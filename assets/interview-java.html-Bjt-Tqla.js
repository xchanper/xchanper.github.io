import{_ as n}from"./Executor框架-BNad5lzh.js";import{_ as e}from"./ThreadLocal结构-SvAV-sNB.js";import{_ as t}from"./SSO-JHFvDKUB.js";import{_ as h}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as p,a as s,d as i,f as a,o as k}from"./app-CHBNztBQ.js";const r="/img/HTTP%E6%BC%94%E8%BF%9B.webp",d="/img/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png",o="/img/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png",g="/img/DNS%E6%9F%A5%E8%AF%A2.webp",c="/img/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B.webp",A="/img/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98.webp",y="/img/%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5.webp",B="/img/%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5.webp",u="/img/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98.webp",C="/img/32%E4%BD%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.webp",F="/img/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.webp",v="/img/%E7%9B%AE%E5%BD%95%E9%A1%B9%E5%92%8C%E7%B4%A2%E5%BC%95%E5%85%B3%E7%B3%BB%E5%9B%BE.webp",b="/img/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.webp",E="/img/I_O%E8%BD%AF%E4%BB%B6%E5%88%86%E5%B1%82.webp",m="/img/%E5%8D%95Reactor%E5%8D%95%E8%BF%9B%E7%A8%8B.webp",f="/img/%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.webp",D="/img/%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.webp",S="/img/Proactor.webp",x="/img/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C.webp",T="/img/CLH%E9%98%9F%E5%88%97.png",P="/img/MySQL%E6%9E%B6%E6%9E%84.webp",I="/img/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.webp",L="/img/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.webp",M="/img/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg",R="/img/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.webp",_="/img/MVC%E5%8E%9F%E7%90%86.png",O="/img/RabbitMQ%E6%A8%A1%E5%9E%8B.jpg",w={},N=r+"#id=D7LAB&originHeight=366&originWidth=782&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",U=d+"#id=N9ti5&originHeight=1081&originWidth=1296&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",H=o+"#id=kVjem&originHeight=794&originWidth=753&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",j=g+"#id=l92M7&originHeight=1095&originWidth=1505&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",q=c+"#id=Rdt00&originHeight=271&originWidth=613&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",Q=A+"#id=puypr&originHeight=854&originWidth=962&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",K=y+"#id=Ed6yQ&originHeight=1004&originWidth=1382&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",G=B+"#id=zADBN&originHeight=561&originWidth=935&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",W=u+"#id=pGugH&originHeight=699&originWidth=1452&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",V=C+"#id=cOAL8&originHeight=976&originWidth=1210&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",J=F+"#id=gi9T3&originHeight=722&originWidth=1166&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",z=v+"#id=mkdtI&originHeight=842&originWidth=1172&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",Y=b+"#id=N5wFA&originHeight=1262&originWidth=962&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",$=E+"#id=aTZtk&originHeight=842&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",X=m+"#id=Xhd2m&originHeight=834&originWidth=1427&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",Z=f+"#id=cxi30&originHeight=1277&originWidth=1514&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",ii=D+"#id=ZGkWX&originHeight=1262&originWidth=1772&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",si=S+"#id=sbg1q&originHeight=654&originWidth=1427&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",ai=x+"#id=oVxf2&originHeight=560&originWidth=587&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",li=n+"#id=GBk0x&originHeight=380&originWidth=561&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",ni=e+"#id=s38Y5&originHeight=794&originWidth=1072&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",ei=T+"#id=ixnaN&originHeight=304&originWidth=1181&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",ti=P+"#id=DyVTi&originHeight=1440&originWidth=1920&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",hi=I+"#id=AzFfx&originHeight=1131&originWidth=1440&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",pi=L+"#id=PE5BI&originHeight=856&originWidth=1142&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",ki=M+"#id=JyJIF&originHeight=303&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",ri=R+"#id=vQ1zV&originHeight=619&originWidth=1440&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",di=_+"#id=jJqZb&originHeight=419&originWidth=737&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",oi=O+"#id=q62UK&originHeight=306&originWidth=687&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=",gi=t+"#id=IasZY&originHeight=931&originWidth=737&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=";function ci(Ai,l){return k(),p("div",null,l[0]||(l[0]=[s(`<h2 id="实习-目的地搜索优化" tabindex="-1"><a class="header-anchor" href="#实习-目的地搜索优化"><span>实习 -- 目的地搜索优化</span></a></h2><p>以前用户在搜索机场数据时，只会展示对应的城市机场信息，新的需求是用户在搜索某个景点信息时，展示对应城市的机场信息。另外优化了两个问题：</p><ul><li>邻近机场距离由机场-邻近城市 -&gt; 机场-邻近机场：增加near_airport_distance的json格式串</li><li>同音不同字的城市机场搜索：cityPinyin -&gt; 机场 的 Map 切换为 MultiMap</li></ul><h3 id="数据库设计" tabindex="-1"><a class="header-anchor" href="#数据库设计"><span>数据库设计</span></a></h3><h4 id="scenic-data" tabindex="-1"><a class="header-anchor" href="#scenic-data"><span>Scenic_Data</span></a></h4><p>4K 多条数据</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">CREATE</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> TABLE \`scenic_data\` (</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  \`id\` </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">bigint</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">20</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) unsigned </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">NOT</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> AUTO_INCREMENT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  \`scenic_id\` </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">varchar</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">32</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">NOT</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> DEFAULT </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  \`scenic_name\` </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">varchar</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">32</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">NOT</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> DEFAULT </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  \`city_code\` </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">char</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">DEFAULT</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  \`city_name\` </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">varchar</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">32</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">DEFAULT</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  \`scenic_longitude\` </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">varchar</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">32</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">NOT</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> DEFAULT </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  \`scenic_latitude\` </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">varchar</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">32</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">NOT</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> DEFAULT </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  \`deleted\` </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">11</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">NOT</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> DEFAULT </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;0&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  \`operator\` </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">varchar</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">32</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">NOT</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> DEFAULT </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  \`create_time\` timestamp </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">NOT</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> NULL</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> DEFAULT</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> CURRENT_TIMESTAMP</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  \`update_time\` timestamp </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">NOT</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> NULL</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> DEFAULT</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> CURRENT_TIMESTAMP</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ON</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> UPDATE</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> CURRENT_TIMESTAMP</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">  PRIMARY</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> KEY</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (\`id\`)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  KEY \`idx_city_code\` (\`city_code\`)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  KEY \`idx_scenic_id\` (\`scenic_id\`)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  KEY \`idx_deleted\` (\`deleted\`)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) ENGINE</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">InnoDB</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> AUTO_INCREMENT</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">7762</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> DEFAULT</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> CHARSET</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">utf8mb4</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="scenic-near-airports" tabindex="-1"><a class="header-anchor" href="#scenic-near-airports"><span>Scenic_Near_Airports</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">CREATE</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> TABLE \`scenic_near_airports\` (</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  \`id\` </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">bigint</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">20</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) unsigned </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">NOT</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> AUTO_INCREMENT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  \`scenic_id\` </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">varchar</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">32</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">NOT</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> DEFAULT </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  \`scenic_name\` </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">varchar</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">32</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">NOT</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> DEFAULT </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  \`near_city_code\` </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">char</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">NOT</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> DEFAULT </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  \`near_airport_code\` </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">char</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">NOT</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> DEFAULT </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;[]&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  \`distance\` </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">11</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) DEFAULT </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;0&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  \`deleted\` </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">11</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">NOT</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> DEFAULT </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;0&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  \`operator\` </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">varchar</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">32</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">NOT</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> DEFAULT </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  \`create_time\` timestamp </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">NOT</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> NULL</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> DEFAULT</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> CURRENT_TIMESTAMP</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  \`update_time\` timestamp </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">NOT</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> NULL</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> DEFAULT</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> CURRENT_TIMESTAMP</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ON</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> UPDATE</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> CURRENT_TIMESTAMP</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">  PRIMARY</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> KEY</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (\`id\`)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  KEY \`idx_scenic_near_airport\` (\`scenic_id\`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">\`near_airport_code\`)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  KEY \`idx_deleted\` (\`deleted\`)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) ENGINE</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">InnoDB</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> AUTO_INCREMENT</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">7589</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> DEFAULT</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> CHARSET</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">utf8mb4</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="核心逻辑" tabindex="-1"><a class="header-anchor" href="#核心逻辑"><span>核心逻辑</span></a></h3><h4 id="景点-邻近机场落库" tabindex="-1"><a class="header-anchor" href="#景点-邻近机场落库"><span>景点/邻近机场落库</span></a></h4><p>ScenicDataPullJob#pullScenicPoiAndComputeNearAirport 每 6H 执行一次</p><ul><li>从景点服务拉取全量景点数据</li><li>过滤有机场的城市、国内景点等等各种过滤</li><li>和DB里面现有的的景点数据做diffAndSave</li><li>计算景点的邻近机场，选取0-300km以内，且距离最近的三个机场</li><li>落到景点邻近机场表里</li></ul><h4 id="本地缓存-搜索树" tabindex="-1"><a class="header-anchor" href="#本地缓存-搜索树"><span>本地缓存/搜索树</span></a></h4><p>InitService#buildSuggestionEnv 服务启动时/每天凌晨执行 (本地缓存1.5G，机器8G，影响不大)</p><ul><li>读取数据库的最新数据，构建 景点id -&gt; 邻近机场 的map集合</li><li>根据拼音构建前缀搜索树 Trie Tree，key=景点拼音，value=景点id <ul><li>服务里缓存了很多前缀树，如城市拼音、城市拼音简称、机场、邻近机场、景点等等，存入一个<code>Map&lt;TrieTreeTypeEnum, TrieTree&gt;</code>里</li><li>TrieTree封装了一个TreeNode根结点，每个TreeNode节点里面是一个TreeNode列表，和当前这个节点保存的字符，以及是否是叶子结点的标志位，叶子结点还会有一个存储景点Id的data字段</li><li>搜索的时候按照用户输入的内容转换成拼音，然后一个个字符匹配，输入全部匹配完或者到达叶子结点即匹配成功，把当前这层后续的所有叶子结点里data域存储的景点Id返回出去，如果中途遇到某个字符不匹配，那么匹配失败返回个null出去</li></ul></li></ul><blockquote><p><code>TrieTree = TreeNode + 对外的方法</code></p><p><code>TreeNode = List&lt;TreeNode&gt; + char + terminal + scenicId</code></p></blockquote><h4 id="搜索逻辑" tabindex="-1"><a class="header-anchor" href="#搜索逻辑"><span>搜索逻辑</span></a></h4><ul><li>用户输入过滤非法字符，转换成拼音</li><li>根据拼音搜索前缀树，获得匹配的景点Id</li><li>然后构造对应的景点信息</li><li>接着用中文过滤一遍，防止中文搜索时同音不同名的景点信息（黄鹤楼/黄河楼）</li><li>然后再过滤没有机场信息的景点</li><li>如果过滤完的结果为空，会根据用户输入去查邻近城市的机场做一个兜底</li><li>最后有一些后置的处理，像城市/景点的搜索热度等等。最后将搜索结果返回</li></ul><h4 id="多线程使用" tabindex="-1"><a class="header-anchor" href="#多线程使用"><span>多线程使用</span></a></h4><p>中转av批量查询接口需求中，需要根据 ftd 批量查询中转联程的AV情况，以前已经有了单个查询请求的接口，这次需要新增批量查询接口。由于每次查询都是一个耗时的RPC调用，因此需要使用多线程提高效率。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">CompletableFuture</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Void</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> allFuture </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> CompletableFuture</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">allOf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">transferAvFlightReqs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">stream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                    .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(request </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> CompletableFuture</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                            .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">supplyAsync</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> queryTransferAv</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">((request)))</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                            .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">thenAccept</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">((res) </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">                                String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> uniqueKey</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getTransferAvUniqueKey</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(request);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">                                map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(uniqueKey, res);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                            }))</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                    .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toArray</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">CompletableFuture</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[]</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">::new</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">allFuture</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Config</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">BATCH_QUERY_TRANSFER_AV_TIMEOUT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">TimeUnit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">MILLISECONDS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要的考虑点是要保证单个请求的失败不影响其它请求（thenAccept），并且基于单次查询的调用时间，通过配置的方式限制批量请求的总时间。</p><h2 id="项目" tabindex="-1"><a class="header-anchor" href="#项目"><span>项目</span></a></h2><h3 id="酷安好物" tabindex="-1"><a class="header-anchor" href="#酷安好物"><span>酷安好物</span></a></h3><p>酷安好物是一个好物推荐和购物商城，用户可以通过网页浏览商品信息、搜索商品、下单等，管理员通过系统后台维护商品<br>SPU/SKU、订单管理、人员管理等。</p><p>技术总体基于 SpringBoot+SpringCloud+MyBatis+Redis。主要<br>使用 SpringBoot 框架完成后台商品 SPU/SKU 的上下架管理<br>使用 MyBatisPlus 完成数据库的增删改查<br>实现 MySQL 的主从同步<br>使用 Redisson 实现分布式锁避免缓存击穿<br>使用 阿里云OSS 实现图片的上传存储<br>使用 Redis 对购物车数据进行缓存，减少对数据库的访问，加快处理速度</p><h4 id="nginx-反向代理" tabindex="-1"><a class="header-anchor" href="#nginx-反向代理"><span>Nginx 反向代理</span></a></h4><p>正向代理代理客户端，反向代理代理服务器。</p><div class="language-properties line-numbers-mode" data-highlighter="shiki" data-ext="properties" data-title="properties" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">upstream gulimall{</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">  server 127.0.0.1:10086</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">server {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">  listen       80</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">  server_name gulimall  *.gulimall</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">  location /static {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">      root   D:\\Tools\\nginx\\html</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">    </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	# 配置请求路由</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">  location / {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">      proxy_pass http://gulimall</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">      proxy_set_header Host $host</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  # include D:\\\\Tools\\\\nginx\\\\conf\\\\conf.d\\\\*.conf;  # 包含了哪些配置文件</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>本机请求 gulimall -&gt; 本地 Nginx 服务器，如果是 /static 路径的静态资源直接从 Nginx 目录下返回</li><li>其它 gulimall 域名下的请求根据 upstream 转发到网关</li></ul><h4 id="jvm-调优" tabindex="-1"><a class="header-anchor" href="#jvm-调优"><span>JVM 调优</span></a></h4><p><strong>JMeter 压测</strong></p><p>添加线程组 -&gt; 查看结果树和汇总报告 -&gt; 分析异常比例、吞吐量、响应时间等。</p><p>发现：直接访问一个控制器的吞吐量可达 25000 QPS；而经过网关再访问吞吐量还剩 5500 QPS 左右，异常数量也会增加；而如果经过 Nginx 代理吞吐量仅剩 2200 QPS 左右。</p><p>优化：</p><ul><li>三级目录原本是根据父目录 id 查三次数据库，查询 DB 速度很慢。可以优化业务逻辑，一次性全部查出再封装树形结构，QPS 从 2500 提高到了 7000。</li><li>商品信息展示的业务，网络传输数据量过大，导致页面加载过慢，可以通过 TO 传输对象精简返回的数据量，加快页面的加载</li></ul><p><strong>JConsole</strong></p><p>Java 监视和管理控制台，根据 PID 连接查看进程信息，可以查看虚拟机内存使用情况，包括堆空间、Eden、Survivor等，包括 Young GC、Old GC 时间，以及线程数量等信息</p><p><strong>jmap</strong><br><code>jstack</code> 查看堆栈信息，以及排查死锁问题<br><code>jhsdb jmap --heap --pid 20536</code> 查看进程使用的GC算法、堆配置信息和各内存区域内存使用信息<br><code>jstat -gc -h3 31736 1000 10</code> 查看 GC 情况，各个空间的使用量<br><code>jmap -dump:format=b,file=dump.hprof 20536</code> 生成堆转储快照 heap profile -&gt; VisualVM/JProfile 查看内存占用情况 -&gt; 定位大对象 -&gt; 定位代码中创建的位置 -&gt; 排查 BUG</p><h4 id="缓存" tabindex="-1"><a class="header-anchor" href="#缓存"><span>缓存</span></a></h4><p>引入 data-redis-starter -&gt; 配置 redis 地址、访问 -&gt; 使用 StringRedisTemplate 操作 Redis （redisTemplate 是 Spring 对 Lettuce/Jedis 的封装）</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Test</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> testRedis</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    ValueOperations</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> stringStringValueOperations </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> redisTemplate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">opsForValue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> val </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> stringStringValueOperations</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Hello&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(val </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Key &#39;Hello&#39; does not exist. Then set it...&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        stringStringValueOperations</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Hello&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;World&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        val </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> stringStringValueOperations</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Hello&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Hello = &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> val);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>购物车缓存</strong></p><p>使用 Redis 的原因：减轻数据库压力、速度快、共享缓存</p><p>具体操作：导入 Spring Cache 和 Redis 依赖坐标，ttl过期时间设为30分钟，<a href="/EnableCaching">@EnableCaching </a> 开启缓存，在对应的控制器方法上标注 <a href="/Cacheable">@Cacheable </a> 注解对结果缓存。在 save 和 delete 方法上标注 <a href="/CacheEvict">@CacheEvict </a> 标注，对数据库做修改时删除缓存，保证数据一致性。</p><p>数据结构：<code>Map&lt;String, Map&lt;String, CatItemInfo&gt;&gt; Cart:UID = {{SKU1 = Info1}, {SKU2 = Info2}}</code></p><ul><li>以 业务名+用户ID 作为 key</li><li>以商品 id 作为值的 field</li><li>以商品相关信息的 json 数据作为值的 value</li></ul><h4 id="多线程使用-1" tabindex="-1"><a class="header-anchor" href="#多线程使用-1"><span>多线程使用</span></a></h4><p>自定义线程池，并使用 CompletableFuture 异步编排实现根据 skuId 检索商品详细信息，SKU 分基本信息、图片信息、销售属性、介绍、规格参数。其中，图片信息是可以和基本信息并发检索的，通过 runAsync 实现，而后面三个属性必须先获取到 SKU 的 spuId 才能检索，因此通过 thenAcceptAsync 实现。最后通过 CompletableFuture.allOf(...) 等待所有检索完成再返回。</p><ul><li><code>CompletableFuture::supplyAsync(Supplier， executor)</code> 相比于 <code>CompletableFuture::runAsync(Runnable， executor)</code> 可以获取返回值</li><li>如果没有指定线程池，则默认使用 ForkJoinPool.commonPool()</li><li>get() 获取结果时，如果结果非空则 reportGet()，否则 waitingGet()</li></ul><p><strong>线程池配置</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ThreadPoolExecutor</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">20</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 200</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">TimeUnit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">SECONDS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">				new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> LinkedBlockingDeque</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10000</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Executors</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">defaultThreadFactory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(),</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">				new</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> ThreadPoolExecutor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">AbortPolicy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">/**</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  * 查询页面详细内容</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  */</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> SkuItemVo</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> item</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Long</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> skuId) throws ExecutionException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> InterruptedException {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    SkuItemVo</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> skuItemVo </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> SkuItemVo</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 1. sku 基本信息</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    CompletableFuture</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">SkuInfoEntity</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> infoFuture </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> CompletableFuture</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">supplyAsync</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        SkuInfoEntity</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> info</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getById</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(skuId);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        skuItemVo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setInfo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(info);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> info;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }, executor);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 2. sku图片信息</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    CompletableFuture</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Void</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> imageFuture </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> CompletableFuture</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">runAsync</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        List</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">SkuImagesEntity</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">images</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> imagesService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getImagesBySkuId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(skuId);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        skuItemVo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setImages</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(images);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }, executor);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 3. 获取spu销售属性组合 list (在 1 之后)</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    CompletableFuture</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Void</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> saleAttrFuture </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> infoFuture</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">thenAcceptAsync</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(res </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        List</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ItemSaleAttrVo</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">saleAttrVos</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> skuSaleAttrValueService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getSaleAttrsBuSpuId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">res</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getSpuId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        skuItemVo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setSaleAttr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(saleAttrVos);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }, executor);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ......</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // TODO 6. 查询当前 sku 是否参与秒杀优惠</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 等待所有任务都完成在返回</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    CompletableFuture</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">allOf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(imageFuture, saleAttrFuture, descFuture, baseAttrFuture).</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> skuItemVo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="订单、库存" tabindex="-1"><a class="header-anchor" href="#订单、库存"><span>订单、库存</span></a></h4><p>业务逻辑：当用户下单时，订单系统生成订单，商品系统扣减库存，促销系统扣减优惠券，最后订单入库。</p><p>可以采用 2PC、3PC、TCC 等分布式事务方案（适合要求强一致性的场景例如金融支付），但本项目采用 MQ 保证事务的最终一致性。</p><h5 id="订单业务" tabindex="-1"><a class="header-anchor" href="#订单业务"><span>订单业务</span></a></h5><p>用户下单后，订单系统需要</p><ul><li>发送订单创建的消息给 MQ，并设置 TTL，经过设定的 TTL 后进入死信队列，监听死信队列的服务根据订单的状态（已支付/未支付）进行后续业务处理（交付仓储物流/关单库存解锁），实现自动关单</li><li>然后进入库存系统锁定库存</li></ul><h5 id="库存锁定" tabindex="-1"><a class="header-anchor" href="#库存锁定"><span>库存锁定</span></a></h5><ul><li>由于订单可能回滚，所以为了能够得到库存锁定的信息，在锁定时需要记录库存工作单（订单信息、商品信息、数量等）</li><li>库存保存在 Redis 中，收到请求后判断库存是否充足，然后减掉 Redis 中的库存（Redis 中的库存扣完就无法下单了）</li><li>锁定成功后向延迟队列发送消息(锁定的相关信息)，实现库存自动解锁。然后修改对应的订单状态，进入支付流程</li><li>支付成功后订单进入出库状态，此时扣除数据库中的库存。如果中途失败，则取消订单，解锁库存等</li></ul><p><strong>库存自动解锁</strong>：库存锁定(Redis 中)后，也会有一个消息发送到延迟队列，经过 TTL 后根据订单状态和工作单状态来判断是否进行库存解锁，只有订单是过期的，且工作单的库存处于锁定状态才进行库存解锁。</p><p>自动关单和自动解锁库存两个业务通过重新查询当前的状态来保证幂等性。</p><h5 id="优惠券业务" tabindex="-1"><a class="header-anchor" href="#优惠券业务"><span>优惠券业务</span></a></h5><ul><li>订单系统下单时，将扣减的优惠券事件放入消息队列中，最终优惠券系统会执行对应的业务，完成后通过手动确认的方式发送应答，告诉 MQ 删除这条消息，防止业务出现异常而消息已经被删除的问题。</li><li>同时订单系统需要将对应的优惠券消息写入数据库，并把状态设为未完成，优惠券系统在消费成功后，也向 MQ 发送一个消息，通知订单系统将这个订单的优惠券业务状态设为完成，这样，即使消息积压导致消息丢失，也能通过定时任务将未完成的消息重新发送，实现最终一致性。</li></ul><h4 id="mq" tabindex="-1"><a class="header-anchor" href="#mq"><span>MQ</span></a></h4><p><strong>消息丢失</strong></p><p>MQ 本身有持久化机制，此外还有：</p><ul><li>消息确认机制 <ul><li>ConfirmCallback</li><li>ReturnCallback</li><li>ConsumerAck</li></ul></li><li>消息生产端给每个消息注入一个唯一 ID，消费者基于 ID 进行校验，实现消息检测，防止消息丢失</li></ul><p>注：分布式 ID 的生成可以使用 自增主键、UUID、Redis、雪花算法等</p><p><strong>重复消费(幂等性)</strong></p><p>防止消息被重复消费，也即解决消费者端幂等性问题。可以通过建立消息的日志表（MySQL/Redis），记录消息的 ID 和执行状态（未执行/已完成），然后根据消息的执行状态做进一步的判断处理。</p><p><strong>消息积压</strong></p><p>一般是消费者端的性能问题。</p><ul><li>扩容，增加消费者的数量</li><li>降级一些非核心业务，减少服务端的压力</li><li>通过监控、日志等手段分析业务逻辑是否影响了性能</li></ul><h4 id="秒杀设计" tabindex="-1"><a class="header-anchor" href="#秒杀设计"><span>秒杀设计</span></a></h4><ul><li>服务单一职责 + 独立部署：秒杀服务即使自己扛不住挂掉，也不影响其他服务</li><li>秒杀链接加密：防止恶意攻击、链接暴露</li><li>库存预热 + 快速扣减：秒杀读多写少，无需每次实时校验库存，提前扣减库存放到 Redis 中，并用信号量控制进来的请求数</li><li>动静分离：nginx 做好动静分离，保证动态请求才打到后端的服务集群，并使用 CDN 网络分担集群压力</li><li>恶意请求拦截：网关层识别非法攻击请求并拦截</li><li>流量错峰：利用验证码、加入购物车等手段均摊流量</li><li>限流、熔断、降级：前后端限流，限制次数，快速失败降级运行，熔断隔离防止雪崩</li><li>队列削峰：所有秒杀成功的请求进入队列，慢慢处理后续流程</li></ul><h3 id="手写spring" tabindex="-1"><a class="header-anchor" href="#手写spring"><span>手写Spring</span></a></h3><h4 id="ioc" tabindex="-1"><a class="header-anchor" href="#ioc"><span>IoC</span></a></h4><h5 id="beanfactory" tabindex="-1"><a class="header-anchor" href="#beanfactory"><span>BeanFactory</span></a></h5><p>最基本的可初始化的容器：DefaultListableBeanFactory 通过一层层的继承关系主要实现了两个接口：</p><ul><li>BeanFactory： Map 存储 BeanName 和 BeanDefinition（全限定类名+属性集合） 的映射关系</li><li>SingletonBeanRegistry：Map 存储 BeanName 和单例 Bean 的映射，需要时候通过 BeanName 从 map 里获取 Bean 对象，如果获取的时候不存在对应的Bean对象，就从BeanFactory中取BeanDefinition实例化（反射/Cglib）后放入map</li></ul><p>注：实例化一般就是反射创建对象，区别于拦截器通过Cglib动态创建代理对象</p><h5 id="applicationcontext" tabindex="-1"><a class="header-anchor" href="#applicationcontext"><span>ApplicationContext</span></a></h5><p>更进一步，ApplicationContext 组合了 BeanFactory（具有加载 BeanDefinition 和 存储 Bean 的功能），还提供了很多额外的扩展点，例如自动装载、后置处理器、Aware 接口、监听器等等。</p><p>注：BeanFactory是需要手动注册Bean的，获取时自动实例化。而Context创建时根据配置自动注册Bean。</p><p>创建 ApplicationContex 时，传入Bean的配置文件，然后进入 refresh() 方法，执行应用上下文的初始化：</p><ul><li>refreshBeanFactory：创建 BeanFactory 装载所有 BeanDefinition（包括各种处理器、监听器）</li><li>invokeBeanFactoryPostProcessor：实例化所有 BeanFactoryPostProcessor 并执行后置处理</li><li>registerBeanPostProcessor：实例化所有 BeanPostProcessor 并执行后置处理</li><li>InitApplicationEventMulticaster：初始化事件发布器，创建所有 ApplicationListener 的集合用于事件处理</li><li>registerListeners：实例化 ApplicationListener 并放入监听器集合</li><li>preInstantiateSingletons：实例化所有单例 Bean</li><li>finishRefresh：发布容器刷新完成事件</li></ul><p>注：事件处理 publishEvent -&gt; multicastEvent -&gt; getListenersForEvent -&gt; onApplicationEvent 具体的监听器负责对事件是否响应、如何响应</p><h4 id="aop" tabindex="-1"><a class="header-anchor" href="#aop"><span>AOP</span></a></h4><p>DefaultAdvisorAutoProxyCreator 是默认的代理创建器，基于容器中所有的 AspectJExpressionPointcutAdvisor 对当前要创建的 Bean 作匹配，然后通过 ProxyFactory 选择基于 JDK/CGLIB 创建实际的代理对象作为 Bean 返回，最终加入到容器中。（基于AspectJ实现的）</p><p>AspectJExpressionPointcutAdvisor 整合了切面 pointcut、拦截方法 advice、表达式 expression，能够基于 expression 做匹配，构建 AdvisedSupport(代理目标、拦截器)。</p><h4 id="bean-生命周期" tabindex="-1"><a class="header-anchor" href="#bean-生命周期"><span>Bean 生命周期</span></a></h4><p>让Bean实现DisposableBean（destroy）, InitializingBean（afterPropertiesSet）, Aware（setters）接口，在容器的各个阶段执行相应的生命周期回调。</p><h4 id="循环依赖" tabindex="-1"><a class="header-anchor" href="#循环依赖"><span>循环依赖</span></a></h4><p>Spring 框架设计解决循环依赖需要用到三个Map：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 一级缓存，存放成品对象</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Map</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Object</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> singletonObjects </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ConcurrentHashMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 二级缓存，存放未填充属性的半成品对象</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">protected</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  final</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Map</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Object</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> earlySingletonObjects </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> HashMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 三级缓存，存放代理对象</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Map</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ObjectFactory</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> singletonFactories </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> HashMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ObjectFactory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取单例 Bean 方法如下：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Object</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getSingleton</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> beanName) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Object</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> singletonObject </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> singletonObjects</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(beanName);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (singletonObject </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) { </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 没有就到二级缓存中取</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        singletonObject </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> earlySingletonObjects</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(beanName);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (singletonObject </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) { </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 二级还没有去三级缓存找，只有代理对象才会放到三级缓存</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">            ObjectFactory</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> singletonFactory </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> singletonFactories</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(beanName);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (singletonFactory </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">                singletonObject </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> singletonFactory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                //把三级缓存中代理工厂的真实对象取出来放入二级缓存</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">                earlySingletonObjects</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(beanName, singletonObject);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">                singletonFactories</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">remove</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(beanName);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> singletonObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>单例 Bean 在实例化后立刻放入三级缓存（非代理 Bean 是一个假工厂直接返回该对象）</li><li>当其他 Bean 依赖此 Bean 时从三级缓存中移除，取出真实对象放入二级缓存提前暴露出来。</li><li>当对象完全创建完成后，调用 registerSingleton 放入一级缓存，同时移除二级和三级缓存中的引用。</li></ul><h4 id="事务管理" tabindex="-1"><a class="header-anchor" href="#事务管理"><span>事务管理</span></a></h4><p>编程式：transactionManager、TransactionTemplate</p><p>声明式：@Transactional（基于TransactionInterceptor）</p><ul><li>TransactionDefinition：事务定义信息 <ul><li>事务隔离级别</li><li>传播行为、超时</li><li>只读</li><li>回滚规则</li></ul></li><li>TransactionStatus：事务运行状态 <ul><li>是否回滚</li><li>暂停的外部事务</li><li>并且封装了一个实际的事务对象（Connection）</li></ul></li><li>TransactionManager：事务管理器，Spring 事务策略的核心管理器。 <ul><li>getTransaction()</li><li>commit()</li><li>rollback()</li></ul></li><li>TransactionSynchronizationManager：基于ThreadLocal绑定线程事务，以及提供一些回调</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> abstract</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> TransactionSynchronizationManager</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 当前线程开启状态的所有数据库连接 Map</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // key是DataSource数据源对象</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // value是数据库连接ConnectionHolder</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ThreadLocal</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Map</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Object</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> resources </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> NamedThreadLocal</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Transactional resources&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 事务同步器集合，可扩展的接口，定义了若干不同事物阶段的回调</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ThreadLocal</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Set</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">TransactionSynchronization</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> synchronizations </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> NamedThreadLocal</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Transaction synchronizations&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构"><span>数据结构</span></a></h2><h4 id="排序算法" tabindex="-1"><a class="header-anchor" href="#排序算法"><span>排序算法</span></a></h4><p>冒泡 $O(n^2)$, 选择 $O(n^2)$, 插入 $O(n^2)$, 归并 $O(nlogn)$, 快排 $O(nlogn)$, 堆排 $O(nlogn)$</p><h4 id="查找算法" tabindex="-1"><a class="header-anchor" href="#查找算法"><span>查找算法</span></a></h4><p>顺序查找、二分查找、哈希查找、树表查找（二叉排序树、平衡树、红黑树）</p><h4 id="满二叉树和完全二叉树" tabindex="-1"><a class="header-anchor" href="#满二叉树和完全二叉树"><span>满二叉树和完全二叉树</span></a></h4><p>满二叉树:每一层的节点数都达到最大值，即$2<sup>{h-1}$个，其中h是树的高度。满二叉树的总节点数是$2</sup>h-1$个。<br>完全二叉树:除了最后一层外，其他层的节点数都达到最大值，且最后一层的节点都连续集中在最左边。总节点数在$2<sup>{h-1}$到$2</sup>h-1$之间。</p><p>满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树。</p><h4 id="图" tabindex="-1"><a class="header-anchor" href="#图"><span>图</span></a></h4><p>一个图就是一些顶点的集合，这些顶点通过一系列边结对（连接）。</p><p>存储结构：邻接表、十字链表、邻接多重表<br>Prim算法：选已连通集合到未连通集合最小权值边的顶点<br>Kruscal算法：选最小权值边，直到构成一个连通图</p><h4 id="哈希冲突" tabindex="-1"><a class="header-anchor" href="#哈希冲突"><span>哈希冲突</span></a></h4><ul><li>开放定址法：从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。线行探查法、平方探查法、双散列函数探查法。</li><li>链地址法：将哈希值相同的元素构成一个同义词的单链表</li><li>再哈希法</li><li>公共溢出区</li></ul><h4 id="布隆过滤器" tabindex="-1"><a class="header-anchor" href="#布隆过滤器"><span>布隆过滤器</span></a></h4><p>能够快速检索一个元素是否在给定的大集合中，一个布隆过滤器中有多个不同的哈希函数，</p><ul><li>加入一个元素时，取哈希，对应位数组下标置 1</li><li>判断一个元素是否存在时，计算哈希判断对应位是否为 1。都为 1 则可能存在，只要有一位非 1，则一定不存在</li></ul><p>使用场景：快速判断一个数是否存在于大数据量的集合中、防止缓存穿透、邮箱的垃圾过滤、黑名单功能、去重等。</p><h2 id="计网" tabindex="-1"><a class="header-anchor" href="#计网"><span>计网</span></a></h2><h3 id="基础" tabindex="-1"><a class="header-anchor" href="#基础"><span>基础</span></a></h3><h4 id="tcp-ip-网络模型" tabindex="-1"><a class="header-anchor" href="#tcp-ip-网络模型"><span>TCP/IP 网络模型</span></a></h4><p>物数网传会表应。其中只有应用层在用户空间，其它层都在 OS 内核中。</p><ol><li><strong>应用层</strong>：网络应用程序和网络之间的接口</li><li><strong>表示层</strong>：负责把数据转换成兼容另一个系统能识别的格式</li><li><strong>会话层</strong>：负责建立、管理和终止表示层实体之间的通信会话</li><li><strong>传输层</strong>：负责端到端的数据传输</li><li><strong>网络层</strong>：负责数据的路由、转发、分片</li><li><strong>数据链路层</strong>：负责数据的封帧和差错检测，以及 MAC 寻址；</li><li><strong>物理层</strong>：负责在物理网络中传输数据帧</li></ol><h4 id="键入网址到网页显示" tabindex="-1"><a class="header-anchor" href="#键入网址到网页显示"><span>键入网址到网页显示</span></a></h4><ol><li>对 URL 网址进行解析，生成 HTTP 请求消息</li><li>进行 DNS 查询：域名 -&gt; IP地址</li><li>和目标服务器通过三次握手，建立 TCP 连接。连接建立后，封装 TCP 报文，交付网络层</li><li>网络层封装IP数据包，写入源 IP 地址、目标 IP 地址、协议等信息，然后交付网络接口层</li><li>网络接口层通过 ARP 协议获得下一跳 MAC 地址，封装数据帧发送出去。</li><li>数据包经过若干个交换机/路由器的转发，来到目标 IP 所在的子网，再交给目标 IP 对应的的服务器</li><li>服务器一层层解析数据包，根据端口交付给对应的进程。</li><li>进程将响应数据封装成 HTTP 响应报文，然后也一层层封装，发回给客户端进程，也就是浏览器。</li><li>客户端的浏览器对接收到的数据包解析，然后渲染整个网页的显示。</li><li>最后，如果没有别的数据请求了，双方就进行 TCP 四次挥手断开连接</li></ol><h4 id="内核收发数据包" tabindex="-1"><a class="header-anchor" href="#内核收发数据包"><span>内核收发数据包</span></a></h4><p>应用程序通过系统调用，跟 Socket 层进行数据交互，经过传输层、网络层、网络接口层，最后由网卡负责接收和发送网络包。</p><p><strong>接收</strong></p><ul><li>网卡接收到一个网络包后，通过 DMA 写入 RingBuffer 环形缓冲区</li><li>接着网卡向 CPU 发起硬件中断（屏蔽中断 -&gt; 软中断 -&gt; 取消屏蔽），唤醒数据接收服务程序</li><li>内核中的<code>ksoftirqd</code>线程负责处理软中断，通过 poll 方法轮询处理数据（从 RingBuffer 取 sk_buff 帧交由协议栈，放入 Socket 接收缓冲区）</li><li>应用层程序调用 Socket 接口，将接收缓冲区数据拷贝到应用层缓冲区，然后唤醒用户进程</li></ul><p><strong>发送</strong></p><ul><li>程序调用 socket 发送数据时，内核申请一个内核态的 sk_buff 内存，将待发送数据拷贝到 sk_buff 中，并加入发送缓冲区</li><li>网络协议栈从发送缓冲区中取出 sk_buff，向下逐层处理（对于 TCP，会拷贝一份 sk_buff 副本以支持重传）</li><li>网卡驱动程序从发送队列中读取 sk_buff，挂到 RingBuffer 中，并将数据映射到 DMA 内存区域，触发真实发送</li><li>发送完成后，网卡触发硬中断释放内存（sk_buff 和 RingBuffer，收到 ACK 后释放 TCP 数据包对应的原始 sk_buff）</li></ul><p><strong>期间共发生了三次内存拷贝：</strong><br>用户数据 -&gt; 内核 sk_buff -&gt; TCP 拷贝 -&gt; sk_buff 大于 MTU 时拷贝成多份小 sk_buff</p><h4 id="网络分析" tabindex="-1"><a class="header-anchor" href="#网络分析"><span>网络分析</span></a></h4><p>一般使用 tcpdump 在 Linux 下抓取数据包存入 pcap 文件，然后到 Wireshark 中进行分析</p><p><code>tcpdump -i &lt;eth0&gt; &lt;protocol&gt; and host &lt;ip&gt; -nn</code></p><ul><li>数据格式：<code>时间戳 协议 源地址.源端口 &gt; 目的地址.目的端口 网络包详情</code></li><li>数据链路层可以得到 源 MAC 地址、目标 MAC 地址、类型等</li><li>IP 层可以得到 源 IP、目的 IP、TTL、IP 包长度、协议等字段</li></ul><h3 id="http" tabindex="-1"><a class="header-anchor" href="#http"><span>HTTP</span></a></h3><h4 id="http-协议" tabindex="-1"><a class="header-anchor" href="#http-协议"><span>HTTP 协议</span></a></h4><p>超文本传输协议，超文本指文字、图片、视频等等信息，传输指在多个设备之间，协议指规定了通信的方式。</p><p><strong>状态码</strong></p><ul><li>1xx 提示信息</li><li>2xx 成功。如 200 OK；204 No Content</li><li>3xx 重定向。如 301 永久重定向；304 资源未修改</li><li>4xx 发送报文有误。如 400 请求错误；404 资源不存在</li><li>5xx 服务器处理出错。如 500 服务器内部错误；503 服务器忙</li></ul><p><strong>字段</strong></p><ul><li>Host: 服务器域名</li><li>Content-Length: 本次回应的数据长度</li><li>Connection: 是否使用长连接 Keep-Alive。只要任意一端没有提出断开，就保持TCP连接状态</li><li>Content-Type: 服务器回应客户端本次数据的格式 <code>Content-Type: text/html; Charset=utf-8</code></li><li>Accept: 客户端声明自己接收的数据格式，<code>Accept: */*</code>表示任意</li><li>Content-Encoding / Accept-Encoding: 发送 / 可接受的压缩格式</li></ul><h4 id="http-缓存" tabindex="-1"><a class="header-anchor" href="#http-缓存"><span>HTTP 缓存</span></a></h4><ol><li>强制缓存：根据响应中的 Cache-Control (相对时间) 和 Expires (绝对时间) 判断请求是否过期，没过期直接从缓存中取响应结果</li><li>协商缓存：强制缓存没有命中时，可以与服务端协商之后，通过协商结果来判断是否使用本地缓存，一般响应 304 告知使用缓存。两种头部实现 <ul><li>Last-Modified 和 If-Modified-Since 根据时间判断是否有更新</li><li>Etag 和 If-None-Match 根据唯一标识判断 （类似CAS）</li></ul></li></ol><h4 id="http-优化" tabindex="-1"><a class="header-anchor" href="#http-优化"><span>HTTP 优化</span></a></h4><p><strong>尽量避免发送 HTTP 请求</strong></p><p>对于重复性的 HTTP 请求，通过缓存技术，避免发送请求。具体的：</p><ul><li>客户端把第一次请求以及响应的数据保存在本地磁盘上，key 是 URL，value 是响应</li><li>响应过期后，再次发送请求会在 Etag 头部带上唯一标识响应的摘要，服务器将摘要和本地资源作比较</li><li>如果一致，响应 304 Not Modified，无需携带数据</li></ul><p><strong>减少请求次数</strong></p><ul><li>减少重定向请求次数：<br>如果资源转移了，且由代理服务器转发，可能产生多次重定向。而如果重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了</li><li>合并请求： <ul><li>把多个访问小文件的请求合并成一个大的请求，减少重复发送的 HTTP 头部</li><li>例如对于很多小图片，可以使用 CSS Image Sprites 合成一个大图片；服务端 Webpack 工具打包 js/css 资源；图片二进制数据用 Base64 编码跟随 HTML 一起发送</li><li>但可能一个小资源变化后，必须重新下载整个大资源</li></ul></li><li>延迟发送请求： <ul><li>按需下载，用户滑动到某个元素才加载</li></ul></li></ul><p><strong>减少响应数据的大小</strong></p><ul><li>无损压缩：例如霍夫曼编码、gzip，适用于文本、代码、可执行文件等</li><li>有损压缩：WebP/PNG、H264/H265...，适用于音频、视频、图片等</li></ul><h4 id="https-协议" tabindex="-1"><a class="header-anchor" href="#https-协议"><span>HTTPS 协议</span></a></h4><p>HTTP 默认端口 80，HTTPS 默认端口 443。HTTPS 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</p><ul><li>混合加密：通信建立前基于非对称加密的数字证书交换<code>会话秘钥</code>，通信过程中基于对称加密用<code>会话秘钥</code>来加密明文数据</li><li>摘要算法：通过哈希函数计算传输内容的指纹，保证消息完整性。</li><li>数字证书：将服务器公钥放在 CA 机构的数字证书中，只要证书是可信的，公钥就是可信的</li></ul><p>非对称加密算法：RSA、DSA、ECDHE...<br>对称加密算法：DES、AES、RC5...<br>散列摘要算法：SHA1、SHA256、MD5...</p><h5 id="tls-握手" tabindex="-1"><a class="header-anchor" href="#tls-握手"><span>TLS 握手</span></a></h5><p><strong>RSA 密钥协商算法</strong></p><p>HTTP 完成 TCP 连接建立需要三次握手，而 HTTPS 还要进行 SSL/TLS 四次握手（2个RTT）。旧版 TLS 使用 RSA 算法实现：</p><ul><li>第一次 - 客户端：<code>Client Hello</code> 包括 TLS版本 + client_random + 支持的密码套件</li><li>第二次 - 服务端：<code>Server Hello</code> 包括 确认 TLS 版本 + server_random + 选择的密码套件，以及 <code>Server Certificate</code> 内含数字证书、</li><li>第三次 - 客户端： <ul><li><code>Client Key Exchange</code> 内含用服务端 RSA 公钥加密的新随机数 <code>pre-master</code></li><li>然后双方基于三个随机数生成基于对称加密的会话密钥。</li><li>接着发送 <code>Change Cipher Spec</code> 告诉服务端开始使用加密方式发送消息</li><li>最后发送 <code>Encrypted Hashshake Message (Finished)</code>，对之前的数据做个摘要并用会话密钥加密，让服务器做验证，确保加密通信安全可用</li></ul></li><li>第四次 - 服务端：也发送 <code>Change Cipher Spec</code> 和 <code>Encrypted Hashshake Message</code>，验证加密通信安全可用</li></ul><p>RSA 算法缺陷：不支持前向保密，一旦服务端私钥泄露，过去所有被截获的 TLS 通信密文都会被破解。因此产生了 ECDHE 密钥算法。</p><p><strong>改进：ECDHE 密钥协商算法</strong></p><ul><li>基于离散对数、ECC 椭圆曲线计算得到会话密钥</li><li>支持前向保密</li></ul><h5 id="数字证书" tabindex="-1"><a class="header-anchor" href="#数字证书"><span>数字证书</span></a></h5><p>用来认证公钥持有者的身份，防止第三方进行冒充。</p><ul><li>数字证书 = 公钥 + 持有者信息 + CA 机构信息 + CA 对这份文件的数字签名、算法、有效期等</li><li>其中数字签名由 CA 对持有者的相关信息 Hash 后用 CA 私钥加密而得</li><li>客户端从服务端拿到数字证书后，用 CA 公钥解密数字签名，与服务端信息做对比，一致则是可信赖的</li></ul><h4 id="http-演进" tabindex="-1"><a class="header-anchor" href="#http-演进"><span>HTTP 演进</span></a></h4>`,173),i("figure",null,[i("img",{src:N,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s('<p><strong>HTTP/1.1</strong></p><p>优点：简单、灵活、易于扩展、应用广泛、跨平台。相比于1.0，HTTP/1.1 使用长连接减少连接建立释放的开销，支持管道化传输，可以一次发起多个请求</p><p>缺点：</p><ul><li>无状态，得用Cookie解决</li><li>不安全：明文传输</li><li>性能一般：存在响应的队头阻塞问题（HTTP 完成一个请求+响应才能处理下一个）</li></ul><p><strong>HTTP/2</strong></p><ul><li>基于HTTPS，安全性得到保证</li><li>头部压缩：HPack 算法压缩 Header 部分固定重复的字段</li><li>二进制帧：分数据帧和控制帧两类</li><li>多路复用：一个 TCP 连接包含多个 Stream，不同的 HTTP 请求通过 Stream ID 区分</li><li>支持服务器主动推送（偶数号 Stream）</li><li>缺陷：由于基于TCP，仍然存在 TCP 层队头阻塞问题（只有前一个字节数据到达，后面的字节数据才能从内核缓冲区中取出）</li></ul><p><strong>HTTP/3</strong></p><p>使用基于 UDP 的 QUIC 协议（一个在 UDP 之上的伪 TCP + TLS + HTTP/2 的多路复用协议）。特点：</p><ul><li>单向递增的 Packet Number，配合 StreamID 和 Offset 字段，支持乱序确认而不影响数据包的正确组装</li><li>无队头阻塞：多个 Stream 之间独立，互不影响。某个流发生丢包仅影响该流</li><li>更快的连接建立：QUIC 本身包含 TLS 1.3，一个 RTT 内就可以完成连接建立和密钥协商</li><li>支持连接迁移：通过<code>连接ID</code>标记通信的两个端点，避免网络切换后的握手、慢启动造成网络卡顿</li><li>优化 HTTP 层：简化帧结构、QPack 压缩算法</li></ul><h4 id="get-和-post" tabindex="-1"><a class="header-anchor" href="#get-和-post"><span>Get 和 Post</span></a></h4><ul><li>Get 的语义是从服务器获取指定的资源，请求的参数一般是以 KV 形式写在 URL 中（浏览器会对 URL 的长度有限制， HTTP协议没有）</li><li>POST 的语义是根据请求体对指定的资源做出处理，请求携带的数据一般是在报文 body 中，格式任意，大小不限</li><li>Get 方法是安全且幂等的，不会破坏服务器上的资源，且多次执行的结果相同（因此 GET 请求的数据可以缓存，POST 需要手动设置）。</li><li>Post 方法不是安全，也不是幂等的。</li></ul><p>HTTP 请求都是明文，因此GET/POST都不安全，此外GET没有规定不能携带请求体，POST请求URL也可以有参数。</p><h4 id="对比-rpc" tabindex="-1"><a class="header-anchor" href="#对比-rpc"><span>对比 RPC</span></a></h4><p>纯裸 TCP 可以收发数据，但它是个无边界的数据流，上层需要定义消息格式用于定义消息边界。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。RPC本质上是一种调用方式，具体的实现 gRPC/Thrift 才是协议，目的是希望程序员能像调用本地方法那样去调用远端的服务方法。当然 RPC 也不一定非得基于 TCP。</p><p>区别：</p><ul><li>服务发现：RPC一般有专门的中间服务，如 Zookeeper 来保存服务名和IP信息（HTTP当然也能实现）</li><li>底层连接形式：RPC使用连接池</li><li>传输内容：HTTP报文非常冗余，而RPC定制化程度高，性能也更好。因此内网服务之间通常使用 RPC。</li></ul><p>不过，HTTP/2 通过压缩做了很多改进，性能甚至优于RPC，例如 gRPC 基于 HTTP/2 实现。但由于历史原因，RPC仍在使用。</p><h3 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp"><span>TCP</span></a></h3><h4 id="tcp-udp-区别" tabindex="-1"><a class="header-anchor" href="#tcp-udp-区别"><span>TCP/UDP 区别</span></a></h4><ul><li>TCP是有连接的、面向字节流的可靠传输协议。</li><li>UDP是无连接的，面向数据报的协议，尽最大努力交付，不保证可靠传输。</li><li>TCP提供流量控制，即源端通过滑动窗口来告诉对端自己的发送窗口大小，从而控制对端发送数据的速度；UDP没有流量控制。</li><li>TCP提供拥塞控制，即当网络拥塞时，TCP会降低自己的发送速度，从而避免网络拥塞的恶性循环；UDP没有拥塞控制。</li><li>TCP开销大，头部至少20个字节，而UDP头部固定只有8个字节。</li></ul><h4 id="三次握手" tabindex="-1"><a class="header-anchor" href="#三次握手"><span>三次握手</span></a></h4>',21),i("figure",null,[i("img",{src:U,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s('<p><strong>过程：</strong></p><ul><li>首先服务端主动监听某个端口，处于 Listen 状态</li><li>客户端随机一个序列号，并发送 SYN 报文给服务端。此时客户端处于 SYN-SENT 状态</li><li>服务端接收到客户端的 SYN 报文后，也随机一个序列号，然后发送 SYN+ACK 报文给客户端，并且确认客户端报文的序列号。此时服务端处于 SYN-RCVD 状态</li><li>客户端收到服务端报文后，序列号+1，再次向服务端回应一个 ACK 报文，同时确认服务端报文的序列号。此次报文已经可以携带数据了。之后客户端处于 ESTABLISHED 状态</li><li>服务端收到客户端应答报文后，也进入 Established 状态。三次握手完成。</li></ul><p>TCP 通过 (源IP、源端口、目的IP、目的端口) 这样的四元组来唯一确定一条连接。</p><p><strong>为什么需要三次握手：</strong></p><ul><li>首要原因是防止旧的（阻塞在网络中）重复连接初始化造成混乱。如果只有两次握手，服务端没有中间状态给客户端来阻止旧连接，导致连接释放后服务端又建立一个旧连接，造成资源浪费。</li><li>同步双方的初始序列号，两次握手只能保证服务端确认了客户端的序列号，不能保证客户端确认了服务端的序列号。</li></ul><p><strong>握手丢失</strong></p><ul><li>第一次握手 SYN 丢失: 触发超时重传，Linux 会重传 5 次，且超时时间 RTO 呈指数上涨（翻倍 1 -&gt; 3 -&gt; 7 -&gt; 15 -&gt; 31）</li><li>第二次握手 SYN + ACK 丢失：客户端重传 SYN，服务端重传 SYN + ACK，一直重传至最大次数</li><li>第三次握手 ACK 丢失：服务端处于 SYN_RECV 状态，一直重传 SYN + ACK 直至最大次数后断开连接。客户端处于 Established 状态，由于 TCP 保活机制，可能持续 2 小时才会发现该连接已失效，而如果客户端已经发送数据了，会一直重传数据包直至最大次数（默认 15 次）</li></ul><p>注：</p><ul><li>所有重传次数都有<code>/proc/sys/net/ipv4/</code>下的内核参数限定</li><li>网络包进主机顺序：Wire -&gt; NIC -&gt; tcpdump -&gt; netfilter/iptables（防火墙）</li><li>网络包出主机顺序：iptables -&gt; tcpdump -&gt; NIC -&gt; Wire</li></ul><h4 id="四次挥手" tabindex="-1"><a class="header-anchor" href="#四次挥手"><span>四次挥手</span></a></h4>',10),i("figure",null,[i("img",{src:H,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s('<p><strong>过程：</strong></p><ul><li>客户端打算关闭连接时，会发送一个 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。</li><li>服务端收到该报文后，回复一个 ACK 应答，进入 CLOSE_WAIT 状态。</li><li>客户端收到服务端的 ACK 应答后，进入 FIN_WAIT_2 状态。</li><li>等服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。</li><li>客户端收到服务端的 FIN 报文后，也回复一个 ACK 应答，之后进入 TIME_WAIT 状态</li><li>服务端收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 2MSL（最大报文生存时间，Linux中为30s） 时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭。</li></ul><p><strong>为什么需要四次挥手？</strong></p><ul><li>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端把这些数据都处理发送完，才发送 FIN 报文给客户端来表示现在同意关闭连接。</li></ul><p>也就是要等待服务端把手上的数据处理发送完再关闭。</p><p><strong>为什么需要 TIME_WAIT 状态？</strong></p><ul><li>等待 2MSL 让两个方向上现有的数据包都被丢弃，使得旧连接的数据包在网络中都自然消失，防止被后面相同四元组的新连接错误的接收</li><li>等待足够的时间以确保第四次挥手的 ACK 能让服务端接收，从而帮助其正常关闭</li></ul><p>TIME_WAIT 会占用系统资源，因此在高并发下可以适当调整该时间，避免资源浪费和连接延迟。例如开启 tcp_tw_reuse 重用处于 TIME_WAIT 状态的连接，并开启 PAWS 防回绕时间戳（双方维护最近一次收到数据包的时间戳）</p><p><strong>三次挥手</strong></p><p>如果第一次挥手后，如果被动关闭方接收到 FIN 且没有数据要继续发送，同时开启了 TCP 延迟确认机制，那么第二、三次挥手 ACK+FIN 可以合并传输，实现三次挥手。</p><p>TCP 延迟确认：没有响应数据要发送时，ACK 将延迟一段时间随数据一块发送，以提高网络效率。</p><h4 id="重传机制" tabindex="-1"><a class="header-anchor" href="#重传机制"><span>重传机制</span></a></h4><p><strong>超时重传：</strong><br>在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文（数据包丢失/确认应答丢失），就会重发该数据。</p><p>问题：超时重传时间 RTO 的设定，理论上应略大于 RTT。但RTT无法准确计算，Linux采用加权移动平均，采样估计。</p><p><strong>快速重传：</strong><br>当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p><p>问题：重传时是重传一个还是重传所有已经发出去的数据包，只重传一个可能造成延迟重传，重传所有可能浪费网络资源</p><p><strong>SACK: Selective ACK</strong><br>在 TCP 头部「选项」字段里加一个 SACK，将已收到的数据信息发给「发送方」，这样发送方就可以只重传丢失的数据。</p><p><strong>Duplicate SACK：</strong><br>使用 SACK 来告诉「发送方」有哪些数据被重复接收了，这样「发送方」就知道数据没有丢，是「接收方」的 ACK 确认报文丢了。</p><h4 id="流量控制" tabindex="-1"><a class="header-anchor" href="#流量控制"><span>流量控制</span></a></h4><p>流量控制是为了避免「发送方」的数据填满「接收方」的缓存，并不涉及整体网络中的流量。</p><p><strong>滑动窗口：</strong></p><p>为了提高网络的传输效率，引入滑动窗口，双方各自维护发送窗口和接收窗口。在发送窗口范围内的数据都可以发送出去，窗口后延之外的数据都是暂时不能发送的数据。随着接收到的数据，窗口会向后移动。</p><p>一般由接收方告诉发送方自己还有多少缓冲区可以用于接收数据，发送方根据接收方的处理能力调整窗口大小。但双方窗口只是近似相等，传输过程存在延迟，窗口也时刻在变化。发送窗口 = min(拥塞窗口，接收窗口)</p><p><strong>优化点</strong></p><ol><li>为了防止资源紧张时，操作系统减小缓存，同时收缩窗口，导致丢包和窗口变负值的情况，TCP规定必须先收缩窗口，再减少缓存。窗口缩减为0后，需要定时发送窗口探测报文，确认当前窗口大小，避免双方持久等待。</li><li>糊涂窗口综合征：发送方为了填满接收方几个字节的窗口，发送一整个 TCP 报文，而 TCP + IP 首部就有40字节，会造成极大资源浪费。</li></ol><ul><li>接收方在窗口小于 min(MSS, 0.5*cache) 时，就发送0窗口通告</li><li>Nagle 延迟处理算法：必须等窗口 &gt;=MSS 且数据大小 &gt;= MSS，或者收到之前发送数据的 ACK，才会继续发送；否则一直囤积数据。</li><li>接收方不通告小窗口 + 发送方开启 Nagle 算法，才能避免糊涂窗口综合症。</li></ul><h4 id="拥塞控制" tabindex="-1"><a class="header-anchor" href="#拥塞控制"><span>拥塞控制</span></a></h4><p>拥塞控制是为了避免「发送方」的数据填满整个网络，由发送方维护，根据网络的拥塞程度动态变化。（以下窗口大小的单位都是 MSS，而不是个）</p><p><strong>慢启动</strong></p><p>指在刚刚加入网络的连接中，一点一点地提速，不要一上来就把链路占满。开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。每当收到一个ACK，cwnd+1；也就是说每经过一个RTT，cwnd = cwnd*2，呈指数上升。阈值ssthresh（slow start threshold）慢启动门限是一个上限，当cwnd &gt;= ssthresh时，就会进入拥塞避免算法。</p><p><strong>拥塞避免</strong></p><p>cwnd超过慢启动门限后，每收到一个ACK，cwnd = cwnd + 1/cwnd；也就是说每经过一个RTT，cwnd = cwnd + 1。此时发包数呈线性增长，避免增长过快导致网络拥塞。</p><p><strong>拥塞发生</strong></p><p>一旦发生丢包、延时导致重传，进入拥塞发生阶段：ssthresh = 0.5 * cwnd，cwnd重置为1 （Linux初始值为10）</p><p><strong>快重传</strong></p><p>当接收方发现一个乱序到达的报文段，就会发送三次前一个包的 ACK。发送端接收到三个相同的ACK报文，就会进行快速重传，不必等到超时再重传。这时设置 cwnd /= 2，ssthresh = cwnd，进入快恢复。</p><p><strong>快恢复</strong></p><p>快速恢复算法是认为，如果还能收到 3 个重复的 ACK 说明网络也没那么糟糕，因此没必要像 RTO 超时那么强烈。此时发送方把 ssthresh 设为当前 cwnd 的一半</p><h4 id="半-全连接队列" tabindex="-1"><a class="header-anchor" href="#半-全连接队列"><span>半/全连接队列</span></a></h4><p>TCP 三次握手时，Linux 会维护两个队列：</p><ul><li>半连接队列，也称 SYN 队列，底层是哈希表 <ul><li>服务端收到客户端的 SYN 后，内核会把该连接存储到半连接队列中，并响应 SYN + ACK</li><li>SYN 洪泛攻击、DDos 都是半连接队列溢出</li></ul></li><li>全连接队列，也称 accept 队列，底层是链表 <ul><li>服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列中移除，然后创建新的完全连接加入全连接队列，等待进程调用 accept 把连接取出</li></ul></li></ul><p>不管是半连接，还是全连接队列，都有最大长度限制，超过后会直接丢弃或返回 RST 包。需要注意，TCP 三次握手的过程是发生在 accept 调用之前的。</p><h4 id="tcp-优化" tabindex="-1"><a class="header-anchor" href="#tcp-优化"><span>TCP 优化</span></a></h4><p><strong>三次握手</strong></p><ul><li>客户端：可以根据网络稳定性、目标服务器繁忙程度修改 SYN 重传次数，调整握手时间上限。例如在内网中降低重试次数，尽快把错误暴露给应用程序</li><li>服务端：调整半/全连接队列长度、SYN+ACK 报文重传次数</li><li>绕过三次握手：tcp_fastopen 减少一个 RTT</li></ul><p><strong>四次挥手</strong></p><ul><li>主动方：调整 FIN 报文重传次数、FIN_WAIT2 状态时间、孤儿连接上限</li></ul><h4 id="分片问题" tabindex="-1"><a class="header-anchor" href="#分片问题"><span>分片问题</span></a></h4><p>如果TCP层不进行分片，仅在IP层分片，那么当一个TCP报文段的某个IP分片丢失，接收方的IP层无法组装成一个完整的TCP报文，也就不会响应ACK给发送方。于是发送方就会一直等待直到超时重传，因此由IP层进行分片传输效率很低。</p><p>所以，为了达到最佳的传输效能 TCP 协议在建立连接的时候通常要协商双方的 MSS 值，使得IP包长度不会大于MTU，也就不用IP分片了。这样即使一个IP分片丢失，进行重发时也是以 MSS 为单位。</p><h4 id="粘包问题" tabindex="-1"><a class="header-anchor" href="#粘包问题"><span>粘包问题</span></a></h4><p>对于UDP，OS不会对消息进行拆分，每个UDP报文就是一个完整的用户消息。<br>而对于TCP，消息可能会被操作系统分组成多个 TCP 报文，因此接收方的程序如果不知道发送方发送的消息长度/边界，就无法读出一个有效的用户消息。因此我们说 TCP 是面向字节流的协议。</p><p>当两个消息各自的部分内容被分到同一个 TCP 报文时，即产生 TCP 粘包问题，这时接收方如果不知道消息边界的话，无法读出有效的信息。</p><p><strong>解决方法</strong></p><ul><li>固定长度的消息：不灵活</li><li>特殊字符作为边界：两个用户消息之间插入特殊字符，例如 HTTP 协议通过回车符+换行符作为报文的边界（注意转义）</li><li>自定义消息结构：分包头和数据，在包头里记录数据部分的长度，接收方通过解析包头就可以知道消息的边界了。</li></ul><h4 id="序列号和确认号" tabindex="-1"><a class="header-anchor" href="#序列号和确认号"><span>序列号和确认号</span></a></h4><p><strong>序列号</strong></p><ul><li>初始序列号：TCP 建立连接时，客户端和服务端基于时钟、源/目的 IP/端口 生成的随机数</li><li>序列号：TCP 头部的一个 32位 无符号数字段，到达 4G 后归零。标识了 TCP 发送端到 TCP 接收端的数据流的一个字节，用于传输确认、丢失重传、有序接收。 <ul><li>序列号 = 上一次发送的序列号 + 数据长度。如果上一次是 SYN/FIN，则改为上一次序列号 +1</li></ul></li></ul><p>客户端和服务端随机生成初始序列号，以避免历史报文被下一个相同四元组的连接接收。但也无法完全避免，可以开启 TCP 时间戳机制，防止序列号回绕。</p><ul><li>合法的序列号：报文的序列号比<code>期望下一个收到的序列号</code>要大</li><li>合法的时间戳：报文的时间戳比<code>最后收到的报文时间戳</code>要大</li></ul><p><strong>确认号</strong></p><p>指下一次「期望」收到的数据的序列号，发送端收到接收方发来的 ACK 确认报文以后，就可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题。</p><ul><li>确认号 = 上一次收到的报文序列号 + 数据长度。如果收到的是 SYN/FIN，则改为上一次序列号 +1</li></ul><h4 id="保活机制" tabindex="-1"><a class="header-anchor" href="#保活机制"><span>保活机制</span></a></h4><p>如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，并且开启了 TCP-keepalive 机制，那么内核里的 TCP 协议栈就会发送探测报文。</p><ul><li>如果对端正常响应，那么 TCP 保活时间重置，等待下一次保活时机到来</li><li>如果对端连续几次没有响应，达到保活探测次数后，TCP 会报告该 TCP 连接已死亡</li></ul><p>如果没有开启 TCP-keepalive，并且双方都没有进行数据传输，那么客户端和服务端的 TCP 连接将会一直保持存在。</p><h4 id="关闭连接" tabindex="-1"><a class="header-anchor" href="#关闭连接"><span>关闭连接</span></a></h4><p>关闭 socket 有两个系统调用：</p><ul><li>close() 同时关闭 socket 发送方向和读取方向，使得 socket 不再有发送和接收数据的能力。但如果多线程共享该 socket，则 close() 会让引用计数 -1，只要引用计数非0，其它线程还可以正常读写该 socket</li><li>shutdown() 可以指定仅关闭 socket 发送方向/读取方向。如果多线程共享该 socket，则其它线程将受到影响</li></ul><p>因此，close() 是一种粗暴的关闭方式，不会经历四次挥手的过程，等到对端发送数据恢复 RST 才能正确关闭连接。</p><p>粗暴的关闭进程可以关闭 TCP 连接，但不优雅。可以通过伪造 RST 报文来关闭连接，但要同时满足<strong>四元组相同</strong>、<strong>序列号是对方期望的</strong>两个条件。</p><ul><li><code>killcx</code> 工具： <ul><li>主动向处于 Established 状态的服务端发送 SYN，接收 Challenge ACK，获得服务器期望的序列号和确认号</li><li>利用 Challenge ACK 信息伪造两个 RST 报文发送给客户端(序列号)和服务端(确认号)，让它们优雅地释放连接</li></ul></li><li><code>tcpkill</code> 工具： <ul><li>在双方进行 TCP 通信时，拿到对方下一次期望的序列号，然后伪造 RST 报文来关闭连接</li><li>仅适用于活跃的 TCP 连接</li></ul></li></ul><p>如果进程崩溃，OS 内核会自动发送 FIN 完成 TCP 四次挥手关闭连接；而如果主机宕机，对端是无法感知的，需要 TCP 保活机制来探测主机是否正常。在 Linux 中，需要至少 2H 11min 15s 才能发现一个死亡连接。</p><h3 id="ip" tabindex="-1"><a class="header-anchor" href="#ip"><span>IP</span></a></h3><h4 id="ip-地址" tabindex="-1"><a class="header-anchor" href="#ip-地址"><span>IP 地址</span></a></h4><ul><li>ABCDE 地址 -&gt; CIDR 无分类地址</li><li>IP 地址 &amp; 子网掩码 = 网络号</li><li>IPv4 地址 32 位，而 IPv6 地址 128 位，且支持自动分配 IP 地址，简化包头，提高传输性能，提升了安全性</li><li>localhost 是一个域名，不过会解析成 127.0.0.1 本地回环地址</li><li><code>ping 127.0.0.1/本地IP</code>最后都会走 本地回环接口（假网卡），然后插入<code>input_pkt_queue</code>链表后，通过软中断通知<code>ksoftirqd</code>接收数据，因此断网也能 Ping 通</li><li>如果服务器 listen 的是 0.0.0.0，表示监听本机的所有 IPv4 地址</li></ul><h4 id="ip-和-mac-地址" tabindex="-1"><a class="header-anchor" href="#ip-和-mac-地址"><span>IP 和 MAC 地址</span></a></h4><ol><li>MAC 地址的作用是实现「直连」的两个设备之间通信，在网络传输寻址过程中是一直变化的。</li><li>而 IP 则负责在「没有直连」的两个网络之间进行通信传输，源IP地址和目标IP地址在整个传输过程中是不会变化的（除非 NAT）</li><li>如果只用 MAC 地址，路由器就需要记住每个MAC地址所在的子网，而 MAC 地址有48位，路由器无法存储这么多子网信息</li><li>IP 地址是设备上线以后，才能根据进入哪个子网来分配的，在设备还没有 IP 的时候需要用 MAC 地址来区分不同的设备</li></ol><p>IP 地址类似住址门牌号，住在不同地方就有不同门牌号，快递根据门牌号找到所在位置。而 MAC 地址类似身份证号，设备出厂就固定写死了，但是知道身份证号是没法找到人的，身份证号和地理位置无关。</p><h4 id="dns" tabindex="-1"><a class="header-anchor" href="#dns"><span>DNS</span></a></h4><p>域名解析协议，域名 -&gt; IP地址</p><p>查询顺序：</p><ul><li>浏览器缓存 -&gt; OS缓存 -&gt; 本地DNS  （主机和本地DNS服务器之间递归查询）</li><li>还没有就由本地DNS发出查询：根DNS -&gt; 顶级DNS -&gt; 权威DNS  （DNS服务器之间迭代查询）</li></ul>',84),i("figure",null,[i("img",{src:j,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s('<h4 id="arp" tabindex="-1"><a class="header-anchor" href="#arp"><span>ARP</span></a></h4><p>地址解析解析，IP -&gt; MAC</p><p>原理：广播 ARP 请求 -&gt; 解包匹配 -&gt; 单播 ARP 响应 -&gt; 有限缓存</p><p>RARP：MAC -&gt; IP，用于打印机服务器等小型嵌入式设备接入网络</p><h4 id="dhcp" tabindex="-1"><a class="header-anchor" href="#dhcp"><span>DHCP</span></a></h4><p>动态主机配置协议，动态获取IP地址</p><p>原理（全程 UDP广播）：</p><ul><li>客户端（0.0.0.0:68）使用 UDP 广播（255.255.255.255:67），发起 DHCP DISCOVER</li><li>DHCP 服务器响应 DHCP OFFER，携带可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 IP 地址租用期等信息</li><li>客户端收到一个 DHCP OFFER 后，回复 DHCP REQUEST，回显配置的参数</li><li>DHCP 服务器响应 DHCP ACK 确认配置信息</li></ul><h4 id="icmp" tabindex="-1"><a class="header-anchor" href="#icmp"><span>ICMP</span></a></h4><p>互联网控制报文协议，用于确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</p><p>分类：</p><ul><li>用于诊断的查询报文 <ul><li>如 Ping 命令利用 ICMP-回送请求、ICMP-回送应答 两类报文</li></ul></li><li>用于通知出错原因的差错报文 <ul><li>如 Traceroute 命令利用 ICMP-超时消息 报文，通过设置特殊的 TTL 追踪沿途路由，以及一个不可能的端口号（ICMP-端口不可达）标记已到达目的主机</li><li>如 Traceroute 命令利用 ICMP-禁止分片 报文，通过设置不分片确定路径上合适的 MTU 大小</li></ul></li></ul><h4 id="nat" tabindex="-1"><a class="header-anchor" href="#nat"><span>NAT</span></a></h4><p>网络地址转换协议。基于转换表将 私有IP -&gt; 公有IP（通常用 NAPT：网络地址和端口转化协议，私有IP + 端口 -&gt; 共有IP + 端口）</p><p>缺点：外网无法主动连接、性能开销大、重启连接断开<br>解决：IPv6、NAT穿透（应用程序主动建立端口映射）</p><h4 id="igmp" tabindex="-1"><a class="header-anchor" href="#igmp"><span>IGMP</span></a></h4><p>因特网组管理协议。用于维护 IGMP 路由表，管理加入、离开组播组的主机</p><h2 id="操作系统" tabindex="-1"><a class="header-anchor" href="#操作系统"><span>操作系统</span></a></h2><h3 id="硬件结构" tabindex="-1"><a class="header-anchor" href="#硬件结构"><span>硬件结构</span></a></h3><h4 id="冯诺依曼结构" tabindex="-1"><a class="header-anchor" href="#冯诺依曼结构"><span>冯诺依曼结构</span></a></h4><p>运算器、控制器、存储器、输入设备、输出设备</p>',21),i("figure",null,[i("img",{src:q,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s('<ul><li>CPU = 控制单元 + 逻辑运算单元 + 寄存器</li><li>寄存器分 通用寄存器、指令寄存器、程序计数器</li><li>总线分 地址总线（指定内存地址）、控制总线（指定读/写）、数据总线（传输数据）</li></ul><h4 id="指令" tabindex="-1"><a class="header-anchor" href="#指令"><span>指令</span></a></h4><p>指令周期的四级流水线：Fetch -&gt; Decode -&gt; Execute -&gt; Store</p><p>硬件32/64位指CPU位宽，软件32/64位指指令的位宽。</p><p>64位相比32位的优势：</p><ol><li>64位CPU可以一次计算超过32位的数字，但很少有程序计算这么大的数字，只有计算大数字才能体现超过32位CPU的性能</li><li>64位CPU可以寻址更大的物理内存空间，32位最高寻址4G</li></ol><h4 id="多级存储器" tabindex="-1"><a class="header-anchor" href="#多级存储器"><span>多级存储器</span></a></h4><ul><li>寄存器: 一般在半个CPU周期内完成读写</li><li>CPU Cache：RAM 静态随机存储器，断电丢失。 <ul><li>L1：2-4个时钟周期，几十KB。分数据缓存、指令缓存</li><li>L2：10-20个时钟周期，几百KB</li><li>L3: 20-60个时钟周期，几十MB。多核共享</li></ul></li><li>内存：DRAM 动态随机存取存储器，电容需要定时刷新。200-300个时钟周期</li><li>SSD/HDD 硬盘：断电后数据不丢失，SSD比内存慢 10-1000 倍，HDD比内存慢 10W 倍</li></ul><p>每个存储器只和相邻的一层存储器设备进行交互，形成缓存体系。</p>',9),i("figure",null,[i("img",{src:Q,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s('<h4 id="cpu-cache" tabindex="-1"><a class="header-anchor" href="#cpu-cache"><span>CPU Cache</span></a></h4><p>CPU Cache 是由很多个 <code>Cache Line</code> 组成的，<code>Cache Line</code> 是 CPU 从内存读取数据的基本单位（例如一次载入 64Byte），由各种标志（Tag）+ 数据块（Data Block）组成。</p><p><strong>直接映射</strong></p><ul><li>通过取模运算，计算内存块对应的 Cache Line 地址</li><li>组标记 Tag： 记录是否是对应的内存块（因为多个内存块会映射到同一个 Cache Line）</li><li>有效位 Valid Bit：标记数据是否还有效</li><li>偏移量 Offset：定位 CPU 读取 Cache Line 中哪个 Word 字</li></ul><p>因此，一个内存的访问地址由 组标记、Cache Line 索引、偏移量 三者共同定位。其它映射例如全相联、组相联等类似。</p><p><strong>提升缓存命中率</strong></p><p>提升缓存命中率，也就可以提升程序执行速度，优化方法例如：</p><ul><li>按内存布局顺序访问</li><li>有规律的条件分支语句可以充分利用 CPU 的分支预测器</li><li>当有多个同时执行的「计算密集型」线程，可以把线程绑定在某一个 CPU 核心上，避免线程在不同核心来回切换，影响缓存命中率。</li></ul><p><strong>写入数据</strong></p><ol><li>写直达 Write Through：把数据同时写入内存和Cache。每次写操作都会写回内存，消耗性能</li><li>写回 Write Back：将新数据写入 Cache Block 里，只有当修改过的 Cache Block「被替换」时才需要写到内存中。</li></ol><p><strong>缓存一致性问题</strong></p><p>由于 L1/L2 Cache 是多个核心各自独有的，因此可能带来多核心的缓存一致性问题。因此需要一种同步机制，能够实现：</p><ol><li>写传播：某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache。 <ul><li>实现方法：总线嗅探，每个 CPU 核心监听总线上的广播事件，检查是否有相同的数据在自己的 L1 Cache 里，如果有事件就更新。会加重总线负载，且不能保证事务串行化</li></ul></li><li>事务串行化：某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的 <ul><li>实现方法：MESI协议，标记 Cache Line 的四种不同状态</li><li><code>Modified</code>：已修改。Cache 数据和内存中数据不一致，可以自由写入，被替换时需要写回内存。</li><li><code>Exclusive</code>：独占。仅一个核心存储该 Cache Line，可以自由写入，不需要通知其它核心。如果其它核心从内存读取了该 Cache Line，那么将转为共享状态</li><li><code>Shared</code>：共享。修改时需要向所有其它核心广播请求，要求把该 Cache Line 标记为无效，然后再更新</li><li><code>Invalidated</code>：已失效。数据不一致，不可以读取该状态数据。</li></ul></li></ol><p><strong>伪共享</strong></p><p>由于多个线程同时读写同一个 Cache Line 的不同变量，而导致 CPU Cache 失效的现象。</p><p>解决方案：</p><ul><li>Cache Line 大小字节对齐（空间换时间）</li><li>字节填充，例如 Disruptor 中的 RingBuffer 类数据前后填充 long，使得无论怎么加载 Cache Line，这整个 Cache Line 里都没有会发生更新操作的数据</li></ul><h4 id="cpu-调度" tabindex="-1"><a class="header-anchor" href="#cpu-调度"><span>CPU 调度</span></a></h4><p>Linux 内核中，无论是进程还是线程，调度的都是 <code>task_struct</code> 结构体，区别在于线程的<code>task_struct</code>部分资源是共享了进程已创建的资源，如内存地址空间、代码段、文件描述符等。</p><p><strong>调度器</strong></p><ul><li>Deadline：对应 dl_rq 运行队列</li><li>Realtime：对应 rt_rq。</li><li>Fair: 对应 cfs_rq。完全公平调度，优先选择 vruntime 少的任务，用于普通任务，内部组织成红黑树结构</li></ul><p>调度优先级从上到下，dl_rq -&gt; rt_rq -&gt; cfs_rq，也即实时任务总是先于普通任务被执行。</p><p>进程优先级可以通过 <code>nice | renice</code> 设置/更改，范围 -20~19，是一个修正值，nice 值越小优先级越高。</p><h4 id="中断" tabindex="-1"><a class="header-anchor" href="#中断"><span>中断</span></a></h4><p>中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求。中断是一种异步的事件处理机制，可以提高系统的并发处理能力。</p><p>Linux 为了解决中断处理程序执行过长和中断丢失的问题，将中断处理程序分成了两个阶段：</p><ul><li>上半部：直接处理硬件请求，也就是硬中断。 <ul><li>负责耗时短的工作，特点是快速执行，一般会暂时关闭中断请求。例如处理跟硬件相关或时间敏感的事情。</li></ul></li><li>下半部：由内核触发，也就是软中断。 <ul><li>负责上半部未完成的工作，特点是延迟执行，通常耗时较长。</li></ul></li></ul><p>另外，硬中断会打断 CPU 正在执行的任务，然后立即执行中断处理程序。每个 CPU 都对应一个软中断内核线程，名为<code>ksoftirqd/CPU.no</code></p><p><code>watch -d cat /proc/softirqs</code> 可以监控软中断变化，[]内的是内核线程</p><h4 id="数值存储" tabindex="-1"><a class="header-anchor" href="#数值存储"><span>数值存储</span></a></h4><p>负数用补码表示：统一和正数的加减法操作<br>十进制转二进制：整数除 2 取余并反转，小数乘 2 取整</p><p>浮点数存储：</p><p>$(-1)^\\text{符号位} * (1 + \\text{尾数}) * 2^{\\text{指数} - 127}$</p><ul><li>尾数位决定了浮点数的精度</li><li>指数位决定了浮点数的表示范围</li></ul><p>由于计算机存储浮点数有位数限制，有的小数无法用「完整」的二进制来表示，所以只能以近似值保存。进而，两个近似数相加，得到的必然也是一个近似数。</p><h3 id="os-结构" tabindex="-1"><a class="header-anchor" href="#os-结构"><span>OS 结构</span></a></h3><h4 id="内核态和用户态" tabindex="-1"><a class="header-anchor" href="#内核态和用户态"><span>内核态和用户态</span></a></h4><p>内核具有很高的权限，可以控制 cpu、内存、硬盘等硬件，而应用程序具有的权限很小，因此 OS 把内存分成了两个区域：</p><ul><li>内核空间：这个内存空间只有内核程序可以访问</li><li>用户空间：这个内存空间专门给应用程序使用</li></ul><p>用户空间的代码只能访问一个局部的内存空间，而内核空间的代码可以访问所有内存空间。因此，程序使用用户空间即该程序在用户态执行，程序使用内核空间即程序在内核态执行。应用如果需要进入内核态，需要通过中断发起系统调用，内核处理完后再触发中断回到用户态。</p><h4 id="内核设计" tabindex="-1"><a class="header-anchor" href="#内核设计"><span>内核设计</span></a></h4><ul><li>Linux 是宏内核设计，包含多个模块，整个内核像一个完整的程序，且拥有最高的权限</li><li>Windows 是混合型内核，微内核（内核只保留基本能力）基础上搭建其它模块</li></ul><h3 id="内存管理" tabindex="-1"><a class="header-anchor" href="#内存管理"><span>内存管理</span></a></h3><h4 id="虚拟内存" tabindex="-1"><a class="header-anchor" href="#虚拟内存"><span>虚拟内存</span></a></h4><p>为了在多进程环境下，使得进程之间的内存地址不受影响，相互隔离，于是 OS 提供一种机制，将不同进程的虚拟地址和内存的物理地址映射起来。程序仅访问虚拟地址，由 OS 转换成不同的物理地址。</p><ul><li>程序中使用的地址叫虚拟内存地址</li><li>硬件里的空间地址叫物理内存地址</li></ul><p>每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。</p><p><strong>内存分段</strong><br>程序由若干个逻辑段组成，例如代码分段、数据分段、栈段、堆段。不同的段有不同的属性，于是用分段的形式把这些段分离出来。</p>',48),i("figure",null,[i("img",{src:K,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s("<p>分段机制下的虚拟地址由两部分组成:</p><ul><li>段选择因子: 保存在段寄存器里，包括两部分： <ul><li>段号：段表的索引，段表 = 段基地址 + 段界限 + 特权等级</li><li>特权标志位</li></ul></li><li>段内偏移量：段基地址 + 段内偏移量 -&gt; 物理内存地址</li></ul><p>缺陷：</p><ul><li>内存碎片：主要是外部内存碎片，不连续内存空间导致无法加载一个新进程。可以通过内存交换解决（也就是Swap分区）</li><li>内存交换效率低：内存交换需要在硬盘和内存间交换数据，硬盘速度太慢，如果交换一个很大的空间，将造成卡顿</li></ul><p><strong>内存分页</strong></p><p>为了解决内存分段的「外部内存碎片和内存交换效率低」的问题，就出现了内存分页。分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小，这样的一个连续且尺寸固定的内存空间叫页（Linux下一页4KB）。</p>",6),i("figure",null,[i("img",{src:G,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s("<p>分页机制下的虚拟地址由两部分组成:</p><ul><li>页号：作为页表的索引，页表包含物理页所在物理内存的基地址</li><li>页内偏移：页基地址 + 页内偏移量 -&gt; 物理地内存址</li></ul><p>优点：</p><ul><li>由于每个页的大小固定，因此存在内部碎片问题。但碎片很小</li><li>内存不足时，OS 换出最近未使用的页面，需要时再换入。每次交换仅几个页面，因此效率较高</li></ul><p>缺点：</p><ul><li>每个程序都有自己的虚拟地址空间，因此页表占用空间大</li></ul><p>解决办法：多级页表。充分利用程序的局部性原理，一级页表需要覆盖所有虚拟地址，而二级页表按需创建。对于 64 位系统，需要四级目录。</p><p>优化：TLB 快表。利用局部性原理，把页表项缓存在 CPU 的一个专门芯片 TLB （Translation Lookaside Buffer 转址旁路缓存）中。</p><p><strong>段页式内存管理</strong></p><p>段页结合，虽然增加了硬件成本和系统开销，但提高了内存的利用率。</p><ul><li>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；</li><li>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；</li></ul>",11),i("figure",null,[i("img",{src:W,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s('<p>因此，访问内存地址时：</p><ol><li>到段表中根据段号查询页表地址</li><li>到页表中查询物理页号</li><li>物理页基地址 + 页内偏移量 得到物理内存地址</li></ol><p><strong>虚拟内存优点</strong></p><ol><li>虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。</li><li>由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。</li><li>页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。</li></ol><h4 id="linux-内存管理" tabindex="-1"><a class="header-anchor" href="#linux-内存管理"><span>Linux 内存管理</span></a></h4><p>由于 Intel CPU 历史原因，Linux 不得不使用虚拟的段式内存，只用于访问控制和内存保护，主要还是页式内存管理。整个内存空间分为了内核空间和用户空间，每个进程的虚拟地址的内核部分都关联相同的物理内存，这样进程切换到内核态后就可以很方便地访问内核空间内存。</p><p>而用户空间内存分为：</p><ul><li>代码段: 包括二进制可执行代码；</li><li>数据段: 包括已初始化的静态常量和全局变量；</li><li>BSS 段: 包括未初始化的静态变量和全局变量；</li><li>堆段: 包括动态分配的内存，从低地址开始向上增长；</li><li>文件映射段: 包括动态库、共享内存等，从低地址开始向上增长</li><li>栈段: 包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；</li></ul>',8),i("figure",null,[i("img",{src:V,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s('<p>对于 32位 OS，内核空间占 1G，用户空间 3G，即理论上可以申请最大 3G 虚拟内存；<br>对于 64位系统，内核空间 128T，用户空间 128T，中间是未定义，即理论上可以申请最大 128G 虚拟内存。</p><h4 id="内存分配" tabindex="-1"><a class="header-anchor" href="#内存分配"><span>内存分配</span></a></h4><ul><li>malloc() 不是系统调用，而是 C 的库函数，用于动态分配内存。</li><li>malloc() 分配的是虚拟内存，只有在初次访问时由 OS 触发缺页中断，建立实际的映射关系。（因此申请时可以超出物理内存限制）</li><li>分配空间时，malloc() 会预分配一定的空间作为内存池，例如 malloc(1) 会直接分配 132KB。</li><li>每次分配的内存块前有 16Byte 头信息，因此 free() 只需要知道起始地址就知道该释放多大的内存空间。</li></ul><p>两种方式：</p><ol><li>通过 brk() 系统调用从堆分配内存，堆顶指针上移。</li></ol><ul><li>用于小于 128KB 的内存申请。</li><li>free() 时会先放进 malloc 内存池中以复用，等进程退出后再归还 OS</li></ul><ol start="2"><li>通过 mmap() 系统调用在文件映射区域分配内存。</li></ol><ul><li>用于大于 128KB 的内存申请。</li><li>free() 后直接归还 OS</li></ul><p>因此，mmap() 方式会频繁发生运行态的切换和缺页中断，而 brk() 通过内存池减少了系统调用和缺页中断。但是 brk() 不断分配小空间，回收后可能无法用于大内存的分配，进而产生内存碎片，导致内存泄漏。</p><p>内存泄露：程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。<br>内存溢出：OOM，指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存。此时程序就运行不了，系统会提示内存溢出。</p><h4 id="内存回收" tabindex="-1"><a class="header-anchor" href="#内存回收"><span>内存回收</span></a></h4><p>malloc() 分配虚拟内存后，程序初次访问时会触发缺页中断，进而中断处理程序会判断物理内存是否足够，不足时将进行内存回收。</p><p>回收流程：kswapd -&gt; direct reclaim -&gt; OOM Killer</p><ul><li>后台内存回收 kswapd：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，异步非阻塞</li><li>直接内存回收 direct reclaim：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，同步阻塞</li><li>OOM: 如果直接回收仍然无法满足程序的申请，内核将触发 OOM，由 OOM Killer 根据每个进程的内存占用情况和 <code>oom_score_adj</code> 值进行打分，得分最高的进程会被杀掉，直到释放足够的内存（可通过<code>/proc/[pid]/oom_score_adj</code>调整被杀掉的概率）。</li></ul><p><strong>可回收内存</strong></p><p>OS 通过页面置换算法得到以下两类可回收的内存：</p><ul><li>文件页 File-backed Page：内核缓存的磁盘数据（Buffer）和内核缓存的文件数据（Cache） <ul><li>可以直接释放，需要时重新从磁盘读取</li><li>脏页需要先写回</li></ul></li><li>匿名页 Anonymous Page：像 堆、栈 这样的没有实际载体的数据 <ul><li>通过 Linux 的 Swap 机制，把不常用的内存写入磁盘，需要时重新载入</li></ul></li></ul><p>文件页、匿名页的回收都基于 LRU 算法，分别对应 active、inactive 两个双向链表（共四个链表），优先回收不常访问的内存。</p><p><strong>性能优化</strong></p><p>直接内存回收会阻塞线程，文件页、匿名页都需要磁盘 IO，因此频繁的内存回收会影响系统性能。优化措施：</p><ol><li>减小 <code>/proc/sys/vm/swappiness</code>，使其倾向于回收文件页（干净页可以直接回收，好于 Swap 换入换出）。范围0-100</li><li>增大 <code>/proc/sys/vm/min_free_kbytes</code> ，调整页阈值，及早触发后台回收，避免进入直接内存回收阻塞进程</li></ol><ul><li>内核定义了三个内存阈值：pages_min, pages_low, pages_high。后两者基于 pages_min 计算而得</li><li>内存处在 pages_min 和 pages_low 之间时会触发后台回收 kswapd</li></ul><ol><li>对于 NUMA 架构的 CPU，可以置 <code>/proc/sys/vm/zone_reclaim_mode</code> 为 0，以支持访问远端 Node 内存</li></ol><ul><li>SMP：也称 UMA（Uniform Memory Access），每个 CPU 地位平等，共享物理资源，因此访问内存时间都相同。但总线压力大，可用带宽小</li><li>NUMA：非 UMA，对 CPU 分组，每组 Node 有独立的物理资源，通过总线访问其它 Node 内存，但耗时稍长（但收益高于内存回收）</li></ul><h4 id="swap-机制" tabindex="-1"><a class="header-anchor" href="#swap-机制"><span>Swap 机制</span></a></h4><p>物理内存不够用时，需要将内存数据换出到磁盘，需要时再从磁盘换入内存，这个过程由 Swap 机制控制。一般回收像 堆、栈 这样的没有实际载体的匿名页数据</p><p><strong>触发场景</strong></p><ol><li>内存不足：系统所需内存超过可用物理内存，内核会进行直接内存回收，保证正在执行进程的可用性。同步。</li><li>内存闲置：通过后台守护进程 kSwapd 将不再使用的内存回收。异步。</li></ol><p><strong>开启方法</strong></p><ol><li>Swap 分区：硬盘上的独立区域，仅用于交换分区</li><li>Swap 文件：文件系统中的特殊文件</li></ol><h4 id="缓存命中率" tabindex="-1"><a class="header-anchor" href="#缓存命中率"><span>缓存命中率</span></a></h4><p><strong>预读失效</strong></p><p>Linux/MySQL 为读缓存提供了预读机制，通过一次磁盘顺序读将多个 Page (4KB)装入 Page Cache (16KB)，减少磁盘IO，提高吞吐量。而如果预读的数据没有被访问，就是预读失效，占用了 LRU 链表前排的位置，大大降低了缓存命中率。</p><p>改进方法：让预读页停留在内存里的时间要尽可能短，因此可以划分冷数据和热数据。</p><ul><li>Linux：两个 LRU 链表，活跃 LRU 链表 active_list，非活跃 LRU 链表 inactive_list <ul><li>预读页先加入 inactive_list 头部，待真正被访问时才插入 active_list 头部</li><li>active_list 淘汰的页面降级到 inactive_list 头部</li></ul></li><li>MySQL：LRU 链表划分前半部分 young 区域和后半部分 old 区域 <ul><li>预读页先加入 old 区域头部，待真正被访问时才插入 young 区域头部</li><li>young 区域淘汰的页面降级到 old 区域头部</li></ul></li></ul><p><strong>缓存污染</strong></p><p>批量读取数据时（例如 SQL 全表扫描），由于数据仅被访问一次，这些大量数据都会被加入到「活跃 LRU 链表」里，然后之前缓存在活跃 LRU 链表（或者 young 区域）里的热点数据全部都被淘汰了，如果这些大量的数据在很长一段时间都不会被访问的话，那么整个活跃 LRU 链表（或者 young 区域）就被污染了。</p><p>改进方法：提高进入活跃 LRU 链表（或者 young 区域）的门槛，避免热点数据不会被轻易替换掉。</p><ul><li>Linux：内存页第二次访问时才进行升级</li><li>MySQL：内存页第二次被访问时，判断它停留在 old 区域的时间，超过 1s 就升级到 young 区域，否则停留在 old 区域</li></ul><h3 id="进程管理" tabindex="-1"><a class="header-anchor" href="#进程管理"><span>进程管理</span></a></h3><h4 id="进程" tabindex="-1"><a class="header-anchor" href="#进程"><span>进程</span></a></h4><p>运行中的程序，就被称为「进程」（Process）。</p><ul><li>运行状态（Running）：该时刻进程占用 CPU</li><li>就绪状态（Ready）：可运行，由于其他进程处于运行状态而暂时停止运行</li><li>阻塞状态（Blocked）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行</li><li>创建状态（new）：进程正在被创建时的状态</li><li>结束状态（Exit）：进程正在从系统中消失时的状态</li></ul>',43),i("figure",null,[i("img",{src:J,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s('<p>另外还有挂起状态，描述进程暂时被淘汰出内存的状态（sleep/换出等）：</p><ul><li>阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；</li><li>就绪挂起状态：进程在外存（硬盘），但只要进入内存，立刻运行；</li></ul><p>根据进程所处的不同状态，将进程对应的进程控制块 PCB 通过链表组织起来，例如就绪队列、阻塞队列等</p><h4 id="线程" tabindex="-1"><a class="header-anchor" href="#线程"><span>线程</span></a></h4><p>线程是进程当中的一条执行流程。同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。</p><p><strong>优点</strong></p><ul><li>一个进程中可以同时存在多个线程；</li><li>各个线程之间可以并发执行；</li><li>各个线程之间可以共享地址空间和文件等资源；</li></ul><p><strong>缺点</strong><br>当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃。（针对C/C++）</p><p><strong>实现</strong></p><ul><li>用户线程：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理</li><li>内核线程：在内核中实现的线程，是由内核管理的线程</li><li>轻量级进程：在内核中来支持用户线程</li></ul><h4 id="进程和线程对比" tabindex="-1"><a class="header-anchor" href="#进程和线程对比"><span>进程和线程对比</span></a></h4><ul><li>进程是资源分配的基本单位，而线程是处理器调度的基本单位。</li><li>进程拥有自己的地址空间，因此不会相互影响；而线程共享进程的地址空间，包括内存和资源。</li><li>线程是轻量级的进程，由于涉及资源少，而且相同的地址空间不需要切换页表，线程的创建、销毁以及切换所需的开销都比进程小。</li></ul><h4 id="线程和协程对比" tabindex="-1"><a class="header-anchor" href="#线程和协程对比"><span>线程和协程对比</span></a></h4><p>协程是一种运行在线程之上的用户态模型，也称纤程，在线程的基础上通过时分复用的方式运行多个协程。</p><ul><li>一个线程可以有多个协程，一个进程也可以单独拥有多个协程</li><li>线程进程都是同步机制，而协程则是异步</li><li>协程切换不需要内核态/用户态的转换，可以直接在用户态切换上下文</li><li>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</li></ul><h4 id="上下文切换" tabindex="-1"><a class="header-anchor" href="#上下文切换"><span>上下文切换</span></a></h4><p>CPU 上下文切换：先把前一个任务的 CPU 上下文（CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p><p>根据任务的不同，分三种：</p><p><strong>进程上下文切换</strong></p><ul><li>在内核态完成，交换信息存储在 PCB 中</li><li>不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括内核堆栈、寄存器等内核空间的资源。</li></ul><p><strong>线程上下文切换</strong></p><ul><li>当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；</li><li>当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的寄存器状态和栈数据</li><li>涉及资源少，开销比进程低得多</li></ul><p><strong>中断上下文切换</strong></p><ul><li>响应硬件中断时发生</li><li>比进程和线程上下文切换更快，因为通常涉及极少的的状态信息</li></ul><h4 id="进程间通信" tabindex="-1"><a class="header-anchor" href="#进程间通信"><span>进程间通信</span></a></h4><p>每个进程的用户地址空间都是独立的，不能互相访问，但内核空间是所有进程共享的，因此进程之间要通信必须通过内核。</p><h5 id="管道-pipe" tabindex="-1"><a class="header-anchor" href="#管道-pipe"><span>管道（Pipe）</span></a></h5><ul><li>特点：一种用于父子进程之间的单向通信方式，通过<code>pipe</code>创建，仅存在于内存。</li><li>优点：简单、轻量级、适用于一对一通信。</li><li>缺点：单向通信，不适用于无亲缘关系的进程之间的通信。</li></ul><h5 id="命名管道-named-pipe" tabindex="-1"><a class="header-anchor" href="#命名管道-named-pipe"><span>命名管道（Named Pipe）</span></a></h5><ul><li>特点：一种允许无亲缘关系的进程之间进行双向通信的方式。通过<code>mkfifo</code>创建。</li><li>优点：支持双向通信，适用于多个进程之间的通信。</li><li>缺点：需要显式创建和命名，效率低，不适合进程间频繁交换数据</li></ul><h5 id="消息队列-message-queue" tabindex="-1"><a class="header-anchor" href="#消息队列-message-queue"><span>消息队列（Message Queue）</span></a></h5><p>消息队列解决了管道通信效率低的问题。</p><ul><li>特点：允许不同进程之间进行异步通信，通过消息传递数据。</li><li>优点：支持多对多通信、异步通信，消息具有格式化结构。</li><li>缺点：需要额外的编程工作来管理消息队列，消息拷贝开销大，不适合大数据的传输</li></ul><h5 id="共享内存-shared-memory" tabindex="-1"><a class="header-anchor" href="#共享内存-shared-memory"><span>共享内存（Shared Memory）</span></a></h5><p>共享内存解决了 MQ 的消息拷贝导致额外开销的问题，是<strong>速度最快</strong>的 IPC 方式，因为不需要在内核和用户空间之间复制数据。前提是处理好多进程并发访问的问题。</p><ul><li>特点：允许多个进程访问同一块内存区域，实现高效的数据共享。</li><li>优点：高效、快速，适用于大量数据共享。</li><li>缺点：需要额外的同步机制来保证数据一致性，对内存管理要求较高。</li></ul><h5 id="信号量-semaphore" tabindex="-1"><a class="header-anchor" href="#信号量-semaphore"><span>信号量（Semaphore）</span></a></h5><p>信号量机制防止了多进程竞争共享资源而造成数据错乱的问题。</p><ul><li>特点：用于控制多个进程对共享资源访问的方式，本质上是一个整型的计数器，可用于同步和互斥。 <ul><li>原子 P 操作：用于进入共享资源前，信号量减 1，然后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；否则表明还有资源可使用，进程继续正常执行</li><li>原子 V 操作：用于离开共享资源后，信号量加 1，然后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，会将该进程唤醒运行；否则表明当前没有阻塞中的进程</li><li>P、V必须成对出现。</li><li>如果信号量初始值为1，即互斥信号量，任何时刻仅有一个进程访问，很好的保护了共享内存。</li><li>如果信号量初始值为0，即同步信号量，保证进程执行的先后，例如生产者-消费者模型</li></ul></li><li>优点：支持进程同步和互斥，可用于多种通信场景。</li><li>缺点：编程复杂性较高，容易引入死锁等问题。</li></ul><h5 id="套接字-socket" tabindex="-1"><a class="header-anchor" href="#套接字-socket"><span>套接字（Socket）</span></a></h5><ul><li>特点：基于网络协议的IPC方式，用于不同主机上的进程之间进行通信。 <ul><li><code>int socket(int domain, int type, int protocal)</code><ul><li>domain: 协议族，如 UPv4 对应 AF_INET, IPv6 对应 AF_INET6， 本地通信 AF_LOCAL/AF_UNIX</li><li>type：类型，如 TCP 对应 SOCKET_STREAM, UDP 对应 SOCKET_DGRAM, SOCK_RAW</li><li>protocol：协议，基本废弃，填0</li></ul></li><li>对于 TCP，需要 bind, listen, accept, write, read... 服务端监听和传送数据使用的是两个socket（门卫和员工）</li><li>对于 UDP，只要 bind, sendto, recvfrom</li></ul></li><li>优点：支持跨网络通信，可用于分布式系统。</li><li>缺点：相对复杂，需要网络协议支持。</li></ul><h5 id="信号-signal" tabindex="-1"><a class="header-anchor" href="#信号-signal"><span>信号（Signal）</span></a></h5><p>对于异常情况下的工作模式，需要用「信号」的方式来通知进程。例如 Ctrl+Z 产生 SigSTP 信号，Ctrl+C 产生 SigINT 信号</p><ul><li>特点：用于通知进程发生事件（来自软件/硬件）的轻量级方式，通常用于处理异步事件。</li><li>优点：简单、快速，用于处理异步事件。</li><li>缺点：只能传递简单的信息，不适合大量数据交换。</li></ul><h4 id="线程间通信" tabindex="-1"><a class="header-anchor" href="#线程间通信"><span>线程间通信</span></a></h4><p>临界区：访问共享资源的代码片段，产生来自多线程间的竞争条件导致程序运行的不确定性。<br>互斥：保证一个进程/线程在临界区执行时，其他进程/线程应该被阻止进入临界区<br>同步：并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程/线程同步</p><p>通常使用 锁/信号量 实现进程/线程互斥，信号量功能更强大，还能实现同步。</p><ol><li>互斥锁（Mutex）：用于控制对共享资源的访问，保证多个线程访问共享资源时的互斥性。底层可以基于<code>测试并设置</code>/<code>等待队列</code></li><li>信号量（Semaphore）：一种同步工具，用于保证多个线程之间的顺序性和互斥性。P操作减1，小于0阻塞；V加1，小于等于0唤醒线程。初始置 1 即互斥，置 0 即同步。</li><li>条件变量（Condition Variable）：用于线程间的等待和唤醒，一个线程可以等待某个条件变量满足后被唤醒。</li><li>屏障（Barrier）：用于多个线程之间的同步，当所有线程到达屏障时，才能继续执行后续操作。</li><li>自旋锁（Spinlock）：一种忙等待的同步工具，它会不断地检测共享资源是否可用，直到资源可用后才能继续执行后续操作。</li></ol><h4 id="线程创建数量" tabindex="-1"><a class="header-anchor" href="#线程创建数量"><span>线程创建数量</span></a></h4><p>受限于进程的虚拟内存空间上限和系统参数限制</p><ul><li>每分配一个线程需要分配一定的虚拟内存，例如对于 32位 系统，用户空间3G，每个线程占 10M 虚拟内存，则能创建约 300 个线程</li><li>/proc/sys/kernel/threads-max 表示系统支持的最大线程数，默认 14553</li><li>/proc/sys/kernel/pid_max 表示系统全局的进程/线程 PID 号数值的限制，默认 32768</li><li>/proc/sys/vm/max_map_count 表示限制一个进程可以拥有的VMA(虚拟内存区域)的数量，默认 65530</li></ul><h4 id="关闭进程" tabindex="-1"><a class="header-anchor" href="#关闭进程"><span>关闭进程</span></a></h4><p><strong>线程崩溃</strong></p><p>一般来说，如果线程因为非法访问内存引起崩溃，那么进程也会崩溃。因为各个线程的地址空间是共享的，非法访问会导致内存的不确定性。</p><p><strong>进程崩溃</strong></p><p>进程结束是由于 OS内核 发起的系统调用，向进程发送信号，例如 SIGKILL，然后执行自定义/默认的信号处理函数(除SIGKILL)，执行完毕后结束进程。</p><p>因此，对于 JVM 这种自己定义了信号处理函数的进程，可以发送 SIGTERM（kill 的默认信号）命令，执行一些资源清理后再 exit 优雅地退出。而像 StackOverFlowError、NPE 等非法访问内存，JVM 自定了 SIGSEGV 信号处理函数，内部通过栈回溯恢复线程执行并抛出异常。而其它的 SIGSEGV 信号 JVM 不做特殊处理，生成崩溃日志并退出。</p><h4 id="死锁" tabindex="-1"><a class="header-anchor" href="#死锁"><span>死锁</span></a></h4><p>死锁：多个线程互相持有对方所需要的资源，并且都在等待对方释放资源，导致这些线程都被阻塞，无法继续执行，进而陷入了一种僵局的状态。Java 程序可以使用 jstack 工具检查死锁。</p><p><strong>死锁条件</strong></p><ol><li>互斥：多个线程不能同时使用同一个资源。</li><li>请求与保持：线程持有资源后不会主动释放已经持有的资源</li><li>不可抢占：线程已经持有的资源不会被其它线程剥夺</li><li>循环等待：两个线程获取资源的顺序构成了环形链</li></ol><p><strong>预防死锁</strong></p><ol><li>破环互斥：资源非独占，即多个进程可以同时访问一个资源</li><li>破环请求与保持：可以一次性请求所有所需的资源，或运行过程中逐步释放掉已使用完毕的资源</li><li>破坏不可抢占：已持有资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源</li><li>破坏循环等待条件：通过对资源进行排序，按编号顺序申请，保证资源申请不形成环路（最常用，将稀缺资源设置较大的编号，按从小到大的序号申请）</li></ol><p><strong>避免死锁</strong><br>银行家算法：在分配资源时判断是否会出现死锁，只在不会出现死锁的情况下才分配资源。但是进程必须事先声明每个进程请求得最大资源数。</p><ul><li>Available：可利用资源向量</li><li>Max：最大需求矩阵</li><li>Allocation: 已分配矩阵</li><li>Need：需求矩阵</li></ul><h4 id="经典同步问题" tabindex="-1"><a class="header-anchor" href="#经典同步问题"><span>经典同步问题</span></a></h4><p><strong>哲学家进餐问题</strong></p><ul><li>拿筷子前加上互斥信号量</li><li>偶数编号哲学家先拿左边筷子，后拿右边筷子；奇书编号哲学家先拿右边筷子，后拿左边筷子</li><li>state 数组记录每位哲学家的 进餐/思考/饥饿 状态</li></ul><p><strong>读者/写者问题</strong></p><ul><li>读者有限：wMutex 写互斥，rCount 读个数，rCountMutex 对rCount的互斥</li><li>写者优先：rMutex 读互斥，wDataMutex 写互斥，wCount 写数量，wCountMutext 对wCount的互斥</li><li>公平策略：读写互斥、优先级相同、一个写者访问临界区、多个读者同时访问临界区</li></ul><h4 id="锁机制" tabindex="-1"><a class="header-anchor" href="#锁机制"><span>锁机制</span></a></h4><p>为了避免资源竞争而导致数据错乱，共享资源访问前需要加锁，</p><ul><li>互斥锁： <ul><li>加锁失败后，线程会释放 CPU，并被内核置为睡眠状态</li><li>等到锁被释放后，内核在合适的时机唤醒线程</li><li>加锁失败/唤醒线程会进行用户态和内核态的上下文切换，存在性能开销。因此如果被锁住的代码执行时间很短应选择自旋锁</li></ul></li><li>自旋锁： <ul><li>加锁失败后，线程会忙等待，直到它拿到锁</li><li>底层基于 CAS，在用户态完成加锁和解锁，开销较小。忙等通过 while循环/PAUSE指令 来实现，推荐PAUSE，加锁失败时cpu睡眠 30 clock 降低了读频率</li><li>对于单核CPU，需要配合抢占式的调度器，否则自旋的线程永远不会放弃 CPU</li></ul></li></ul><p><strong>加锁失败时，互斥锁进行线程切换，自旋锁则忙等</strong></p><ul><li>读写锁： <ul><li>读取共享资源用读锁，修改共享资源用写锁。可以基于互斥锁/自旋锁</li><li>根据实现还分为读优先锁和写优先锁，但存在饥饿问题，以及公平读写锁</li><li>适用于能明确区分 read/write，且读多写少的场景</li></ul></li></ul><p>以上三种锁都是悲观锁，即认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。</p><p>而乐观锁，也叫无锁编程，假定冲突的概率很低，先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有那么操作完成，否则放弃本次操作，并进行重试来解决冲突。乐观锁适用于冲突概率很低，且加锁成本非常高的场景。</p><h3 id="调度算法" tabindex="-1"><a class="header-anchor" href="#调度算法"><span>调度算法</span></a></h3><h4 id="进程调度" tabindex="-1"><a class="header-anchor" href="#进程调度"><span>进程调度</span></a></h4><p>也即线程调度。根据如何处理时钟中断 ，把调度算法分抢占式和非抢占式。</p><p><strong>调度原则</strong></p><ol><li>CPU 利用率：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；</li><li>系统吞吐量：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；</li><li>周转时间：周转时间是进程运行+阻塞时间+等待时间的总和，一个进程的周转时间越小越好；</li><li>等待时间：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；</li><li>响应时间：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。</li></ol><p><strong>调度算法</strong></p><ul><li>先来先服务 FCFS：非抢占式，先来的进程一直运行到退出或阻塞。不利于短作业，适用于 CPU 繁忙型作业，不适合 I/O 繁忙型作业的系统</li><li>最短作业优先 SJF：优先选择运行时间最短的进程。不利于长作业，甚至饥饿</li><li>高响应比优先 HRRN：响应比 = (等待时间 + 要求服务时间) / 要求服务时间。权衡了短作业和长作业，但要求服务时间是不可预知的，因此只是理想算法</li><li>时间片轮转 RR：Round-Robin，关键在于时间片的设定，过短导致怕频繁的上下文切换，过长会引起短作业进程的响应时间变长</li><li>最高优先级 HPF：分抢占式和非抢占式，还分静态优先级和动态优先级（运行时间增加降低优先级，等待时间增加提高优先级）。可能导致低优先级饥饿</li><li>多级反馈队列 MFQ： <ul><li>多级：多个优先级队列，优先级越高时间片越短</li><li>反馈：如果有新进程加入优先级高的队列，立刻停止当前运行进程，转而去运行优先级高的队列；</li><li>新进程放入第一级队列，时间片用完放入下一级队列，被强占则放入原队列末尾</li><li>兼顾了长短作业，同时有较好的响应时间</li></ul></li></ul><h4 id="页面调度" tabindex="-1"><a class="header-anchor" href="#页面调度"><span>页面调度</span></a></h4><p>缺页中断和一般中断的区别：</p><ul><li>缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号。</li><li>缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回到该指令的「下一个指令」执行。</li></ul><p>当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面：</p><ul><li>最佳页面置换：理想算法，置换未来最长时间不访问的页面</li><li>先进先出置换：换出驻留时间最长的页面</li><li>最近最久未使用 LRU：换出最长时间未被访问的页面。实现开销会比较大</li><li>时钟页面置换：所有页面保存在一个环形链表中，维护指向最老的页面。发生缺页时，顺时针找到一个访问位为 0 的页面置换</li><li>最不常用置换 LFU：换出访问次数最少的页面。但没有考虑时间问题，可以定期减少已访问次数。</li></ul><h4 id="磁盘调度" tabindex="-1"><a class="header-anchor" href="#磁盘调度"><span>磁盘调度</span></a></h4><ul><li>先来先服：简单粗暴，磁道分散，性能低</li><li>最短寻道时间优先：优先选择从当前磁头位置所需寻道时间最短的请求，存在饥饿</li><li>Scan：磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向。中间磁道访问频率高</li><li>CScan：磁头朝一个方向移动时处理请求，返回时直接复位不处理请求。对各个位置磁道响应频率比较平均</li><li>LOOK：类似 Scan，但磁头在移动到最远的请求位置时就立即反向移动。</li><li>C-LOOK：类似 CScan，也是最远请求时就返回，且返回途中不处理请求</li></ul><h3 id="文件系统" tabindex="-1"><a class="header-anchor" href="#文件系统"><span>文件系统</span></a></h3><p>Linux 一切皆文件，包括普通文件、目录、块设备、管道、Socket 等等</p><h4 id="基本组成" tabindex="-1"><a class="header-anchor" href="#基本组成"><span>基本组成</span></a></h4><p>Linux 为每个文件分配两个数据结构：</p><ul><li>inode：索引节点，文件的唯一标识，记录文件元信息，例如 inode 编号、文件大小、访问权限、创建/修改时间、磁盘位置等</li><li>dentry：目录项，多个目录项关联起来形成目录结构。记录文件的名字、inode 指针、其他目录项层级关联等。本质是内核在内存中维护的数据结构，不存放于磁盘。</li></ul>',96),i("figure",null,[i("img",{src:z,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s("<p>磁盘格式化时会被分成三个存储区域：</p><ul><li>超级块：用来存储文件系统的元信息，比如块个数、块大小、空闲块等等。挂载文件系统时进入内存</li><li>索引节点区：用来存储索引节点。当文件被访问时进入内存</li><li>数据块区：用来存储文件或目录数据。当文件被访问时进入内存</li></ul><p><strong>目录</strong></p><p>目录项记录着文件名，和索引节点是多对一的关系，即文件可以有别名，例如硬链接的实现。而目录也是磁盘上的文件，记录子目录和文件。目录项既可以表示文件，也可以表示目录项。</p><p><strong>存储</strong></p><p>磁盘读写的最小单位是扇区，默认 512B，而文件系统把多个扇区构成一个逻辑块，默认 4KB，以逻辑块为单位读写磁盘。</p><p><strong>虚拟文件系统</strong></p><p>VFS 位于用户层和文件系统中间，为用户提供一个统一的接口。根据存储位置的不同，分为磁盘文件系统（Ext2/3/4）、内存文件系统（/proc, /sys）、网络文件系统(NFS, SMB)</p>",8),i("figure",null,[i("img",{src:Y,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s('<p><strong>硬/软链接</strong></p><ul><li>硬链接：多个目录项中的索引节点指向一个文件 <ul><li>不可用于跨文件系统，每个文件系统有各自的 inode 结构和列表</li><li>只有删除文件的所有硬链接以及源文件时，系统才会删除该文件</li></ul></li><li>软链接：重新创建一个有独立 inode 的文件，其内容是另一个文件的路径 <ul><li>可以跨文件系统</li><li>即使目标文件删除了，软链接仍在，只不过找不到目标文件</li></ul></li></ul><h4 id="文件使用" tabindex="-1"><a class="header-anchor" href="#文件使用"><span>文件使用</span></a></h4><p>open -&gt; write/read -&gt; close</p><ul><li>打开文件后，OS 为每个进程维护一个打开文件表，每一项代表一个文件描述符 FD，包括： <ul><li>文件指针：跟踪读写位置</li><li>打开计数器：打开该文件的进程数，计数器为0时才关闭文件，删除该条目</li><li>文件磁盘位置</li><li>访问权限</li></ul></li></ul><h4 id="文件存储" tabindex="-1"><a class="header-anchor" href="#文件存储"><span>文件存储</span></a></h4><p><strong>连续存放</strong></p><ul><li>文件存放在磁盘连续的物理空间中</li><li>文件数据紧密相连，读写效率高（一次磁盘寻道就可以读出整个文件）</li><li>但会产生磁盘碎片、文件长度不易扩展的问题</li></ul><p><strong>非连续存放</strong></p><ul><li>链表方式： <ul><li>数据离散不连续，分隐式链表（指针相连）、显式链接（链接表存储块地址）</li><li>可以消除磁盘碎片，文件长度也可以动态扩展</li><li>但隐式链表无法直接访问数据块，只能通过指针顺序访问，而且指针还消耗额外存储空间</li><li>而显式链接通过文件分配表，提高了检索速度，减少磁盘访问次数，但不适用于大磁盘</li></ul></li><li>索引方式 <ul><li>为每个文件创建一个索引数据块，存放指向文件数据块的指针列表。文件头中保存索引数据块的指针</li><li>文件的创建、增大、缩小都很方便，没有碎片问题，支持顺序读写和随机读写</li><li>但存储索引占用额外空间。对于大文件，需要链式索引块/多级索引块</li></ul></li></ul><p>Unix 系统对于不同大小的文件，采取链表、一级索引、二级索引、三级索引等方式。</p><h4 id="空闲空间管理" tabindex="-1"><a class="header-anchor" href="#空闲空间管理"><span>空闲空间管理</span></a></h4><p><strong>空闲表</strong></p><ul><li>维护一张表，包括空闲区的第一个块号和空闲块个数</li><li>适用于少量空闲区场景，否则表项太多查询效率低</li></ul><p><strong>空闲链表</strong></p><ul><li>空闲块构成链表</li><li>简单，但不能随机访问，IO 多效率低，指针消耗了块的存储空间</li></ul><p><strong>位图法</strong></p><ul><li>Linux 文件系统采用了位图法，用二进制的一位来表示磁盘中一个块的使用情况</li><li>inode 空闲块也是位图法管理</li></ul><h4 id="文件-io" tabindex="-1"><a class="header-anchor" href="#文件-io"><span>文件 IO</span></a></h4><p><strong>缓冲/非缓冲 IO</strong></p><p>根据是否利用标准库缓冲，分：</p><ul><li>缓冲 IO：利用标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件</li><li>非缓冲 IO：直接通过系统调用访问文件，不经过标准库缓存</li></ul><p><strong>直接/非直接 IO</strong></p><p>根据是否利用操作系统的缓存，分：</p><ul><li>直接 IO：不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘</li><li>非直接 IO：读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘</li></ul><p>触发写回的场景有：</p><ul><li>在调用 write 的最后，当发现内核缓存的数据太多的时候，内核会把数据写到磁盘上；</li><li>用户主动调用 sync，内核缓存会刷到磁盘上；</li><li>当内存十分紧张，无法再分配页面时，也会把内核缓存的数据刷到磁盘上；</li><li>内核缓存的数据的缓存时间超过某个时间时，也会把数据刷到磁盘上；</li></ul><p><strong>阻塞/非阻塞 和 同步/异步 IO</strong>、</p><ul><li>阻塞 IO：程序执行 read 时线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，拷贝过程完成 read 才会返回</li><li>非阻塞 IO：read 请求在数据未准备好的情况下立即返回，程序可以继续往下执行。但应用程序会不断轮询内核，直到内核将数据准备好并将数据拷贝到应用程序缓冲区，read 调用才可以获取到结果（针对轮询的优化：IO 多路复用 select/poll/epoll）</li></ul><p>无论是阻塞 I/O、非阻塞 I/O，还是基于非阻塞 I/O 的多路复用都是同步调用，因为它们在 read 调用时，内核将数据从内核空间拷贝到应用程序空间的过程都是需要等待的，也就是说这个过程是同步的。</p><p>而真正的异步 I/O 是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都不用等待，例如 aio_read()</p><h4 id="page-cache" tabindex="-1"><a class="header-anchor" href="#page-cache"><span>Page Cache</span></a></h4><p>Page Cache 本质上是由 Linux 内核管理的内存区域，通过 mmap/buffered IO 将文件读取到内存空间实际上都是读取到 Page Cache 中。</p><ul><li>由多个 Page(4KB) 构成，但不是所有 Page 都构成 Page Cache，例如匿名页</li><li>Page Cache 用于缓存文件的页数据，buffer cache 用于缓存块设备（如磁盘）的块数据。</li><li>可以加快数据访问，同时基于预读，可以减少IO，提高磁盘吞吐量</li><li>但需要占用额外物理内存空间，物理内存紧张时可能导致频繁的 swap</li></ul><p><strong>数据一致性问题</strong></p><p>两方面：数据一致 + 元数据一致</p><ul><li>fsync(fd)：将文件的脏数据和脏元数据全部刷新至磁盘</li><li>fdatasync(fd)：将文件脏数据刷新至磁盘，同时只刷新必要的元数据，如文件大小</li><li>sync()：刷新回脏的文件元数据</li></ul><p><strong>对比 Direct IO</strong></p><ul><li>Page Cache 在内核空间开辟缓冲区</li><li>mmap：用户空间做内存映射，指向 Page Cache</li><li>Direct IO：去掉 Page Cache，交由 DMA，直接在用户空间开辟缓冲区</li></ul><h3 id="设备管理" tabindex="-1"><a class="header-anchor" href="#设备管理"><span>设备管理</span></a></h3><p>IO 设备分两大类：</p><ul><li>块设备：数据存储在固定大小的块中，每个块有自己的地址。如硬盘、USB等</li><li>字符设备：以字符为单位收发数据，不可寻址。例如鼠标、键盘等</li></ul><h4 id="设备控制器" tabindex="-1"><a class="header-anchor" href="#设备控制器"><span>设备控制器</span></a></h4><p>每个设备都有一个设备控制器，来屏蔽设备之间的差异。它包括：</p><ul><li>芯片：执行逻辑</li><li>寄存器： <ul><li>状态寄存器：告诉 CPU 工作是否已经完成</li><li>命令寄存器：保存要执行的命令</li><li>数据寄存器：保存需要传输的数据</li></ul></li></ul><p>块数据通常传输的数据量大，因此设备控制器设立了可读写的数据缓冲区。</p><p>设备控制器和 CPU 的通信方式包括：</p><ul><li>端口 IO：每个控制寄存器分配一个 I/O 端口，通过特殊汇编指令操作</li><li>内存映射 IO：将所有控制寄存器映射到内存空间中，这样就可以像读写内存一样读写数据缓冲区</li></ul><p><strong>IO 控制方式</strong></p><ul><li>轮询：傻瓜式，占用CPU</li><li>中断：软中断/硬中断，CPU 经常被打断占用</li><li>DMA：直接内存访问，由硬件完成数据读写内存，CPU 仅在传输开始和结束时干预</li></ul><h4 id="设备驱动程序" tabindex="-1"><a class="header-anchor" href="#设备驱动程序"><span>设备驱动程序</span></a></h4><p>设备控制器属于硬件，而设备驱动程序属于 OS。提供 OS -&gt; 设备驱动程序 -&gt; 设备控制器的中间层接口，初始化时需要注册中断处理函数。</p><p>IO 完成 -&gt; 控制器发起中断 -&gt; 保护被中断进程的 CPU 上下文 -&gt; 执行中断处理函数 -&gt; 恢复中断进程上下文</p><h4 id="通用块层" tabindex="-1"><a class="header-anchor" href="#通用块层"><span>通用块层</span></a></h4><p>针对块设备，Linux 通过通用块层管理不同的块设备，提供文件系统和驱动程序之间的抽象接口：</p><ul><li>向上为文件系统/应用程序提供访问块设备的标准接口</li><li>向下把各种磁盘设备抽象为统一的块设备</li><li>并且进行 IO请求 的调度，以提高读写效率</li></ul><p><strong>调度算法</strong></p><ul><li>无调度：不做任何处理。通常用于虚拟机，将 IO 交由物理机负责</li><li>先入先出</li><li>完全公平：每个进程维护一个 IO 调度队列，按时间片均匀分布每个进程的 IO请求</li><li>优先级调度：适合大量进程的系统，如桌面环境、多媒体应用等</li><li>最终期限调度：分读、写IO队列，并确保达到最终期限的请求被优先处理。适用于 IO压力大的场景。如 DB</li></ul><h4 id="linux-io-分层" tabindex="-1"><a class="header-anchor" href="#linux-io-分层"><span>Linux IO 分层</span></a></h4>',59),i("figure",null,[i("img",{src:$,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s('<ul><li>文件系统：虚拟文件/其它文件系统的具体实现，向上提供统一的文件访问接口，向下通过通用块层访问设备</li><li>通用块层：包括块设备的 I/O 队列和 I/O 调度器，选择 IO请求 发给设备层</li><li>设备层：包括硬件设备、设备控制器和驱动程序，负责最终物理设备的 I/O 操作</li></ul><p>Linux 提供了页缓存、索引节点缓存、目录项缓存、缓冲区等来提高 IO效率。</p><h3 id="网络系统" tabindex="-1"><a class="header-anchor" href="#网络系统"><span>网络系统</span></a></h3><h4 id="零拷贝" tabindex="-1"><a class="header-anchor" href="#零拷贝"><span>零拷贝</span></a></h4><p>DMA：Direct Memory Access 直接内存访问，在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，CPU 不再参与任何与数据搬运相关的事情，从而处理别的事务。如今每个 I/O 设备里都有自己的 DMA 控制器。</p><p>以文件传输的场景为例，数据从磁盘 -&gt; 内核缓冲区（磁盘高速缓存 PageCache）-&gt; 用户空间 -&gt; Socket 缓冲区 -&gt; 网卡。<br>整个过程需要产生4次内核态和用户态的上下文切换（read/write 2次系统调用），以及4次数据拷贝（CPU 和 DMA 各负责2次），效率很低。可以通过零拷贝技术减少这两个开销，实现方式有两种：</p><ul><li>mmap + write：<code>mmap()</code>系统调用直接把内核缓冲区里的数据映射到用户空间，减少了一次数据拷贝</li><li>sendfile：用一次<code>sendfile()</code>系统调用替代<code>read() + write()</code>，并且直接把内核缓冲区数据拷贝到 socket 缓冲区里，减少了2次上下文切换和1次数据拷贝</li><li>Zero-Copy: 如果网卡支持 SG-DMA 技术，网卡可以直接从内核缓冲中拷贝数据，全程不需要 CPU 拷贝，减少了2次上下文切换和2次数据拷贝</li></ul><p>也因此，零拷贝技术不允许对数据内容做进一步的加工。</p><p><strong>PageCache</strong><br>PageCache 的优化包括</p><ul><li>缓存最近被访问的数据</li><li>预读功能</li></ul><p>但对于大文件，PageCache 会被大文件占满，优化失效带来性能问题。因此高并发场景下，针对大文件的传输，尽量使用异步IO，绕开 PageCache（也称直接 IO，而使用 PageCache 的叫做 缓存IO）。另外，如果应用程序已经实现了磁盘缓存，可以使用 直接IO，减少额外性能损耗。</p><h4 id="i-o-多路复用" tabindex="-1"><a class="header-anchor" href="#i-o-多路复用"><span>I/O 多路复用</span></a></h4><p><strong>基本 Socket 模型</strong></p><p>通过 Socket 建立 TCP 连接时，监听和传输数据的是两个 Socket，OS 内核为每个 Socket 维护了两个队列：</p><ul><li>TCP 半连接队列：保存还没有完成三次握手的连接，此时服务端处于 syn_rcvd 的状态；</li><li>TCP 全连接队列：保存完成了三次握手的连接，此时服务端处于 established 状态；</li></ul><p>这种模式基于同步阻塞，只能一对一通信</p><p><strong>多进程模型</strong></p><p>服务器的主进程负责监听客户的连接，一旦与客户端连接完成，通过 fork 创建子进程服务客户。但是，子进程退出后可能保留一些信息成为僵尸进程消耗资源，需要主进程通过 wait/waitpid 回收资源。</p><p>由于进程上下文切换开销（虚拟内存、栈、全局变量等用户空间资源，以及内核堆栈、寄存器等内核空间资源）很大，因此这种模式并发量不能很高。</p><p><strong>多线程模型</strong></p><p>当服务器与客户端 TCP 完成连接后，通过 pthread_create() 函数创建线程，然后将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。但是频繁创建和销毁线程，系统开销也是不小的，可以通过线程池进行优化，但是注意需要对存放 Socket 的队列同步加锁。</p><p>无论基于进程还是线程，对于一台机器想要达到 C10K 的并发量还是很困难的。</p><p><strong>I/O 多路复用</strong></p><p>一个进程处理每个请求如果仅需 1ms，那么多个请求复用一个进程就可以实现高并发，也叫时分多路复用。<code>select/poll/epoll</code>是内核提供给用户态的多路复用系统调用，进程可以通过这些系统调用函数从内核中获取多个事件。</p><ol><li>select</li></ol><ul><li>将已连接的 Socket 放到一个文件描述符集合，然后调用 select 将文件描述符集合拷贝到内核里，由内核遍历判断是否有事件，标记可读/可写</li><li>接着再把整个描述符集合拷贝回用户态，用户态再遍历一次找到可读/可写的 Socket，取出进行处理</li><li>需要 2 次遍历文件描述符集合，用固定长度的 BitsMap 表示描述符集合，个数受限</li></ul><ol start="2"><li>poll</li></ol><ul><li>以链表形式组织一个动态数组表示文件描述符集合，和 select 一样也要在内核态和用户态各遍历 1 次</li></ul><ol start="3"><li>epoll</li></ol><ul><li>先用 epoll_create 创建一个 epoll 文件描述符 epfd，通过 epoll_ctl 将需要监视的 socket 添加到 epfd 中，最后调用 epoll_wait 等待数据</li><li>内核中使用红黑树来跟踪进程所有待检测的文件描述符，CRUD 效率很高</li><li>使用事件驱动的机制，内核中维护了一个链表来记录就绪事件，当某个 socket 有事件发生时，通过回调函数，内核会将其加入到这个就绪事件列表中。用户调用 epoll_wait 得到有事件发生的描述符个数。只将有事件发生的 Socket 集合传递给应用程序，因此只在 epoll_wait 期间发生了一次内存拷贝，大大提高了效率</li></ul><p>两种事件触发模式：</p><ul><li>边缘触发： <ul><li>当被监控的 Socket 描述符上有可读事件发生时，服务器端只会从 epoll_wait 中苏醒一次</li><li>因此程序要保证一次性将内核缓冲区的数据读取完；</li><li>一般和非阻塞 I/O 搭配使用，效率要高于水平触发</li></ul></li><li>水平触发： <ul><li>当被监控的 Socket 上有可读事件发生时，服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</li><li>select/poll 仅有水平触发，epoll 默认是水平触发</li></ul></li></ul><h4 id="网络模式" tabindex="-1"><a class="header-anchor" href="#网络模式"><span>网络模式</span></a></h4><p><strong>Reactor 模式</strong></p><p>一种非阻塞同步网络模式，对事件反应，来了一个事件，Reactor 就有相对应的反应/响应。核心部分有两个：</p><ul><li>Reactor：负责监听和分发事件，事件类型包含连接事件、读写事件；</li><li>处理资源池：负责处理事件，如 read -&gt; 业务逻辑 -&gt; send；</li></ul><p><strong>单 Reactor 单进程/线程</strong></p>',37),i("figure",null,[i("img",{src:X,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),i("p",null,"Reactor 对象通过 select（IO 多路复用接口）监听事件，将事件通过 dispatch 分发给 Acceptor / Handler。Acceptor 负责建立连接，并创建一个 Handler 对象来处理后续的响应事件。",-1),i("p",null,"缺点：",-1),i("ul",null,[i("li",null,"无法充分利用多核 CPU 性能"),i("li",null,"Handler 处理业务时无法处理其它事件")],-1),i("p",null,"实现简单，但仅适用于业务处理非常快速的场景，不适用计算机密集型的场景。例如 Redis 6.0 之前的版本就是 单 Reactor 单进程。",-1),i("p",null,[a("**"),i("em",null,"单 Reactor 多进程/线程")],-1),i("figure",null,[i("img",{src:Z,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),i("p",null,"Handler 对象不再直接负责业务处理，只负责数据接收和发送，read 读取到数据后交给子线程里的 Processor 进行业务处理，处理完后再发回 Handler。",-1),i("p",null,"缺点：只有一个 Reactor 承担所有事件的舰艇和响应，且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方。",-1),i("p",null,[i("strong",null,"多 Reactor 多进程/线程")],-1),i("figure",null,[i("img",{src:ii,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),i("p",null,[a("MainReactor 收到事件后将新连接分配给 SubReactor 继续监听，再次发生事件时由 SubReactor 调用相应的 Handler 响应。"),i("br"),a("主线程只负责接收新连接，子线程负责完成后续的业务处理，且无须返回数据。")],-1),i("p",null,"例如著名的 Netty、Memcache 都是多 Reactor 多线程，Nginx 是多 Reactor 多进程。",-1),i("p",null,[i("strong",null,"Proactor")],-1),i("figure",null,[i("img",{src:si,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s('<p>Proactor 是异步网络模式，不用等待 数据准备 和 数据拷贝 两个过程，完全由内核完成并通知。</p><p>Reacto 和 Proactor 都是一种基于<code>事件分发</code>的网络编程模式，区别在于 Reactor 感知的是就绪可读写（待完成）事件，Proactor 感知的是已完成的读写事件。</p><p>然而，Linux 下的 AIO 系列函数都是用户空间模拟的异步，且仅支持本地文件 AIO，不支持网络 Socket，因此基于 Linux 的高性能网络程序都是 Reactor 方案。</p><h4 id="一致性哈希" tabindex="-1"><a class="header-anchor" href="#一致性哈希"><span>一致性哈希</span></a></h4><p>不同的负载均衡算法适用的业务场景也不同的，例如轮询策略只适用于每个节点数据一致的场景，但是不适合分布式系统，可能访问不到需要的数据。</p><p>哈希算法可以建立数据和节点的映射关系，但节点变化时，所有数据需要进行迁移，开销过大。</p><p><strong>一致性哈希</strong></p><p>将「存储节点」和「数据」都映射到一个首尾相连的哈希环上，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响。</p>',8),i("figure",null,[i("img",{src:ai,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s('<p><strong>虚拟节点</strong></p><p>一致性哈希算法不能保证分布均匀，可能大量请求集中在一个节点。</p><p>因此可以引入虚拟节点，对一个真实节点做多个副本，并将虚拟节点也映射到哈希环上。以此提高节点的均衡度和稳定性。带虚拟节点的一致性哈希适合硬件配置不同的节点的场景，以及节点规模会发生变化的场景。</p><h4 id="网络性能" tabindex="-1"><a class="header-anchor" href="#网络性能"><span>网络性能</span></a></h4><p><strong>指标</strong></p><ul><li>带宽：链路的最大传输速率</li><li>延时：请求数据包发送后，收到对端响应，所需要的时间延迟</li><li>吞吐量：单位时间内成功传输的数据量</li><li>PPS：Packet Per Second 发包速率</li><li>网络可用性、并发连接数、丢包率、重传率</li></ul><p><strong>查看网络信息</strong></p><ul><li>ifconfig/ip 查看网络配合和收发数据包的统计信息</li><li>ss/netstat 查看 socket、网络协议栈、网口、路由表信息</li><li>sar 查看当前网络的吞吐率和 PPS</li></ul><h2 id="java" tabindex="-1"><a class="header-anchor" href="#java"><span>Java</span></a></h2><h3 id="集合" tabindex="-1"><a class="header-anchor" href="#集合"><span>集合</span></a></h3><h4 id="arraylist" tabindex="-1"><a class="header-anchor" href="#arraylist"><span>ArrayList</span></a></h4><ul><li>ArrayList底层是可以动态扩展的 Object 数组，默认初始容量是10。</li><li>当添加元素超过当前的 capacity 时，就会触发扩容机制，扩容机制主要由内部的 grow() 方法实现。 <ul><li>首先会根据默认容量和存储所需容量的较大者确定一个最小扩容容量<code>minCapacity</code></li><li>然后将现在的容量扩大1.5倍左右，确定一个新容量</li><li>接着开辟一个新数组，容量为上面两个容量的较大者，将所有元素复制到新数组中完成扩容</li></ul></li><li>最后把新添加元素放到扩容后的数组末尾</li></ul><h4 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap"><span>HashMap</span></a></h4><ul><li>JDK 1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表是为了用拉链法解决哈希冲突。</li><li>JDK 1.8 之后 HashMap 在解决哈希冲突时，如果链表长度大于8，并且数组长度超过64，就会把链表转化为红黑树，以减少搜索时间。</li><li>如果 HashMap 存储元素超过一个阈值，阈值等于当前容量 * 0.75（负载因子），就会将数组扩容至当前的2倍，然后进行rehash，把数据放到新的位置。</li></ul><p>默认大小是 16，负载因子 0.75 是统计学上 Hash 后遵循泊松分布的结果。扩容 $2^n$是为了在确定索引时<code>index = hashcode % capacity</code>可以利用位运算。</p><h4 id="hashtable-treemap" tabindex="-1"><a class="header-anchor" href="#hashtable-treemap"><span>HashTable/TreeMap</span></a></h4><p>HashTable 也实现了 Map 接口，基于锁机制实现了线程安全，因此效率低，多线程环境下推荐使用 ConcurrentHashMap。</p><p>TreeMap 是基于红黑树实现的有序键值对集合。</p><h4 id="set" tabindex="-1"><a class="header-anchor" href="#set"><span>Set</span></a></h4><ul><li>HashSet 底层基于 HashMap，使用哈希表存储元素，具有快速的查找性能，但不保证元素的顺序。</li><li>LinkedHashSet 底层使用哈希表存储元素，并通过链表维护元素的插入顺序。</li><li>TreeSet 底层实现是基于红黑树（TreeMap），支持元素自动排序</li></ul><h4 id="concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap"><span>ConcurrentHashMap</span></a></h4><p>JDK 7 以前的ConcurrentHashMap使用分段锁，每个segment上同时只有一个线程操作。JDK 8后理想情况下，每个table元素都可以并发：</p><ul><li>结构上是数组+链表/红黑树，当冲突链表达到一定长度时，链表会转换成红黑树。</li><li>ConcurrentHashMap 通过 CAS 和 Synchronized 实现并发安全</li><li>put放入元素的时候 <ul><li>首先根据 key 计算哈希定位 Node，如果对应位置的 Node 为 null，尝试 CAS 写入，失败就进入下次循环重试(最外层是个无限循环)</li><li>如果要放的位置为 MOVED（-1），说明其它线程正在扩容，参与一起扩容。</li><li>否则的话，通过 Synchronized 对 Node 加锁，判断是链表还是红黑树，写入数据，实现并发安全</li><li>最后进行检查，如果是链表，且长度超过阈值 8，就扩容数组/转换成红黑树（数组超过64）</li></ul></li><li>get获取元素的时候 <ul><li>直接根据哈希值，找对指定位置，如果头节点就是要找的直接返回</li><li>否则按链表/红黑树查找所要的元素</li><li>get 操作不需要加锁，因为 Node 的元素 val 和指针 next 都是 volatile 修饰的，可以保证多线程下并发的可见性。</li></ul></li><li>扩容的时候： <ul><li>先根据运算得到需要遍历的次数i，然后利用tabAt方法获得i位置的元素f，初始化一个forwardNode实例fwd</li><li>如果f == null，则在table中的i位置放入fwd，否则采用头插法的方式把当前旧table数组的指定任务范围的数据给迁移到新的数组中。然后给旧table原位置赋值fwd。</li><li>直到遍历过所有的节点以后就完成了复制工作，把table指向nextTable，并更新sizeCtl为新数组大小的0.75倍，扩容完成。</li><li>在此期间如果其他线程的有读写操作都会判断head节点是否为forwardNode节点，如果是就帮助扩容。</li></ul></li></ul><h4 id="copyonwritearraylist" tabindex="-1"><a class="header-anchor" href="#copyonwritearraylist"><span>CopyOnWriteArrayList</span></a></h4><p>在读写锁（仅写操作排他）的基础上，更进一步，读取完全不用加锁，仅写写互斥需要同步。</p><ul><li>CopyOnWriteArrayList 类的所有可变操作，如add、set等，都是创建底层数组的副本，修改完后再替换原有数据实现的</li><li>对于读操作，内部array不会发生修改，只会被替换，因此无需任何同步控制就可以保证数据安全</li><li>对于写操作，加锁保证同步，避免多线程写的时候拷贝多份副本</li></ul><h4 id="并发安全的-queue" tabindex="-1"><a class="header-anchor" href="#并发安全的-queue"><span>并发安全的 Queue</span></a></h4><p>Java 提供的线程安全的 Queue 分为阻塞队列、非阻塞队列。</p><p><strong>非阻塞队列 - ConcurrentLinkedQueue</strong></p><ul><li>通过 CAS 实现线程安全</li><li>底层使用链表，在高并发环境下性能非常好</li></ul><p><strong>阻塞队列 - BlockingQueue</strong></p><ul><li>通过加锁实现线程安全</li><li>广泛用于生产者-消费者模型，队列容器已满时，生产者线程阻塞，队列容器为空时，消费者线程阻塞，直至队列非空</li><li>继承自 Queue，实现类有： <ul><li>ArrayBlockingQueue：数组实现的有界队列，创建时指定容量。采用 ReentrantLock 控制并发，默认非公平</li><li>LinkedBlockingQueue：基于单向链表的无界/有界队列，可指定大小.采用 ReentrantLock 控制并发</li><li>PriorityBlockingQueue：基于堆的无界队列，支持优先级，内部自动扩容。采用 ReentrantLock 控制并发</li><li>SynchronousQueue：容量固定为 1 的同步队列，内部没有使用 AQS，而是通过 CAS 控制并发，生产和消费必须一一配对</li><li>DelayedWorkQueue：基于堆的优先级阻塞队列</li></ul></li></ul><h4 id="concurrentskiplistmap" tabindex="-1"><a class="header-anchor" href="#concurrentskiplistmap"><span>ConcurrentSkipListMap</span></a></h4><p>利用空间换时间的思想，通过维护多层链表实现的 Map，查询时间复杂度 O(logN)。内部通过 CAS 实现并发安全。</p><h3 id="io" tabindex="-1"><a class="header-anchor" href="#io"><span>IO</span></a></h3><h4 id="java-io-体系" tabindex="-1"><a class="header-anchor" href="#java-io-体系"><span>Java IO 体系</span></a></h4><p>顶层两大类四个接口：</p><ul><li><strong>InputStream/OutputStream：字节输入输出流</strong><ul><li>FileInputStream/FileOutputStream: 文件输入输出流</li><li>BufferedInputStream/BufferedOutputStream: 缓冲输入输出流，每次批量读/写字节到缓冲区，减少IO，提高重复单字节读写场景的效率</li><li>ObjectInputStream/ObjectOutputStream: 对象序列化/反序列化流</li><li>PrintStream：字节打印流</li></ul></li><li><strong>Reader/Writer：字符输入输出流</strong><ul><li>InputStreamReader/OutputStreamWriter: 字节 -&gt; 字符的转换流</li><li>FileReader/FileWriter: 文件字符输入输出流</li><li>BufferedReader/BufferedWriter：缓冲字符字符输入输出流</li><li>PrintWriter: 字符打印流</li></ul></li></ul><h4 id="io-中的设计模式" tabindex="-1"><a class="header-anchor" href="#io-中的设计模式"><span>IO 中的设计模式</span></a></h4><ol><li>装饰器模式<br><code>BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName), &quot;UTF-8&quot;));</code><br>通过组合替代继承，在不改变原有对象的情况下扩展原始类的功能。</li><li>适配器模式<br><code>InputStreamReader</code> 对字节解码，将字节流转化为字符流，<code>OutputStreamWriter</code> 对字符编码，将字符流转换为字节流<br>不同区装饰器侧重于动态增强原始类的功能，适配器专注解决接口不兼容，不能交互的类，让它们能够一起工作。</li><li>工厂模式<br>如<code>Files::newInputStream</code>创建InputStream对象，<code>Paths::get</code>创建Path对象...</li><li>观察者模式<br>NIO中的文件目录监听服务基于<code>WatchService</code>接口、<code>Watchable</code>接口，内部通过一个守护线程定期轮询检测文件变化实现。</li></ol><h4 id="io-模型" tabindex="-1"><a class="header-anchor" href="#io-模型"><span>IO 模型</span></a></h4><p>Unix中的五种IO模型：同步阻塞 I/O、同步非阻塞 I/O、I/O 多路复用、信号驱动 I/O 和异步 I/O</p><p>Java中的三种常见IO模型：</p><ul><li>BIO：同步阻塞IO，用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间</li><li>NIO，同步非阻塞IO，准备数据阶段不阻塞，只有拷贝阶段才阻塞，应用程序要不断轮询数据是否准备好。而IO多路复用通过 select/epoll 等系统调用减少CPU使用。Java使用Selector、Channel、Buffer等抽象实现。</li><li>AIO：异步IO，基于事件和回调机制</li></ul><h3 id="并发" tabindex="-1"><a class="header-anchor" href="#并发"><span>并发</span></a></h3><h4 id="线程安全的三大特性" tabindex="-1"><a class="header-anchor" href="#线程安全的三大特性"><span>线程安全的三大特性</span></a></h4><ul><li>原子性：若干个操作要么全部执行，要么全部不执行</li><li>可见性：当一个线程修改了共享变量的值，其他线程能够立即看到这个修改。（原因在于 Java 的共享内存模型，线程直接操作的都是缓存）</li><li>有序性：程序的执行顺序与代码的顺序相同（原因在于指令重排序）</li></ul><p>Synchronized 保证了原子性和可见性：加互斥锁 -&gt; 清空工作内存 -&gt; 拷贝最新数据到工作内存 -&gt; 执行代码 -&gt; 刷新工作内存到主内存 -&gt; 释放互斥锁</p><p>Volatile 保证了可见性和有序性：通过 store/load 指令保证对 volatile 变量的读写都是最新的，且通过内存屏障禁止指令重排序</p><h4 id="volatile-关键字" tabindex="-1"><a class="header-anchor" href="#volatile-关键字"><span>Volatile 关键字</span></a></h4><p>Volatile关键字的作用有两个：</p><ol><li>保证变量的可见性：每次对 volatile 修饰的本地变量修改时，会立刻刷新回主内存，读取时也会先从主内存读入本地内存再访问</li><li>通过插入特定的内存屏障，禁止指令重排序</li></ol><h4 id="创建线程的方式" tabindex="-1"><a class="header-anchor" href="#创建线程的方式"><span>创建线程的方式</span></a></h4><ol><li>继承 Thread 创建线程类，重写 run 方法。</li><li>实现 Runnable 接口实现 run 方法，并作为参数来创建 Thread。</li><li>实现 Callable 接口实现 call 方法，并作为参数来创建 FutureTask。Callable可以获取到返回值</li><li>除此之外，还可以使用线程池来创建线程</li></ol><h4 id="线程生命周期" tabindex="-1"><a class="header-anchor" href="#线程生命周期"><span>线程生命周期</span></a></h4><p>Java 线程在运行的生命周期中有 6 种不同状态：</p><ul><li>NEW：线程刚被创建的初始状态</li><li>RUNNABLE：调用start后的运行状态</li><li>BLOCKED：阻塞状态，需要等待锁释放</li><li>WAITING：等待状态，等待其它线程的一些特殊事件，如notify(), join()</li><li>TIMED_WAITING：有限等待</li><li>TERMINATED：线程执行完毕的终止状态<br>其中，Java中的Runnnable状态包含OS层面线程的Ready和Running两个状态</li></ul><h4 id="减少线程切换" tabindex="-1"><a class="header-anchor" href="#减少线程切换"><span>减少线程切换</span></a></h4><ul><li>无锁并发编程</li><li>CAS 算法</li><li>使用最少线程</li><li>协程</li></ul><h4 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池"><span>线程池</span></a></h4><p><strong>优点：</strong></p><ul><li>降低资源消耗</li><li>提高响应速度</li><li>提高线程的可管理性</li></ul><p><strong>Executor 框架：</strong><br>JDK 5 引入的管理线程池的框架，包括三大部分：</p><ul><li>任务 Runnable / Callable <ul><li>Callable可以返回结果/抛出异常</li></ul></li><li>执行者 Executor <ul><li>实现类 ThreadPoolExecutor，通过 execute/submit 提交执行</li></ul></li><li>异步计算结果 Future <ul><li>实现类 FutureTask</li></ul></li></ul><p><strong>submit 和 execute 区别</strong></p><ul><li><code>submit</code> 可以获得执行结果。实现上是将 Runnable/Callable 对象封装成 RunnableFuture 传递给 execute 执行，而 RunnableFuture 继承自 Runnable 并且可以保存执行结果。</li><li><code>execute</code> 只能执行 Runnable，因此不能获得执行结果</li></ul>',66),i("figure",null,[i("img",{src:li,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s(`<p><strong>ThreadPoolExecutor</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ThreadPoolExecutor</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> corePoolSize</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      // 指定常驻线程数量</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">                   int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> maximumPoolSize</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   // 指定允许的最大线程数量</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">                   long</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> keepAliveTime</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 当线程数量超过corePoolSize后，多余的空闲线程的存活时间</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">                   TimeUnit</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> unit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">         // keepAliveTime单位</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">                   BlockingQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">Runnable</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> workQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 任务队列，保存被提交但尚未被执行的任务</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">                   ThreadFactory</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> threadFactory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">       // 线程工厂，用于创建线程</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">                   RejectedExecutionHandler</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> handler   </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 任务过多时的拒绝策略</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">                   )</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>任务队列 - BlockingQueue：指被提交但未执行的任务队列，一个BlockingQueue接口的对象，仅用于存放Runnable对象。常用的队列实现有： <ul><li><code>SynchronousQueue</code>: 直接提交的队列，没有容量，来一个任务执行一个，没有多余线程则执行拒绝策略</li><li><code>ArrayBlockingQueue</code>: 有界任务队列，构造时指定容量</li><li><code>LinkedBlockingQueue</code>: 无界任务队列，任务繁忙时会一直创建线程执行，直至资源耗尽</li><li><code>PriorityBlockingQueue</code>: 带有执行优先级的无界队列</li></ul></li><li>拒绝策略 - RejectedExecutionHandler：指定当任务数量超过系统实际承载能力时的策略，通常是线程池中的线程已经用完，达到了最大线程数，排队队列也已满的情况。ThreadPoolExecutor提供了以下策略： <ul><li><code>AbortPolicy</code>: 默认策略，丢弃并抛出RejectedExecutionException异常</li><li><code>CallersRunsPolicy</code>: 绕过线程池，由主线程直接调用任务的run()方法执行</li><li><code>DiscardOldestPolicy</code>: 抛弃队列中等待最久的任务，然后尝试再次提交当前任务</li><li><code>DiscardPolicy</code>: 丢弃且不抛异常</li></ul></li></ul><p><strong>线程数量设定</strong></p><p>线程池的大小应该根据应用程序的负载进行调整，如果线程池太小，可能会导致应用程序的性能下降，因为没有足够的线程来处理所有的请求。如果线程池太大，也会导致程序的性能下降，因为线程之间的上下文切换会消耗大量的CPU时间。</p><ul><li>CPU 密集型：设置一个较小的线程数量，比如 N + 1，N 是 CPU 核心数，使得处理任务时充分利用 CPU</li><li>IO 密集型：设置一个较大的线程数量，比如 2N + 1，使得 CPU 等待 IO 完成时可以处理其它任务</li></ul><p><strong>线程执行逻辑</strong></p><p>在底层实现上，是不区分核心/非核心线程的，所有线程统一放在 Condition 的等待队列中，因此线程调度时执行的是轮询策略，线程池中的空闲线程依次执行任务。而过期销毁非核心线程是根据当前活跃的线程数来判断的。</p><h4 id="sleep-和wait-对比" tabindex="-1"><a class="header-anchor" href="#sleep-和wait-对比"><span>sleep()和wait()对比</span></a></h4><p>共同点：两者都可以暂停线程的执行<br>区别：</p><ul><li>sleep()不释放锁，而wait()会释放对应的对象锁</li><li>wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。除非使用 wait(long timeout) 超时后线程会自动苏醒。</li><li>sleep()方法执行完成后，线程会自动苏醒</li></ul><p>因此，wait()定义在Object类中，通常被用于线程间交互/通信，而sleep()是Thread类的静态方法，用于简单地暂停执行。</p><p>另外，yield() 方法是暂停当前正在执行的线程对象，并执行其他线程。join() 方法可以使得一个线程在另一个线程结束后再执行</p><h4 id="cas-底层实现" tabindex="-1"><a class="header-anchor" href="#cas-底层实现"><span>CAS 底层实现</span></a></h4><p>CAS 是一种通过硬件实现的乐观锁并发安全的技术，基本思想是，给定一个内存地址，一个期望值和一个新值，如果该地址的当前值和期望值相等，就用新值替换它，否则不做任何操作。底层实现依赖于 CPU 的 CAS 指令，保证了操作的原子性，Java 中可以通过 Unsafe 类的方法调用 CAS 指令。</p><p>CAS 存在 ABA 问题，可以通过版本号/标记位解决。</p><h4 id="threadlocal-原理" tabindex="-1"><a class="header-anchor" href="#threadlocal-原理"><span>ThreadLocal 原理</span></a></h4><p>每个线程内部都有一个 ThreadLocalMap 对象，本质上是一个键值对（key-value）映射，其中 key 是 ThreadLocal 实例对象本身的弱引用，value 是该线程内部的变量值。在不同线程中访问同一个 ThreadLocal 对象时，实际上是访问了各自线程内部的 ThreadLocalMap 对象中的不同 value，从而避免了多线程之间对变量的共享和访问冲突。</p>`,18),i("figure",null,[i("img",{src:ni,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s('<p><strong>使用场景</strong></p><ol><li>例如 SimpleDateFormat/Random 这样的工具类，每个线程都要用到，如果每个线程都 new 一个很麻烦，因此可以改成static共用。但是可能会线程不安全，因此可以使用 threadLocal 每个线程分配一个，保证线程安全</li><li>对于同一个线程内所有方法需要共享的资源，比如用户信息，为了避免参数一层层显式传递，同时保证线程的安全，可以使用 threadLocal 保存。这样每个线程内访问的都是相同的资源，不同线程访问的是不同资源。</li></ol><p><strong>为什么是弱引用</strong></p><p>假如使用强引用，当ThreadLocal不再使用需要回收时，发现某个线程中ThreadLocalMap存在该ThreadLocal的强引用，无法回收，从而造成内存泄漏。</p><p>使用弱引用可以防止长期存在的线程（通常使用了线程池）导致ThreadLocal无法回收造成内存泄漏。</p><p><strong>内存泄漏问题</strong></p><p>TheadLocalMap 的 key 所关联的 ThreadLocal 实例是弱引用，因此如果 key 没有其它关联的强引用，那么 key 就会被 GC 自动回收，而 value 是强引用不会被自动回收，导致 value 一直存在，产生内存泄漏。因此 ThreadLocal 在底层实现上会进行过期 Entry 的清理。</p><p><strong>Set() 实现</strong></p><ol><li>根据当前线程获取 ThreadLocalMap 对象，没有的话就新建</li><li>计算 key 的哈希，内部的 nextHashCode() 每次添加时自增一个斐波那契数/黄金分割数，来和数组/槽容量相与（使得哈希分布更均匀）</li><li>如果哈希对应的槽为空，直接放入</li><li>如果槽非空 <ul><li>并且 key 为 null，即该 Entry 的 key 弱引用已被 GC，说明这是个过期的槽 staleSlot，执行 replaceStaleEntry() 然后返回</li><li>并且 key 和当前 ThreadLocal 一致，直接更新；不一致就向后遍历直到找到空槽</li></ul></li><li>这时找到了一个空槽，创建一个新 Entry 放入</li><li>执行 cleanSomeSlots() 启发式清理； <ul><li>启发式清理结束后，如果 size 超过阈值（容量2/3），进行探测式清理 expungeStaleEntry()</li><li>探测式清理结束后，如果 size 超过 3/4 * thresh 就执行 rehash()</li></ul></li></ol><p><strong>过期 key 的清理</strong></p><p>replaceStaleEntry()</p><ul><li>从 staleSlot 向前迭代找过期槽，更新 slotToExpunge，直到空槽</li><li>从 staleSlot 向后迭代找 key 相同的，执行更新，直到空槽</li><li>最后从 slotToExpunge 开始执行启发式过期数据清理</li></ul><p>启发式清理 - cleanSomeSlots()</p><ul><li>当容量/2的位置开始探测式清理</li></ul><p>探测式清理 - expungeStaleEntry()</p><ul><li>以当前 Entry 往后清理，遇到值为 null 则结束清理，属于线性探测清理</li></ul><p><strong>get() 实现</strong></p><ol><li>计算 key 的哈希定位槽位</li><li>如果槽的 key 一致直接返回，否则向后迭代查找 <ul><li>迭代过程中如果发现空槽，触发探测式数据回收 expungeStaleEntry()</li></ul></li></ol><p><strong>InheritableThreadLocal</strong></p><p>ThreadLocal 无法在异步场景下给子线程共享父线程中创建的线程副本，可以使用 InheritableThreadLocal，在 Thread 构造方法中传递数据。<br>但一般异步处理都使用线程池复用，存在数据不一致问题，可以用阿里开源的 TransmittableThreadLocal 组件。</p><h4 id="synchronized-锁机制" tabindex="-1"><a class="header-anchor" href="#synchronized-锁机制"><span>Synchronized 锁机制</span></a></h4><p>指定对象/用于普通方法上是对实例对象加锁，指定类对象/用于静态方法就是对类加锁。本质上是竞争对象关联的 Monitor 对象的 Owner 身份。</p><p>JDK6 之前是基于监视器 Monitor 的重量级锁机制，在 JDK6 引入了偏向锁、轻量级锁等优化机制。</p><ul><li>偏向锁：当一个线程访问同步块并获得锁时，会在对象头和栈帧的锁记录里存储锁偏向的线程 ID，然后下一次这个线程再次访问同步块时，如果该对象没有被其它线程竞争，就可以直接进入，不需要获取锁资源。目的是在无竞争的情况下，减小锁的获取和释放的操作，提高程序的性能。</li><li>轻量级锁：用于多线程交替执行同步块的场景。如果一个线程试图进入同步块，但是发现对象头里锁偏向的线程 ID 不是自己，就会引发竞争，这时偏向锁就会升级成轻量级锁。轻量级锁使用 CAS 操作来尝试获取锁。如果CAS操作失败，表示有竞争，锁就会膨胀为重量级锁。</li><li>重量级锁：使用操作系统的互斥量（Mutex）来实现锁。在重量级锁的状态下，线程会被阻塞，直到获取到锁。</li></ul><p>除此之外，整个过程中还有自旋、自适应自旋等等的优化措施。</p><h4 id="aqs" tabindex="-1"><a class="header-anchor" href="#aqs"><span>AQS</span></a></h4><p>AbstractQueuedSynchronizer 抽象队列同步器，为建锁和同步器提供了一些通用功能的是实现，能简单且高效地构造出应用广泛的大量的同步器</p><p><strong>核心思想</strong></p><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是基于 CLH 锁实现的。</p><p>CLH 锁是对自旋锁的一种改进，是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系），暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 CLH 队列锁的一个结点（Node）来实现锁的分配。在 CLH 队列锁中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</p>',30),i("figure",null,[i("img",{src:ei,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s(`<p><strong>实现</strong></p><p>AQS 使用 int 成员变量 state 表示同步状态，通过内置的 线程等待队列 来完成获取资源线程的排队工作。</p><p>两种资源共享方式：Exclusive 独占、Share 共享。</p><p>基于AQS的同步工具类：Semaphore, CountDownLatch, CyclicBarrier...</p><h4 id="reentrantlock-原理" tabindex="-1"><a class="header-anchor" href="#reentrantlock-原理"><span>ReentrantLock 原理</span></a></h4><p>ReentrantLock 属于乐观锁类型，默认非公平的，多线程并发情况下。能保证共享数据安全性，线程间有序性。它通过原子操作和阻塞实现锁机制，一般使用 lock 获取锁，unlock 释放锁。</p><p>ReentrantLock 的可重入功能基于 AQS 的同步状态 state 实现的。当某一线程获取锁后，将 state 值+1，并记录下当前持有锁的线程，再有线程来获取锁时，判断这个线程与持有锁的线程是否是同一个线程，如果是，将 state 值再 +1，如果不是，阻塞线程。</p><h4 id="公平锁和非公平锁的实现" tabindex="-1"><a class="header-anchor" href="#公平锁和非公平锁的实现"><span>公平锁和非公平锁的实现</span></a></h4><p>公平锁和非公平锁是两种不同的锁的实现方式，它们的区别在于是否保证等待锁的线程按照先来后到的顺序获取锁。公平锁会让线程进入一个队列中排队等待，每次只有队首的线程能够获取锁，这样可以避免线程饥饿，但是会增加线程切换的开销。非公平锁则不考虑等待顺序，每个线程都有机会抢占锁，这样可以提高响应速度，但是可能导致某些线程长时间得不到锁。</p><p>以基于 AQS 的 ReentrantLock 为例，如果是公平锁，会先判断队列中是否有其他等待的节点，如果有，则直接加入到队尾；如果没有，则尝试修改state变量的值。非公平锁则不管队列中是否有其他等待的节点，直接尝试修改 state 变量的值，如果成功，则获取到了锁；如果失败，则再判断队列中是否有其他等待的节点，如果有，则加入到队尾；如果没有，则再次尝试修改state变量的值。</p><h3 id="jvm" tabindex="-1"><a class="header-anchor" href="#jvm"><span>JVM</span></a></h3><h4 id="内存区域" tabindex="-1"><a class="header-anchor" href="#内存区域"><span>内存区域</span></a></h4><p><strong>线程私有：</strong></p><ul><li>程序计数器： <ul><li>当前线程所执行的字节码的行号指示器，各线程私有互不影响，不会 OOM</li></ul></li><li>虚拟机栈： <ul><li>由一个个栈帧组成，栈帧包括局部变量表、操作数栈、动态链接、返回地址等信息</li><li>入栈、出栈对应方法的调用和结束（正常/异常）</li><li>若栈内存不允许动态扩展，栈深超过最大深度 -&gt; StackOverFlow</li><li>若栈内存允许动态扩展，无法申请足够栈空间 -&gt; OOM</li></ul></li><li>本地方法栈： <ul><li>和虚拟机栈基本类似，用于 Native 方法</li><li>HotSpot 虚拟机中和 Java 虚拟机栈合二为一</li></ul></li></ul><p><strong>线程共享：</strong></p><ul><li>堆： <ul><li>JVM 最大的一块内存，用于存放几乎所有的对象实例（栈上分配、标量替换等技术除外）</li><li>由GC管理，分新生代、老年代、永久代（元空间取代）</li><li>堆空间不足 -&gt; OOM</li></ul></li><li>方法区: <ul><li>存储已被虚拟机加载的类信息、常量、静态变量、代码缓存等数据</li><li>JDK 8 以前用永久代实现方法区，容易 OOM</li><li>JDK 8 后使用元空间实现方法区，使用直接内存，能加载更多类，不容易 OOM</li></ul></li></ul><h4 id="对象创建" tabindex="-1"><a class="header-anchor" href="#对象创建"><span>对象创建</span></a></h4><p><strong>创建过程：</strong></p><ol><li>类加载检查 <ul><li>遇到new指令时，先检查对应的类是否已经加载、解析和初始化，如果没有先执行类加载过程</li></ul></li><li>分配内存 <ul><li>从堆中分配内存</li><li>分配方式：规整的碰撞指针法 或 不规整的空闲列表法（取决于GC算法）</li><li>并发问题：CAS+失败重试 或 TLAB预先分配的缓冲内存</li></ul></li><li>初始化零值</li><li>设置对象头 <ul><li>Mark Word：HashCode、GC分代年龄、锁状态、偏向标记等</li><li>kClass Pointer：指向类元数据的指针</li></ul></li><li>执行对象的<code>&lt;init&gt;</code>方法（父类<code>&lt;init&gt;</code> -&gt; 实例域语句 -&gt; 构造方法）</li></ol><p><strong>对象内存布局：</strong></p><ul><li>对象头 <ul><li>Mark Word：HashCode、GC分代年龄、锁状态、偏向标记等</li><li>kClass Pointer：指向类元数据的指针</li></ul></li><li>实例数据：对象真正存储的有效信息</li><li>对齐填充：8Byte对齐</li></ul><p><strong>对象访问定位：</strong><br>栈帧的局部变量表中的reference引用 --&gt; 堆中对象实例 和 方法区中对象类型</p><ul><li>句柄：堆中划分句柄池，记录对象实例指针和对象类型指针。优点是稳定，对象移动时只要改变句柄</li><li>直接指针：直接指向堆中对象实例。优点是速度快，节省一次指针定位。</li></ul><h4 id="对象存活判断" tabindex="-1"><a class="header-anchor" href="#对象存活判断"><span>对象存活判断</span></a></h4><p><strong>判断方法</strong></p><ul><li>引用计数法：计数器加减。无法解决循环依赖问题</li><li>可达性分析：GC Roots 引用链分析，如果一个对象到 GC Roots 没有任何引用链相连，即不可达对象，可以被回收。GC Roots 通常包括： <ul><li>虚拟机栈/本地方法栈 中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li></ul></li></ul><p><strong>引用类型</strong></p><ul><li>强引用<code>Strongly Reference</code>：任何情况下都不回收此对象，甚至抛出OOM</li><li>软引用<code>Soft Reference</code>：可有可无，内存足够就不回收，内存溢出前才回收</li><li>弱引用<code>Weak Reference</code>：弱于软引用，GC扫描到就立即回收</li><li>虚引用<code>Phantom Reference</code>：也叫幻影引用，任何时候都可能被回收，主要用于跟踪对象被垃圾回收的活动</li></ul><h4 id="gc-算法" tabindex="-1"><a class="header-anchor" href="#gc-算法"><span>GC 算法</span></a></h4><ul><li>标记-清除算法 Mark-Sweep <ul><li>过程：标记出需要回收的对象，然后统一回收</li><li>缺点：执行效率随对象数量增长而降低、内存碎片化</li></ul></li><li>标记-复制算法 Mark-Copy <ul><li>将内存划为大小相等的两块，每次使用其中一块。当一块内存用完，将存活对象复制到另一块上面，然后把已使用的内存块一次性清理掉</li><li>缺点：将可用内存缩小为原来的一半</li><li>改进：Appel式回收，划分为一块较大的<code>Eden</code>空间和两块较小的<code>Survivor</code>空间，每次分配只用<code>Eden</code>和其中一块<code>Survivor</code></li></ul></li><li>标记-整理算法 Mark-Compact <ul><li>先标记出需要回收的对象，然后让所有存活对象移向内存空间的一端，最后直接清理掉边界以外的内存</li><li>缺点：移动时必须 STW</li></ul></li></ul><p>新生代：一般使用 <strong>标记-复制</strong> 算法，因为每次 GC 都会有大量对象死亡，只要复制少量对象即可完成。<br>老年代：一般使用 <strong>标记-清除</strong>、<strong>标记-整理</strong> 算法，因为其中的对象存活几率较高，而且没有额外空间分配担保</p><h4 id="gc-分类" tabindex="-1"><a class="header-anchor" href="#gc-分类"><span>GC 分类</span></a></h4><p>JVM 的堆内存分为新生代、老年代，分别对应 Young GC、Full GC。划分不同的内存空间是为了优化 GC 性能，新生代的复制算法能够快速回收掉生命周期短暂的对象，而老年代的垃圾回收则更加谨慎，因为它包含了较长时间存活的对象。这种分代的设计提高了垃圾回收的效率，提供了更好的性能和响应时间。</p><p><strong>Young GC</strong></p><p>新生代是用于存储新创建的对象的区域。在新生代中，大部分对象都是朝生夕灭的，也就是说，它们很快就会变得不可达并被回收。因此 Young GC 非常频繁，回收速度也比较快。当 Eden 区空间不足或 Survivor 区空间不足时，就会触发 Young GC，将 Eden 区和 Survivor 区中存活的对象复制到另一个 Survivor 区，然后清空 Eden 区和原 Survivor 区。</p><p>频繁 Young GC 可能的原因：</p><ul><li>Eden/Survivor 区空间不足，触发 Young GC</li><li>对象过多，导致 Eden/Survivor 区满了，触发 Full GC，间接触发 Young GC</li></ul><p>优化：</p><ul><li>增加 JVM 内存</li><li>调整 JVM 参数</li><li>减少对象创建、对象引用、对象大小</li></ul><p><strong>晋升老年代</strong></p><p>老年代用于存储较长时间存活的对象。当对象在新生代经过多次(15次)垃圾回收仍然存活时，它们会被晋升到老年代。此外还有一些特殊情况：</p><ol><li>对象的大小大于 Eden 的二分之一会直接分配在 old 区</li><li>Young GC 后，Survivor 仍然放不下则放到老年代</li><li>动态年龄判断，大于等于某个年龄的对象超过了 Survivor 空间一半 ，大于等于某个年龄的对象直接进入老年代</li></ol><p><strong>Full GC</strong></p><p>指对整个堆内存进行垃圾回收，包括新生代和老年代。Full GC 的过程是：首先会执行一次 Young GC，然后对整个堆进行垃圾回收。Full GC 会暂停整个应用程序，通常开销较大，频率较低。</p><p>触发 Full GC 的时机：</p><ul><li><code>System.gc()</code>方法的调用，不一定立即回收</li><li>老年代空间不足</li><li>永久代/元空间不足</li><li>Minor GC 前，会检查老年代是否有足够的连续空间，如果当前老年代最大可用连续空间小于平均历次晋升到老年代大小，则触发 Full GC。（排查是不是频繁创建大对象）</li><li>Minor GC 后，新生代 Survivor 空间不足，需要放入老年代，而老年代空间也不足，则触发Full GC</li></ul><h4 id="gc-实现" tabindex="-1"><a class="header-anchor" href="#gc-实现"><span>GC 实现</span></a></h4><p>垃圾收集算法是内存回收的方法论，而垃圾收集器就是垃圾收集算法的具体实现。</p><p><strong>GC分类:</strong></p><ul><li>部分收集 <code>Partial GC</code><ul><li>新生代收集 <code>Minor GC</code></li><li>老年代收集 <code>Major GC</code></li><li>混合收集 <code>Mixed GC</code></li></ul></li><li>整堆收集 <code>Full GC</code></li></ul><p><strong>Serial</strong></p><ul><li>用于新生代，单线程，基于标记-复制算法</li><li>简单高效，但GC时必须STW</li></ul><p><strong>Serial Old</strong></p><ul><li>用于老年代，单线程，基于标记-整理算法</li><li><code>Serial</code>的老年代版本，可以作为 CMS 的后备方案</li></ul><p><strong>ParNew</strong></p><ul><li>用于新生代，多线程，基于标记-复制算法</li><li><code>Serial</code>的多线程版本，GC时必须STW</li></ul><p><strong>Parallel Scavenge</strong></p><ul><li>用于新生代，多线程，基于标记-复制算法</li><li>类似<code>ParNew</code>，区别在于目标是达到一个可控的吞吐量, 因此提供了很多参数调节和自适应调节策略</li></ul><p><strong>Parallel Old</strong></p><ul><li>用于老年代，多线程，基于标记-整理算法</li><li><code>Parallel Scavenge</code>的老年代版本，注重吞吐量和CPU资源</li></ul><p><strong>CMS (Concurrent Mark-Sweep)</strong></p><ul><li>用于老年代，多线程，基于标记-清除算法</li><li>四个步骤： <ul><li>初始标记：标记<code>GC Roots</code>能直接关联的对象。</li><li>并发标记：遍历对象图。与用户线程并发。</li><li>重新标记：修正并发标记阶段产生的标记变动(因用户线程的并发执行)。STW。</li><li>并发清除：清理标记死亡的对象。与用户线程并发</li></ul></li><li>优点：并发收集，低停顿。仅重新标记阶段需要STW</li><li>缺点：对CPU资源敏感，无法处理&quot;浮动垃圾&quot;， 存在大量内存碎片</li></ul><p>CMS 尽可能减小应用程序的停顿时间，适合要求低延迟的场景。</p><p><strong>G1</strong></p><ul><li>面向局部收集的设计思路和基于Region内存布局</li><li>Region： <ul><li>连续的Java堆划分为多个大小相等的独立Region，每个Region根据需要扮演Eden/Survivor/老年代</li><li>Humongous区域专门存储大对象</li><li>G1跟踪各个Region里面的垃圾堆积的&quot;价值&quot;大小。价值即回收所获得的空间大小以及回收所需时间的经验值，后台维护一个优先级列表。</li></ul></li><li>四个步骤： <ul><li>初始标记：标记<code>GC Roots</code>能直接关联的对象，并修改TAMS指针以便正确分配对象。暂停用户线程。</li><li>并发标记：遍历对象图。与用户线程并发。(用SATB原始快照处理引用变化)</li><li>最终标记：处理并发阶段结束后遗留的少量SATB记录。暂停用户线程。</li><li>筛选回收：更新Region的统计数据，根据优先级选择Region回收集，移动存活对象并清理旧Region的全部空间。暂停用户线程。</li></ul></li><li>目的：延迟可控的情况下，获得尽可能高的吞吐量。</li><li>特点：并发、独立GC分代收集、空间整合、可预测停顿</li></ul><p>G1 适合大内存的应用，能够获得更高的吞吐量。</p><h4 id="类文件结构" tabindex="-1"><a class="header-anchor" href="#类文件结构"><span>类文件结构</span></a></h4><p>魔数、Class文件版本号、常量池、访问标志、当前类、父类、接口的索引集合、字段表集合、方法表集合、属性表集合 十大块。</p><h4 id="类加载过程" tabindex="-1"><a class="header-anchor" href="#类加载过程"><span>类加载过程</span></a></h4><ol><li><strong>加载（Loading）：</strong> 类的加载阶段是指将类的字节码数据从文件或其他途径读取到内存中，并且在内存中创建一个代表该类的<code>java.lang.Class</code>对象。类加载器负责完成加载阶段的工作。加载条件：仅当有类主动去使用该Class。包括new、反射、克隆、反序列化、调用类静态方法、调用其子类、main方法等等。</li><li><strong>链接（Linking）：</strong> 链接阶段包括三个子阶段：验证（Verification）、准备（Preparation）、解析（Resolution）。</li></ol><ul><li><strong>验证：</strong> 确保被加载的类的正确性，包括文件格式的验证、元数据的验证、字节码的验证、符号引用的验证。</li><li><strong>准备：</strong> 在方法区中为类的静态变量分配内存，并将其初始化为默认值。</li><li><strong>解析：</strong> 将常量池内的符号引用替换为直接引用，得到类/接口/字段/方法在内存中的指针或偏移量</li></ul><ol start="3"><li><strong>初始化（Initialization）：</strong> 调用类对象的<code>&lt;clinit&gt;()</code>方法，对类变量赋值。<code>&lt;clinit&gt;</code>是编译器自动收集类中所有类变量的赋值动作和静态代码块（<code>static{}</code>块）中的语句合并产生的。当初始化一个类时，其父类尚未初始化，则需要先触发其父类的初始化。虚拟机会保证一个类的初始化过程是线程安全的。</li><li><strong>使用</strong></li><li><strong>卸载</strong>：该类的 <code>Class对象</code> 被GC，要求：</li></ol><ul><li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被 GC（所以JDK自带类加载器加载的类不会被回收）</li></ul><h4 id="类加载器" tabindex="-1"><a class="header-anchor" href="#类加载器"><span>类加载器</span></a></h4><p><strong>内置类加载器：</strong></p><ul><li><code>BoostrapClassLoader</code> 启动类加载器：C++实现的顶层加载器，负责加载java/base下的核心系统类</li><li><code>ExtentionClassLoader</code> 扩展类加载器：负责加载扩展目录下的jar包和类。JDK 9 移除。</li><li><code>PlatformClassLoader</code> 模块加载器：JDK9引入取代Ext，负责加载非核心模块类</li><li><code>AppClassLoader</code> 应用程序类加载器：负责加载用户应用classpath下的所有jar包和类</li></ul><p><strong>双亲委派模型：</strong></p><ul><li>除 BootstrapClassLoader 外，每个类加载器都有对应的父类加载器。如果父类加载器为 null，默认就是 BootstrapClassLoader（自定义加载器继承ClassLoader）</li><li>任意一个 ClassLoader 在尝试加载一个类的时候，都会先自底向上尝试调用父类的<code>loadClass()</code>方法去加载类，如果父类不能加载该类，再自顶向下交由子类去完成。</li><li>好处：避免类的重复加载，限制使用者对JVM系统的影响。保证了Java程序的稳定运行</li></ul><h4 id="内存排查工具" tabindex="-1"><a class="header-anchor" href="#内存排查工具"><span>内存排查工具</span></a></h4><p><strong>JMeter 压测</strong></p><p>添加线程组 -&gt; 查看结果树和汇总报告 -&gt; 分析异常比例、吞吐量、响应时间等。</p><p><strong>JConsole</strong></p><p>Java 监视和管理控制台，根据 PID 连接查看进程信息，可以查看虚拟机内存使用情况，包括堆空间、Eden、Survivor等，包括 Young GC、Old GC 时间，以及线程数量等信息</p><p><strong>jmap</strong><br><code>jstack</code> 查看堆栈信息，以及排查死锁问题<br><code>jhsdb jmap --heap --pid 20536</code> 查看进程使用的GC算法、堆配置信息和各内存区域内存使用信息<br><code>jstat -gc -h3 31736 1000 10</code> 查看 GC 情况，各个空间的使用量<br><code>jmap -dump:format=b,file=dump.hprof 20536</code> 生成堆转储快照 heap profile -&gt; VisualVM/JProfile 查看内存占用情况 -&gt; 定位大对象 -&gt; 定位代码中创建的位置 -&gt; 排查 BUG</p><h3 id="其它" tabindex="-1"><a class="header-anchor" href="#其它"><span>其它</span></a></h3><h4 id="反射机制" tabindex="-1"><a class="header-anchor" href="#反射机制"><span>反射机制</span></a></h4><p>反射可以在运行时分析类以及执行类中方法，通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。例如 Spring、MyBatis 等框架大量使用反射机制，动态代理的实现也依赖于反射。</p><p>反射可以让代码更加灵活，为各种框架开箱即用提供便利；但也增加了安全问题，比如无视泛型参数的安全检查，性能也会稍差一点。</p><p>获取Class对象的四种方法：</p><ul><li>Target.class</li><li>Class.forName(...)</li><li>instance.getClass()</li><li>ClassLoader::loadClass(...)</li></ul><h4 id="代理模式" tabindex="-1"><a class="header-anchor" href="#代理模式"><span>代理模式</span></a></h4><p>代理模式是一种使用代理对象来代替对真实对象访问的设计模式，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p><p><strong>静态代理</strong></p><ul><li>对目标对象每个方法的增强都手动完成。（创建接口，实现类和代理类，将目标对象注入进代理类，在代理类的对应方法调用目标类中的对应方法并做增强）</li><li>JVM层面上，静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</li><li>缺点：不灵活且麻烦</li></ul><p><strong>动态代理</strong></p><ul><li>JVM 层面上，动态代理是在运行时动态生成类字节码，并加载到 JVM 中。更加灵活。</li><li>JDK 动态代理： <ul><li><code>Proxy.newProxyInstance(ClassLoader, Class[], InvocationHandler)</code> 获得某个类的代理对象</li><li>当动态代理对象调用一个方法时，这个方法的调用就会被转发到实现 InvocationHandler 接口类的 <code>invoke(ProxyObject, Method, args)</code> 方法来调用</li><li>缺点：只能代理实现了接口的类</li></ul></li><li>CGLIB 动态代理 <ul><li>一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。通过继承方式实现代理。</li><li>例如 Spring 的 AOP 模块，如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</li><li>Enhancer 类用于动态获取被代理类</li><li>自定义 <code>MethodInterceptor::intercept(Object, method, args, proxy)</code> 实现增强。当代理类调用方法的时候，实际调用的是 MethodInterceptor 中的 intercept 方法。</li></ul></li></ul><p>JDK 动态代理基于接口实现，只能代理实现了接口的类，而 CGLIB 基于继承，可以代理任何类。</p><h4 id="异常机制" tabindex="-1"><a class="header-anchor" href="#异常机制"><span>异常机制</span></a></h4><p><strong>异常分类</strong></p><ul><li><code>Throwable</code> 是所有异常和错误的超类 <ul><li><code>Error</code> 错误：一般是与 JVM 相关的问题，如系统崩溃，内存空间不足，方法调用栈溢出等。Error 一般会导致程序中断，并且无法恢复和预防。例如 OutOfMemoryError, StackOverFlowError</li><li><code>Exception</code> 异常：程序运行中可以预料的意外情况，并且应该被捕获进行处理，使程序恢复运行 <ul><li><code>RuntimeException</code> 运行时异常：都是非检查异常，例如 NullPointerException, ArrayIndexOutOfBounds, IllegalArgument...</li><li>非运行时异常：都是检查异常/编译时异常，例如 IOException, NoSuchMethodException</li></ul></li></ul></li></ul><p>检查异常在编译前需要手动处理，要么在方法上通过 <code>throws</code> 抛出，由调用该方法的方法处理异常，要么 <code>try-catch</code> 捕获异常自己处理。检查异常会在方法调用链上显式传递，因此推荐使用非检查异常。</p><p><strong>finally 块原理</strong></p><ul><li>字节码层面上，会把 finally 语句复制到 try 和 catch 块的末尾。</li><li>如果 finally 块有 return 语句，那么 try/catch 块中的 return 都会失效。</li><li>如果 finally 块没有 return 语句，那么无论在 finally 块中是否修改返回值，返回值都不会改变，仍然是执行 finally 代码块之前的值。</li><li>try-with-resources 语法糖经过编译后转换为 try-catch-finally 语句</li></ul><h4 id="static-关键字" tabindex="-1"><a class="header-anchor" href="#static-关键字"><span>static 关键字</span></a></h4><p>static 关键字可以修饰 类、方法、变量和代码块。</p><ol><li>修饰类：被 static 修饰的类称为静态内部类。静态内部类可以访问外部类的静态成员变量和方法，但不能访问外部类的非静态成员。</li><li>修饰方法：被 static 修饰的方法称为静态方法。静态方法可以直接通过类名调用，不需要实例化对象。静态方法只能访问类的静态成员变量和方法，不能访问非静态成员变量和方法。</li><li>修饰变量：被 static 修饰的变量称为静态变量，也称为类变量。静态变量在类加载时被初始化，并且所有对象共享同一个静态变量的值。静态变量可以通过类名直接访问，也可以通过对象名访问。</li><li>修饰代码块：被 static 修饰的代码块称为静态代码块。静态代码块在类加载时被执行，只执行一次。静态代码块通常用于初始化静态成员变量。</li></ol><p>另外，子类不能覆写父类的静态方法（@Override会报错），但是可以定义相同方法将其隐藏。</p><h4 id="equals-和-hashcode" tabindex="-1"><a class="header-anchor" href="#equals-和-hashcode"><span>equals() 和 hashcode()</span></a></h4><ul><li>在Java中，如果两个对象的 equals() 返回 true，则它们的 hashcode() 必须返回相同的值。</li><li>因为在 Java 中，hashcode() 用于获取对象的哈希值，而哈希值用于确定对象在哈希表中的索引位置。如果索引位置上已经有元素了，会调用 equals() 判断两个对象是否相同，相同就添加失败，不相同就散列到其它位置上。</li><li>如果重写了 equals(), 但没有重写 hashcode()，会导致所有对象的 hashcode 都不相同，都能添加成功，那么基于哈希的集合就会出现很多重复元素</li></ul><h4 id="string-类型" tabindex="-1"><a class="header-anchor" href="#string-类型"><span>String 类型</span></a></h4><p><strong>存储位置</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 在方法区的常量池中，引用存储的也是常量池中的地址（常量池在编译期间就会生成）</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> str1 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;hello&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> str2 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;hello&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(str1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">str2);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> //true</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 堆中，引用存储的也是堆中的地址</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> str3 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;高大天&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> str4 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;高大天&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(str3</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">str4);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> //false</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在进行字符串拼接时，如果都是静态字符串相加，结果会加入常量池；如果含有变量则不会进入常量池。String::intern() 会将该字符串对应的常量加入常量池，并返回在常量池中的地址。</p><p><strong>不可变对象</strong></p><p>String 底层是 final 修饰的 char[] 数组，因此是不可变的。好处是便于实现字符串常量池，使多线程安全，避免安全问题，以及加快字符串处理速度。StringBuilder不是线程安全的，而StringBuffer是线程安全的</p><h2 id="mysql" tabindex="-1"><a class="header-anchor" href="#mysql"><span>MySQL</span></a></h2><h3 id="三范式" tabindex="-1"><a class="header-anchor" href="#三范式"><span>三范式</span></a></h3><ul><li>第一范式： 要求任何一张表必须有主键，每个字段都不可再分。</li><li>第二范式： 建立在第一范式的基础之上，要求所有非主键字段完全依赖主键，不要产生部分依赖。</li><li>第三范式： 建立在第二范式的基础之上，要求所有非主键字段直接依赖主键，不要产生传递依赖。</li></ul><h3 id="sql-注入" tabindex="-1"><a class="header-anchor" href="#sql-注入"><span>SQL 注入</span></a></h3><p>所谓SQL注入，就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p><ol><li>尽量用预编译机制 prepareStatement，少用字符串拼接的方式传参，它是sql注入问题的根源。</li><li>要对特殊字符转义，比如 % 作为 like 语句中的参数时，要对其进行转义处理</li><li>对所有的异常情况进行捕获，不要在接口直接返回异常信息，因为有些异常信息中包含了sql信息，比如库名，表名，字段名等。攻击者拿着这些信息，就能通过sql注入随心所欲的攻击你的数据库了。</li><li>使用sqlMap等代码检测工具，它能检测sql注入漏洞。</li><li>需要对数据库sql的执行情况进行监控，有异常情况，及时邮件或短信提醒。</li><li>对生产环境的数据库建立单独的账号，只分配DML相关权限，且不能访问系统表。切勿在程序中直接使用管理员账号。</li><li>建立代码review机制，能找出部分隐藏的问题，提升代码质量。</li><li>对于不能使用预编译传参时，要么开启druid的filter防火墙，要么自己写代码逻辑过滤掉所有可能的注入关键字。</li></ol><h3 id="架构" tabindex="-1"><a class="header-anchor" href="#架构"><span>架构</span></a></h3><p>主要分为两层：Server 层和存储引擎层。</p><ol><li>Server 层：负责 MySQL 的所有核心服务，包括连接管理、安全认证、SQL 解析与执行、事务管理、并发控制、日志记录等。Server 层与存储引擎层之间通过 API 进行通信。</li><li>存储引擎层：负责 MySQL 数据的存储和读取。MySQL 支持多种存储引擎，如 InnoDB、MyISAM、Memory、CSV 等。每个存储引擎都有其独特的数据存储和索引结构，可以根据不同的场景选择不同的存储引擎，提高数据访问效率。</li></ol><p>在架构上，MySQL 的 Server 层和存储引擎层是相互独立的，用户可以通过替换存储引擎来改变 MySQL 的数据存储方式，而不会影响 MySQL Server 层的其他功能。</p>`,125),i("figure",null,[i("img",{src:ti,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s('<h3 id="innodb-和-myisam-区别" tabindex="-1"><a class="header-anchor" href="#innodb-和-myisam-区别"><span>InnoDb 和 MyISAM 区别</span></a></h3><ol><li>InnoDB 支持事务和 MVCC，MyISAM 不支持</li><li>InnoDB 支持外键，MyISAM 不支持</li><li>InnoDB 支持行级锁和表级锁，并且默认就是行级锁，MyISAM 只支持表级锁</li><li>InnoDB 是聚集索引，数据即索引，MyISAM 只有二级索引，数据和索引是分离的</li><li>InnoDB 不支持全文检索，MyISAM 支持</li></ol><h3 id="myisam-的优势" tabindex="-1"><a class="header-anchor" href="#myisam-的优势"><span>MyISAM 的优势</span></a></h3><ol><li>快速：MyISAM 存储引擎使用表级锁，因此在读写操作时不会出现死锁问题，且在读操作时不需要加锁，因此读取速度较快，适合于以读操作为主的应用场景。</li><li>索引：MyISAM 存储引擎支持全文本索引和空间索引，能够满足一些特殊的查询需求。</li><li>低存储空间：MyISAM 存储引擎对数据存储的方式非常紧凑，数据文件大小通常比 InnoDB 存储引擎小，因此对于存储空间有限的应用场景来说，MyISAM 更为适合。</li></ol><h3 id="对比-nosql" tabindex="-1"><a class="header-anchor" href="#对比-nosql"><span>对比 NoSQL</span></a></h3><ul><li>关系型数据库基于表的结构，适用于处理结构化数据；NoSQL 通常是键值对、文档、图形等数据结构，适合存储半结构化/非结构化数据</li><li>MySQL 数据表需要严谨的设计；NoSQL 数据库不需要事先设计好，支持动态添加字段和修改结构，灵活性和扩展性更好</li><li>MySQL 使用 SQL 语句进行查询，支持复杂的关系查询和聚合操作；NoSQL 则使用各种不同的查询语句进行查询，不支持复杂关系查询，但读取和写入效率更高</li></ul><p>使用场景需要基于应用的实际需求、数据处理量、数据类型和数据访问模式等考虑。MySQL 适合数据结构固定、需要处理事务、处理海量数据、高度关联的应用。NoSQL 适合处理非结构化数据、高扩展性和高并发、实时查询、数据分析的场景。</p><h3 id="索引" tabindex="-1"><a class="header-anchor" href="#索引"><span>索引</span></a></h3><h4 id="索引类型" tabindex="-1"><a class="header-anchor" href="#索引类型"><span>索引类型</span></a></h4><ul><li>聚集索引：按表中的主键建立的索引，叶子节点存放的就是实际的行数据。（主键索引）</li><li>非聚集索引：按表中的非主键建立的索引，叶子节点存放的是主键值，如果需要其他列信息需要进行回表查询。（非主键/二级索引）</li></ul><h4 id="b-树-对比" tabindex="-1"><a class="header-anchor" href="#b-树-对比"><span>B+树 对比</span></a></h4><ul><li>使用哈希表可以把检索单个数据的复杂度近似为O(1)，但是哈希表不支持排序和范围查找，如果是带条件的批量检索数据就得一次次 IO 去查找</li><li>红黑树在大数据量的情况下，层级较深，可能导致检索速度慢的问题</li><li>B 树（B- 树），一种多路平衡查找树，它的所有节点既放键，也放数据，所以一个数据页中存储的键值对比较少，因此空间利用率较低，进而导致 IO 次数增加，性能降低</li><li>而 B+ 树，仅在叶子节点存放数据，非叶子节点只存放下一层的索引，因此查询效率比较稳定；在大数据量的情况下，树的高度较小，查询性能好；同时还支持排序和范围查找。</li></ul><p>注：InnoDB 的数据是按数据页为单位来读写的，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB。</p><h4 id="索引失效情况" tabindex="-1"><a class="header-anchor" href="#索引失效情况"><span>索引失效情况</span></a></h4><ul><li>使用 SELECT * 进行查询;</li><li>创建了联合索引，但查询条件没有遵循最左匹配原则;</li><li>在索引列上进行计算、函数、(显式/隐式)类型转换等操作(可能破坏索引值的有序性，因此优化器直接放弃使用索引);</li><li>以 % 开头的 LIKE 查询比如 like &#39;%abc&#39;;</li><li>查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;</li></ul><h4 id="索引优化" tabindex="-1"><a class="header-anchor" href="#索引优化"><span>索引优化</span></a></h4><ul><li>在经常用于查询的列上建立索引</li><li>尽量使用覆盖索引（索引覆盖了查询需求），避免回表</li><li>避免索引失效</li><li>索引也不能过多，造成写入性能降低（自增的主键对写入性能影响小，而非自增主键可能引起页分裂导致写性能降低）</li><li>对字符串可以使用前缀索引（如身份证这样的长字符串不适合做主键，索引空间占用过多。但要合理选择前缀的长度，可以根据区分度来选择）</li><li>索引下推优化：在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数（而不是每条记录都回表再判断是否符合条件）</li><li>考虑区分度：区分度指的是索引列中不同值的个数与总记录数之比，用于衡量索引列的区分度。区分度越高，索引效果越好，查询速度越快。</li><li>使用缓存、分库分表、优化硬件和系统</li></ul><h3 id="事务" tabindex="-1"><a class="header-anchor" href="#事务"><span>事务</span></a></h3><h4 id="四个特征" tabindex="-1"><a class="header-anchor" href="#四个特征"><span>四个特征</span></a></h4><ol><li>原子性：事务中包含的操作要么全部执行，要么全部不执行</li><li>一致性：事务执行前后，数据库的完整性没有被破坏，即满足所有的约束条件和业务规则</li><li>隔离性：事务间互不干扰，一个事务的执行不受其他事务的影响，也不影响其他事务。</li><li>持久性：事务一旦提交，其对数据库的修改就会永久保存，即使发生系统故障或崩溃也不会丢失</li></ol><h4 id="并发问题" tabindex="-1"><a class="header-anchor" href="#并发问题"><span>并发问题</span></a></h4><ul><li>脏写：一个事务修改了另一个未提交事务修改过的数据</li><li>脏读：一个事务读到了另一个事务还未提交的数据</li><li>不可重复读：一个事务先后读取同一条记录，期间另一个事务修改了数据，导致第一个事务两次读取的数据不一致</li><li>幻读：一个事务按照某些条件查询，期间另一个事务插入了新的数据，导致第一个事务再次查询时发现多出一些记录</li></ul><h4 id="隔离级别" tabindex="-1"><a class="header-anchor" href="#隔离级别"><span>隔离级别</span></a></h4><ul><li><code>Read_Uncommited</code>: 读未提交，允许读取并发事务尚未提交的数据。可能产生脏读、不可重复读、幻读等问题</li><li><code>Read_Commited</code>: 读已提交，允许读取并发事务已经提交的数据，可以阻止脏读</li><li><code>Repeatable_Read</code>: 可重复读，对同一字段的多次读取结果都一致，可以阻止脏读、不可重复读问题</li><li><code>Serializable</code>: 可串行化，所有事务依次执行，可以阻止所有并发问题。</li></ul><p>MySQL默认是 RR，并且通过 MVVC 机制阻止了幻读问题。</p><h3 id="三大日志" tabindex="-1"><a class="header-anchor" href="#三大日志"><span>三大日志</span></a></h3><p>一个事务的日志操作顺序：加载数据页 -&gt; 写 Undo Log -&gt; 写 Redo Log -&gt; 写 Bin Log -&gt; 提交 Redo Log</p><h4 id="undo-log" tabindex="-1"><a class="header-anchor" href="#undo-log"><span>Undo Log</span></a></h4><p>更新行记录时，首先将数据页加载到 BufferPool，然后将旧值写入 Undo Log，存储事务执行之前的数据版本。作用有二：</p><ul><li>当事务回滚或者发生其他异常时，可以利用 Undo Log 将数据恢复到事务开始之前的状态。</li><li>用于 MVVC，读取记录时判断版本是否对当前事务可见，以此实现非锁定读</li></ul><p>分类：</p><ul><li>insert undo log：insert操作仅对本事务可见，因此在事务提交后可直接删除</li><li>update undo log：update/delete操作，需要提供MVVC，因此分两阶段 delete_mark -&gt; purge</li></ul><h4 id="redo-log" tabindex="-1"><a class="header-anchor" href="#redo-log"><span>Redo Log</span></a></h4><p>执行器更新完 BufferPool 里的数据页后，写入 Redo Log 重做日志，记录事务对数据库所做的修改，保证在发生数据库故障时，可以通过重做日志将数据库恢复到事务提交后的状态。</p><p><strong>原因：</strong><br>数据库按页面从磁盘读取数据加载到 Buffer Pool 中，后续的操作都是对 Buffer Pool 进行，因此需要定时把 Buffer Pool 写回磁盘，但是</p><ul><li>刷新整个页面过于浪费</li><li>写入磁盘是随机IO，速度慢</li></ul><p>因此，MySQL 在事务执行过程中利用 Redo Log，记录修改的具体信息，这样即使系统崩溃也能快速恢复数据，而且：</p><ul><li>占用空间小</li><li>写入是顺序IO，速度快</li></ul><p><strong>刷盘时机：</strong><br>每条 redo 记录由&quot;表空间号+数据页号+偏移量+修改数据长度+具体修改的数据&quot;组成。innodb_flush_log_at_trx_commit参数控制刷盘策略：</p><ul><li>0：事务提交时不立即向磁盘同步redo日志，交给后台线程</li><li>1：默认值，事务提交时立即同步 (fsync)</li><li>2：事务提交时将redo日志写入OS缓冲区，不保证立即刷新到磁盘。这种方式除非DB和OS都挂了，否则是能够保证持久性的</li></ul><p><strong>日志文件组：</strong><br>硬盘上的Redo Log文件有多个，构成一个环形日志文件组，循环写入。<br>日志组维护两个属性，一个 write_pos 是当前记录的位置，一个 checkpoint 是已经刷盘的位置。</p><h4 id="bin-log" tabindex="-1"><a class="header-anchor" href="#bin-log"><span>Bin Log</span></a></h4><p>执行器写完 Redo Log 后，开始写 Bin Log，最后再写 Redo Log 完成两阶段提交。binlog 是一种逻辑日志，记录数据库中所有的修改操作，用于数据备份、主从复制以及数据恢复。</p><p><strong>三种格式：</strong></p><ul><li>statement：记录SQL原文。可能产生数据不一致，例如时间函数now()</li><li>row: 默认。记录SQL原文以及操作的具体数据。占空间，而且消耗IO资源</li><li>mixed：混合前两种，根据是否可能引起数据不一致采用row/statement</li></ul><p><strong>写入时机：</strong><br>事务执行时，先写入 <code>binlog cache</code>，提交时再写入磁盘上的 <code>binlog</code> 文件。<code>sync_binlog</code> 变量控制刷盘时机：</p><ul><li>0：每次提交事务仅 write（写入系统缓存），由OS负责 fsync (写入磁盘)</li><li>1：每次提交任务都 fsync</li><li>N：每次提交任务仅 write，累积 N 个事务后 fsync</li></ul><p><strong>两阶段提交：</strong><br>redo log 让 InnoDB 存储引擎拥有了崩溃恢复能力。binlog 保证了 MySQL 的数据持久性。因此需要确保两份日志的一致性，为此采用两阶段提交机制：</p><ul><li>将 redo log 拆分成 prepare 和 commit 两阶段，事务写入 Redo Log 后就处于 prepare 状态</li><li>事务写入 binlog 后，再将 redo log 设为 commit 状态，最后提交事务</li><li>事务期间如果发生异常 <ul><li>查询 redo log 处于 commit 则直接提交就行</li><li>查询 redo log 处于 prepare，且 redo log 里面的 XID 和 bin log 里面的 XID 一致，说明两份日志逻辑一致，可以直接提交</li><li>否则回滚事务</li></ul></li></ul><p>如果不使用两阶段提交，无论是先写 Redo Log 再写 Bin Log 还是反过来，一旦期间发生崩溃，都会导致用日志恢复出来的数据和原库不一致。</p>',50),i("figure",null,[i("img",{src:hi,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s(`<h3 id="mvvc-机制" tabindex="-1"><a class="header-anchor" href="#mvvc-机制"><span>MVVC 机制</span></a></h3><p>MVVC 基于 Undo Log 实现了非锁定读。</p><ul><li>快照读：也叫非锁定读，读取操作不会去等待行上锁的释放，而是读取行的一个快照数据，根据版本号/时间戳判断可见性</li><li>当前读：也叫锁定读，通过加锁，总是读取数据的最新版本</li></ul><p><strong>行记录的隐藏字段</strong></p><ul><li>row_id: 可选，没有主键/Unique字段的记录，引擎默认生成该隐藏列作为主键</li><li>transaction_id: 最后一次插入或更新该行的事务 id</li><li>roll_pointer: 回滚指针，指向该行的 undo log（构成的版本链）</li></ul><p><strong>ReadView</strong></p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>生成 ReadView 时系统中活跃的读写事务的id列表</td></tr><tr><td>min_trx_id</td><td>生成 ReadView 时系统中活跃的读写事务最小id</td></tr><tr><td>max_trx_id</td><td>生成 ReadView 时系统应分配给下一个事务的id值（最大活跃事务id+1）</td></tr><tr><td>creator_trx_id</td><td>生成该 ReadView 的事务id（仅实际增删改时才分配，只读事务id默认0）</td></tr></tbody></table><p><strong>访问规则</strong><br>有了 ReadView 后，查询过程会顺着版本链遍历，根据ReadView的访问规则，直到找到一条可访问的版本，或不含该记录。其中，trx_id 为被访问版本的 transaction_id 属性值：</p><table><thead><tr><th>条件</th><th>是否可以访问</th><th>说明</th></tr></thead><tbody><tr><td>trx_id == creator_trx_id</td><td>可以访问该版本</td><td>成立，说明数据是当前事务自己更改的</td></tr><tr><td>trx_id &lt; min_trx_id</td><td>可以访问该版本</td><td>成立，说明该版本在当前事务生成 ReadView 前已经提交</td></tr><tr><td>trx_id &gt; max_trx_id</td><td>不可以访问该版本</td><td>成立，说明该版本在当前事务生成 ReadView 后才开启</td></tr><tr><td>min_trx_id &lt;= trx_id &lt;= max_trx_id</td><td>如果trx_id在m_ids中，不可以访问；否则可以访问</td><td>m_ids存在trx_id则说明该事务还是活跃的，不存在则说明该事务已提交</td></tr></tbody></table><p><strong>不同隔离级别</strong></p><ul><li>Read_Uncommited: 读取记录时直接查看最新版本，没有视图概念</li><li>Read_Commited: 事务每次 SELECT 查询前都会生成独立的 ReadView，因此导致不可重复读</li><li>Repeatable_Read: 事务只在第一次 SELECT 查询前生成一个 ReadView，整个事务期间共享该 ReadView，因此可以避免不可重复读的问题</li><li>Seriablizable：加锁来避免并发访问</li></ul><p><strong>RR 防止幻读</strong></p><ul><li>对于 普通的select，RR使用 MVVC 快照读 解决幻读问题</li><li>对于 select...for update/lock in share mode 等当前读，InnoDB使用临键锁对查询范围加锁以防止幻读</li></ul><h3 id="锁机制-1" tabindex="-1"><a class="header-anchor" href="#锁机制-1"><span>锁机制</span></a></h3><p>InnoDB 支持多粒度锁，特定场景下，行级锁可以与表级锁共存。</p><h4 id="全局锁" tabindex="-1"><a class="header-anchor" href="#全局锁"><span>全局锁</span></a></h4><p><code>flush tables with read lock</code> 对整个库加只读锁，常用于全库的逻辑备份。</p><p><code>mysqldump -single-transaction</code> 适用于支持事务的引擎的逻辑备份。</p><h4 id="表级锁" tabindex="-1"><a class="header-anchor" href="#表级锁"><span>表级锁</span></a></h4><p>表级锁对整张表上锁，实现简单粒度粗，因此并发性能差。</p><p><code>lock tables ... read/write</code></p><p>意向锁：一种不与行级锁冲突的表级锁，由引擎维护，无法手动操作的。分：</p><ul><li>意向共享锁 S：事务有意向对表中的某些行加共享锁</li><li>意向排他锁 X：事务有意向对表中的某些行加排他锁</li></ul><p>意向锁不会与行级的共享 / 排他锁互斥。一个事务想要对一个数据行加锁时，会先获取该数据行所在表的意向锁。这样其它事务对表加排他锁时可以直接检测表的意向锁，而不用检测每一行是否有排他锁。</p><h4 id="行级锁" tabindex="-1"><a class="header-anchor" href="#行级锁"><span>行级锁</span></a></h4><p>行级锁对一个行记录上锁，粒度细，并发性能好。</p><p>细分的话，行级锁分三种：</p><ul><li>记录锁，锁定单个行记录</li><li>间隙锁，对索引记录的间隙上锁，确保索引记录间隙不变，防止其他事务在这个间隙插入新记录</li><li>临键锁，是记录锁和间隙锁的组合，同时锁住行记录和记录前面的间隙</li></ul><p>加行锁时，实行两阶段协议：需要时上锁，事务结束 commit 时才释放。因此，一般要把容易产生锁冲突、影响并发度的加锁语句放在后面。默认情况下，InnoDB在查询时使用临键锁来保证数据的一致性和避免幻读问题，不同隔离级别使用的锁不一样。</p><h4 id="加锁语句" tabindex="-1"><a class="header-anchor" href="#加锁语句"><span>加锁语句</span></a></h4><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 快照读，不加锁</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 对满足查询条件的行加上行级写锁</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ... </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> update</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 加共享读锁</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ... LOCK </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">IN</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> SHARE MODE</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ... </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> share</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 加表锁</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">LOCK TABLES</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">UNLOCK</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> TABLES</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="主从同步" tabindex="-1"><a class="header-anchor" href="#主从同步"><span>主从同步</span></a></h3><p>主从同步指多个从服务器实时将主服务器上的数据同步到从服务器上，以实现数据备份、负载均衡、容灾等功能。</p><ol><li>主服务器将更改记录到二进制日志（binlog）中，记录所有更改数据的日志。</li><li>从服务器通过 change master 设置主库的 IP、端口、用户名、密码、日志文件位置等</li><li>从服务器执行 start slave 命令，启动两个线程，一个 I/O 线程，一个 SQL 线程 <ul><li>IO 线程请求主库的 binlog，写入自己的 Relay Log 中继日志中。而主库会生成 Log Dump 线程负责给从库 IO 线程传输 BinLog</li><li>SQL 线程读取 Relay Log，并解析成具体的操作，实现主从操作的一致性，最终数据保持一致</li></ul></li><li><code>show master status;</code> 查看 Master 状态</li><li><code>show slave status</code> 查看 Slave 状态</li></ol>`,34),i("figure",null,[i("img",{src:pi,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s(`<p><strong>主从复制原理</strong></p><ol><li>主库将数据库中数据的变化写入到 binlog</li><li>从库连接主库</li><li>从库创建一个 I/O 线程向主库请求更新的 binlog</li><li>主库创建一个 binlog dump 线程来发送 binlog ，从库中的 I/O 线程负责接收</li><li>从库的 I/O 线程将接收的 binlog 写入到 relay log 中</li><li>从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）。</li></ol><p>但是由于主从同步延迟，可能导致数据不一致的问题，解决方案：</p><ol><li>强制将读请求路由到主库处理：例如 Sharding-JDBC，实现简单但会增加主库压力</li><li>延迟读取</li></ol><p><strong>读写分离</strong></p><p>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上，可以小幅提升写性能，大幅提升读性能。</p><p>通过多台数据库服务器，配置主从复制，然后写请求发给 Master，读请求发给 Slaves。具体实现方法：</p><ol><li>代理方式：例如 MyCat，MySQL Router等</li><li>组件方式：Sharding-JDBC</li></ol><h3 id="分库分表" tabindex="-1"><a class="header-anchor" href="#分库分表"><span>分库分表</span></a></h3><p>分库是将数据库中的数据分散到不同的数据库上，包括：</p><ul><li>垂直分库：把单一数据库按照业务进行划分，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库</li><li>水平分库：把同一张表按一定规则拆分到不同的数据库中，每个库可以位于不同服务器上，实现水平扩展，解决了单表的存储和性能瓶颈的问题。</li></ul><p>分表是对单表的数据进行拆分，包括：</p><ul><li>垂直分表：对数据表列的拆分，把一张列比较多的表拆分为多张表</li><li>水平分表：对数据表行的拆分，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题</li></ul><p>建议使用 ShardingSphere 实现分库分表。</p><p>分片算法：解决数据被水平分片之后，数据该存放在哪个表的问题。</p><ul><li>哈希分片：适合随机读写，不适合经常需要范围查询的场景</li><li>范围分片：按照特性的范围区间分配数据。适合需要经常进行范围查找的场景，不利于随机读写</li><li>地理位置分片</li><li>融合算法</li></ul><p>带来的问题：</p><ul><li>join 操作无法使用，需要手动封装数据</li><li>事务问题</li><li>分布式 ID</li></ul><h3 id="sql-语句" tabindex="-1"><a class="header-anchor" href="#sql-语句"><span>SQL 语句</span></a></h3><h4 id="执行过程" tabindex="-1"><a class="header-anchor" href="#执行过程"><span>执行过程</span></a></h4><ol><li>语法解析：数据库会首先对 SQL 语句进行语法解析，确定查询的语义和执行的操作，如果语法不正确，会直接返回错误信息。</li><li>查询优化：数据库会对 SQL 语句进行查询优化，包括表选择、连接方式、索引使用等等，以找到最优的查询执行计划。</li><li>编译执行计划：优化器找到最优的执行计划后，会将该执行计划编译成可执行的机器码。</li><li>执行查询：数据库引擎开始执行编译后的机器码，按照执行计划从存储引擎中获取数据，并进行筛选、排序、聚合等操作，最终生成结果集。</li><li>返回结果：执行完毕后，数据库将结果集返回给客户端应用程序。</li></ol><p>优化：创建索引、数据分区、避免全表扫描、合理使用缓存</p><h4 id="语法语句" tabindex="-1"><a class="header-anchor" href="#语法语句"><span>语法语句</span></a></h4><p>执行顺序：from -&gt; where -&gt; group by -&gt; having -&gt; select -&gt; order by -&gt; limit (MySQL 中 group by / having 可以使用 select 指定的别名)</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 表清空，并重置自增计数器.</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">truncate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ta_name;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 仅重置自增计数器</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ALTER</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TABLE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tb_name auto_increment</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- count(*) 会统计所有非 null 个数，包括 0</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- sum(if(exp, 1, 0)) 可以排除 0 值求和</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- case 条件语句 </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  CASE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">          when</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> age </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 25</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> then</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;25岁以下&#39;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">          when</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> age </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 25</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> then</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;25岁及以上&#39;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        END</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> as</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> age_cnt, </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(*) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">number</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ...</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- if 条件语句</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) ...</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 日期格式化</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> date_format</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">date</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;%Y-%m&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ...</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> year</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">date</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)/</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">month</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">date</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ...</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 日期增加函数</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> DATE_ADD(orderDate, INTERVAL </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> DAY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ...</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 日期差，以 MINUTE/SECOND/HOUR 等返回</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> TIMESTAMPDIFF(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">MINUTE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, start_time, end_time) ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 取后面一行的 timestamp 列</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> lead</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">timestamp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">over</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  -- 按 trace_id 水平分片</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  parition </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">by</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> trace_id</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  order by</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> timestamp</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">as</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> toTime </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ...;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 截取子串, start 从 1 开始</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> substr(str, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, len) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ...</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 将字符串 str 按 , 分割，选取第n个前的字符</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> substring_index(str, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;,&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ...</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 删除 str 中 前后/前导/尾随 的 &quot;xxx&quot;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> trim</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">( {</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">BOTH</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">/</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">LEADING</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">/</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">TRAILING</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;xxx&quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> str) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ...</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> concat</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(s1, s2, ...) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> xxx;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> upper</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(s)/</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">lower</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(s) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> xxx;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 组内拼接字符串</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> group_concat(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">distinct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> concat_ws(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;:&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">date</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(start_time), tag) SEPARATOR </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;;&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">as</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> detail</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 窗口函数，用于对数据实时分析处理，即本行以及之前的行进行计算</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 如 rank(), dense_rank(), row_number() 以及 聚合函数</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- group by 分组后每个类别聚合成一行，而窗口函数不会减少行数</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">窗口函数</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> over</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">partition</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> by</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">分组列</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> order by</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">排序列</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ...</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 索引</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> [UNIQUE | FULLTEXT]</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> INDEX</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> index_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tb_name(col1, col2);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ALTER</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TABLE</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">表名</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> ADD</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> [UNIQUE | FULLTEXT]</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> [INDEX]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> index_content(content);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">DROP</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> INDEX</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">索引名</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> ON</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">表名</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ALTER</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TABLE</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">表名</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> DROP</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> INDEX</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">索引名</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 重新统计索引信息</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">analyze </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">table</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 重建表，使得索引紧凑，节约存储空间</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">alter</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t engine </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> InnoDB;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">optimize </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">table</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 强制使用索引 a</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">force</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(a) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="count-效率" tabindex="-1"><a class="header-anchor" href="#count-效率"><span>count 效率</span></a></h3><p><code>count(字段) &lt; count(主键id) &lt; count(1) ≈ count(*)</code></p><p>InnoDB 计数时需要先获取所需字段，然后判断是否可能为空，如果不可能为空计数器直接+1，否则还要取出字段判断是否为空再修改计数器，影响性能。因此应尽量使用 count(*)。</p><h2 id="redis" tabindex="-1"><a class="header-anchor" href="#redis"><span>Redis</span></a></h2><h3 id="数据结构-1" tabindex="-1"><a class="header-anchor" href="#数据结构-1"><span>数据结构</span></a></h3><ul><li>5 种基本数据结构： <ul><li>String 字符串：基于 SDS 简单动态字符串的结构，记录了当前长度，修改时可以根据字符串长度动态扩展</li><li>List 列表：基于双向链表的实现</li><li>Hash 散列：基于压缩列表或哈希字典，是一个 String 类型键值对的映射表</li><li>Set 集合：基于压缩列表或整数集合实现的无序集合，其中的的元素没有先后顺序但都唯一，底层用哈希表实现</li><li>Zset 有序集合：基于压缩列表或跳表，相比于 Set，Zset 增加了一个分数 score，使得集合中元素可以按分值进行有序排列</li></ul></li><li>3 种特殊数据结构： <ul><li>HyperLogLogs 基数统计</li><li>Bitmap 位存储：连续的二进制位，每个bit表示某个元素的对应值或状态</li><li>Geospatial 地理位置</li></ul></li></ul><h3 id="速度快的原因" tabindex="-1"><a class="header-anchor" href="#速度快的原因"><span>速度快的原因</span></a></h3><ol><li>内存存储：In-Memory 存储，没有磁盘 IO 开销</li><li>单线程模型：使用单个线程处理请求，避免了多个线程之间切换和锁资源的开销</li><li>非阻塞IO：Redis 使用基于 epoll 多路复用技术，提高了网络 IO 的性能</li><li>优化的数据结构</li><li>底层模型：Redis 自己构建了 VM 虚拟内存机制（冷热数据分离）</li></ol><p>另外，Redis 的事务模型主要关注原子性和隔离性，而不提供传统数据库的一致性（在一个 MULTI/EXEC 事务块中发生错误可能产生不一致）和持久性（依赖持久化机制）。</p><h3 id="线程模型" tabindex="-1"><a class="header-anchor" href="#线程模型"><span>线程模型</span></a></h3><p>Redis 服务器是基于 Reactor 模式的单线程事件驱动程序，处理文件事件和时间事件。</p><ul><li>时间事件：定时/周期性操作，目前是只有serverCron一个时间函数</li><li>文件事件：Redis 通过 IO 多路复用程序 来监听多个socket，每当一个socket准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件。然后文件事件分派器会接收I/O多路复用程序传来的套接字，并根据套接字产生的事件的类型调用相应的事件处理器，也就是与不同任务的套接字关联的一个个函数。</li></ul><p>Redis 6 引入了多线程模型，但是仅用于网络数据的读写这类耗时操作上，来提高网络IO的读写性能，执行命令仍然是单线程顺序执行。</p><h3 id="过期删除策略" tabindex="-1"><a class="header-anchor" href="#过期删除策略"><span>过期删除策略</span></a></h3><ul><li>惰性删除 ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li><li>定期删除 ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li></ul><p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 定期删除+惰性删除 结合的方式，在一定时间内分多次遍历服务器中的各个数据库，从expires字典中随机检查一部分键的过期时间，并删除过期键。</p><h3 id="缓存淘汰机制" tabindex="-1"><a class="header-anchor" href="#缓存淘汰机制"><span>缓存淘汰机制</span></a></h3><ol><li>volatile-lru（least recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol><p>4.0 版本后增加以下两种：</p><ul><li>volatile-lfu（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li><li>allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li></ul><h3 id="持久化机制" tabindex="-1"><a class="header-anchor" href="#持久化机制"><span>持久化机制</span></a></h3><h4 id="rdb-快照" tabindex="-1"><a class="header-anchor" href="#rdb-快照"><span>RDB - 快照</span></a></h4><p>将某一时刻的内存数据，以二进制的方式写入磁盘。可以将快照复制到其他服务器从而创建具有相同数据的服务器副本，也可以将快照留在原地以便重启服务器的时候使用。</p><p>两种命令：</p><ul><li>save 命令：主线程执行，会阻塞主线程；</li><li>bgsave : 子线程执行，不会阻塞主线程，默认选项。</li></ul><p>RDB 默认的保存文件为 dump.rdb，优点是以二进制存储的，因此占用的空间更小、数据存储更紧凑，与 AOF 相比，RDB 具备更快的重启恢复能力。但是有数据丢失的风险。</p><h4 id="aof-仅追加文件" tabindex="-1"><a class="header-anchor" href="#aof-仅追加文件"><span>AOF - 仅追加文件</span></a></h4><p>指将所有的操作命令，以文本的形式追加到文件中。appendfsync 决定何时写入磁盘，appendfsync 选项值：</p><ul><li>always：每次有数据修改发生时都会写入AOF文件。效率最慢，安全性最高</li><li>everysec：默认，每秒钟同步一次，显式地将多个写命令同步到硬盘。效率适中</li><li>no：由 OS 决定何时进行同步。效率最高安全性最差</li></ul><p>AOF重写：<br>为了避免大量写命令造成AOF文件体积过大，以及还原时间过长，需要用 BGREWRITEAOF 命令，通过读取数据库中的键值对，对AOF文件重写。在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p><p>优点是存储频率更高，因此丢失数据的风险就越低，并且 AOF 并不是以二进制存储的，所以它的存储信息更易懂。缺点是占用空间大，重启之后的数据恢复速度比较慢。</p><h3 id="缓存三大问题" tabindex="-1"><a class="header-anchor" href="#缓存三大问题"><span>缓存三大问题</span></a></h3><h4 id="缓存穿透" tabindex="-1"><a class="header-anchor" href="#缓存穿透"><span>缓存穿透</span></a></h4><p>大量请求的 key 不合理，既不存在于缓存，也不存在于数据库 。导致这些请求直接到达数据库服务器，根本不经过缓存这一层，从而对数据库造成了巨大的压力。</p><p><strong>解决方法：</strong></p><ul><li>接口层进行校验，如用户鉴权，id 做基础校验，id 不合法的直接拦截</li><li>缓存中设置无效的 key，例如 <code>set &lt;key&gt; nullObject</code></li><li>布隆过滤器（多个 hash 函数，key 对应的 hashCode 都存在，该元素才可能存在）</li></ul><h4 id="缓存击穿" tabindex="-1"><a class="header-anchor" href="#缓存击穿"><span>缓存击穿</span></a></h4><p>请求的 key 对应的是热点数据 ，该数据存在于数据库中，但可能由于缓存过期，不存在于缓存中。进而导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力。</p><p><strong>解决方法：</strong></p><ul><li>针对热点数据提前预热，设置热点数据永不过期</li><li>通过分布式锁，保证只有第一个请求会落到数据库上，并将数据存入缓存。后续的请求可以直接从缓存中取数据，减少数据库的压力</li><li>接口限流、熔断、降级</li></ul><h4 id="缓存雪崩" tabindex="-1"><a class="header-anchor" href="#缓存雪崩"><span>缓存雪崩</span></a></h4><p>缓存在同一时间大面积的失效，或缓存服务器宕机，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</p><p><strong>解决方法：</strong></p><ul><li>搭建高可用的 Redis 集群，避免单点故障（主从、哨兵、集群）</li><li>设置不同的失效时间，防止同一时间大量 key 失效。例如随机设置过期时间。</li></ul><h3 id="分布式锁" tabindex="-1"><a class="header-anchor" href="#分布式锁"><span>分布式锁</span></a></h3><p>原理：基于 Redis（单线程）的原子操作 <code>set &lt;key&gt; &lt;random_value&gt; NX EX 30</code>，仅当 key 不存在时才会设置成功，否则返回 nil。</p><p>优化：</p><ol><li>防止解锁失败（掉线/宕机）造成程序死锁，key 必须设置过期时间。且和加锁应是原子的</li><li>为了防止锁过期后解锁操作误删了其它线程加的锁，因此可以给 value 设为该线程唯一的 UUID，解锁时先获取锁的值，和自己的 UUID 相等才删除。</li><li>为了防止网络请求的延迟，造成误删其它线程加的锁，获取 value 进行对比和 删除 key 必须是原子的，可以使用 Lua 脚本实现。</li><li>为了防止业务还未完成锁已经过期释放了，需要对锁进行自动续期，或直接设置一个很长的过期时间，例如业务中可以设 300s</li></ol><h3 id="缓存一致性问题" tabindex="-1"><a class="header-anchor" href="#缓存一致性问题"><span>缓存一致性问题</span></a></h3><p>指缓存与数据库的一致性问题，一般不要求强一致性，都是追求最终一致性。</p><h4 id="更新数据库-删除缓存" tabindex="-1"><a class="header-anchor" href="#更新数据库-删除缓存"><span>更新数据库 -&gt; 删除缓存</span></a></h4><ul><li>并发时可能有暂时的脏数据</li><li>解决方法： <ul><li>重试机制，例如配合 MQ/Canal</li><li>加分布式锁，原子地更新数据库和缓存。但是存在缓存资源浪费、性能降低的问题</li></ul></li></ul><h4 id="删除缓存-更新数据库" tabindex="-1"><a class="header-anchor" href="#删除缓存-更新数据库"><span>删除缓存 -&gt; 更新数据库</span></a></h4><ul><li>并发时依然有不一致的问题（A删除缓存，B查缓存不存在取数据库，然后又把旧数据存入缓存）</li><li>解决方法：延迟双删，即删除缓存后更新数据库，然后等一段时间再删除缓存。但延迟时间很难评估</li></ul><h4 id="设计思路" tabindex="-1"><a class="header-anchor" href="#设计思路"><span>设计思路</span></a></h4><ul><li>缓存数据不应该是实时性、一致性要求超高的，所以缓存 + 过期时间，足够解决大部分业务对于缓存的要求</li><li>性能和一致性不能同时满足，为了性能考虑，通常会采用「最终一致性」的方案</li><li>遇到实时性、一致性要求高的数据，即使速度慢点，也应该查数据库</li><li>我们不应该过度设计，增加系统的复杂性</li></ul><h3 id="高可用模式" tabindex="-1"><a class="header-anchor" href="#高可用模式"><span>高可用模式</span></a></h3><h4 id="主从复制" tabindex="-1"><a class="header-anchor" href="#主从复制"><span>主从复制</span></a></h4><ul><li>将一个 Redis 实例作为主节点，多个 Redis 实例作为从节点，主节点将自己的数据同步到从节点。（数据的完整副本）</li><li>从节点可以提供读取服务，实现读写分离。</li><li>当主节点宕机时，可以在从节点中选举出一个新的主节点来保证服务的可用性。</li><li>优点是部署简单，并且由于保存了数据的完整副本，因此降低了数据丢失的风险。</li><li>缺点是主节点宕机后，需要人工介入手动恢复，造成服务的不可用</li></ul><h4 id="哨兵模式" tabindex="-1"><a class="header-anchor" href="#哨兵模式"><span>哨兵模式</span></a></h4><ul><li>Sentinel 是一个专门用于监控 Redis 实例的工具，通过 PING 自动检测 Redis 实例的状态，自动进行故障转移，选举新的主节点，保证服务的可用性。</li><li>优点是实现了自动故障转移，无需人工干预</li><li>缺点是在发生故障转移时可能会出现数据丢失的情况。</li></ul><h4 id="集群模式" tabindex="-1"><a class="header-anchor" href="#集群模式"><span>集群模式</span></a></h4><ul><li>将数据分散到多个节点上进行存储和管理，降低系统对单主节点的依赖，并且大大提高 Redis 服务的读写性能</li><li>除了主从和哨兵的功能外，集群模式下不同的 key 放到不同的 Redis 中，每个 Redis 实例负责一部分的槽，可以实现数据分片。</li><li>优点是可以水平扩展，提高了并发读写的能力</li><li>缺点是配置较为复杂。</li></ul><h2 id="spring" tabindex="-1"><a class="header-anchor" href="#spring"><span>Spring</span></a></h2><h3 id="ioc-1" tabindex="-1"><a class="header-anchor" href="#ioc-1"><span>IoC</span></a></h3><h4 id="ioc-理解" tabindex="-1"><a class="header-anchor" href="#ioc-理解"><span>IoC 理解</span></a></h4><p>IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理，由 Spring 容器（本质上就是个Map）完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。</p><h4 id="声明-bean" tabindex="-1"><a class="header-anchor" href="#声明-bean"><span>声明 Bean</span></a></h4><ul><li><code>@Component</code>：通用的注解，可标注任意类为 Spring 组件。通过类路径扫描来自动侦测以及自动装配到 Spring 容器中</li><li><code>@Repository</code>: 对应持久层，主要用于数据库相关操作。</li><li><code>@Service</code>: 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li><code>@Controller</code>: 对应控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面</li><li><code>@Bean</code>: 作用于方法上，表示方法返回的实例装配到Spring容器中。常用于第三方库的类装配</li><li><code>@Configuration</code>：声明配置类</li></ul><p>框架启动时，Spring 通过扫描各种注解，把需要交给 Spring 管理的 Bean 初始化为 BeanDefinition 的列表，进而创建 Bean 的实例。</p><h4 id="注入-bean" tabindex="-1"><a class="header-anchor" href="#注入-bean"><span>注入 Bean</span></a></h4><ul><li><code>@Autowired</code>: Spring 内置注解 <ul><li>默认 byType，根据接口类型去匹配注入接口实现类</li><li>当一个接口存在多个实现类，转为 byName，即变量名和类名匹配</li><li>建议<code>@Qualifier(value = &quot;serviceImpl1&quot;)</code>显式指定名称</li></ul></li><li><code>@Resource</code>：JDK 提供的注解 <ul><li>默认 byName，否则 byType</li><li>建议通过 name 属性显式指定名称</li></ul></li><li><code>@Inject</code> 基本不用</li></ul><h4 id="bean-作用域" tabindex="-1"><a class="header-anchor" href="#bean-作用域"><span>Bean 作用域</span></a></h4><ul><li>singleton：默认，容器中只有唯一实例。</li><li>prototype: 每次获取都会创建一个新实例。</li><li>request(Web)：每一次 HTTP 请求都会产生一个新实例，且仅在当前 HTTP 请求内有效。</li><li>session(Web)：每一次来自新 session 的 HTTP 请求都会产生一个新实例，且仅在当前 session 内有效。</li><li>application/global-session(Web)：每个 Web 应用在启动时创建一个实例，且仅在当前应用启动时间内有效。</li><li>websocket(Web)：每一次 WebSocket 会话产生一个新实例</li></ul><h4 id="bean-生命周期-1" tabindex="-1"><a class="header-anchor" href="#bean-生命周期-1"><span>Bean 生命周期</span></a></h4><ol><li>实例化：通过反射或者工厂方法创建 Bean 对象。</li><li>属性注入：通过配置文件或者注解给 Bean 对象的属性赋值。</li><li>初始化：调用 Bean 对象的初始化方法，比如 <code>@PostConstruct</code>注解的方法，或者实现了<code>InitializingBean</code>接口的<code>afterPropertiesSet</code>方法，或者配置文件中指定的<code>init-method</code>方法。</li><li>销毁：调用 Bean 对象的销毁方法，比如<code>@PreDestroy</code>注解的方法，或者实现了<code>DisposableBean</code>接口的<code>destroy</code>方法，或者配置文件中指定的<code>destroy-method</code>方法。</li></ol><p>其它扩展点：BeanPostProcessor, BeanFactoryPostProcessor, InstantiationAwareBeanPostProcessor, SmartInstantiationAwareBeanPostProcessor...</p>`,102),i("figure",null,[i("img",{src:ki,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s('<h4 id="自动装配" tabindex="-1"><a class="header-anchor" href="#自动装配"><span>自动装配</span></a></h4><p>Spring 的自动装配通过注解或者一些简单的配置就能在 Spring Boot 的帮助下自动导入一些Bean来实现某些功能。</p><ol><li>整个SpringBoot项目的启动类都是添加<code>@SpringBootApplication</code>注解的，这个注解主要包括三个子注解: <ul><li>@SpringBootConfiguration 表示当前是个配置类</li><li><a href="/ComponentScan">@ComponentScan </a> 包扫描(并且可以排除一些包/类)</li><li>@EnableAutoConfiguration 自动装配的关键注解</li></ul></li><li>@EnableAutoConfiguration 分两部分： <ul><li>@AutoConfigurationPackage 里面是 <a href="/Import">@Import </a> 注解导入了一个 Registrar 类，负责扫描主启动类包及其子包的组件并加载到 Spring 容器中</li><li>另一个 <a href="/Import">@Import </a> 导入了 AutoConfigurationImportSelector 类，这个类实现了 ImportSelector 接口，实现了 selectImports 方法，用于获取所有符合条件的类的全限定类名，并加载到容器中</li></ul></li><li>selectImports 方法首先会判断是否开启了自动装配，如果开启的话继续。</li><li>接着调用 SpringFactoriesLoader::loadMetaData 扫描所有依赖项目的 META-INF 目录下的 spring.factories 文件里，定义的 Key 为 EnableAutoConfiguration 的类的全类名，也就是所有需要装配的 Bean</li><li>然后调用 getAutoConfigurationEntry 来加载这些 Bean，具体的： <ul><li>判断自动装配是否开启</li><li>获取 EnableAutoConfiguration 注解中的 exclude 和 excludeName 做一个过滤并且去重，然后返回一个需要加载的 Bean 的结果集</li><li>然后根据 Bean 上添加的 Conditional 条件注解再做一次过滤</li></ul></li><li>最后就可以把这些剩下的 Bean 装入容器了</li></ol><h4 id="解决循环依赖" tabindex="-1"><a class="header-anchor" href="#解决循环依赖"><span>解决循环依赖</span></a></h4><p>循环依赖就是循环引用，指两个或多个bean互相持有对方，形成一个闭环。分：</p><ul><li>构造器循环依赖：无法解决</li><li>Setter 循环依赖： <ul><li>对于 Singleton 的 Bean，可以提前暴露一个单例工厂方法，使得其它Bean能够引用到（去掉本身的 @Bean）</li><li>对于 Prototype 的 Bean，无法解决。spring容器不缓存prototype作用域的bean，因此无法提前暴露一个正在创建中的bean。</li></ul></li></ul><p><strong>原理</strong></p><p>Spring 通过三级缓存解决循环依赖：</p><ul><li>一级缓存：单例池，限制 bean 在 beanFactory 中仅存一份<br><code>private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);</code></li><li>二级缓存：早期曝光对象<br><code>private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16);</code></li><li>三级缓存：早期曝光对象工厂<br><code>private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);</code></li></ul>',9),i("figure",null,[i("img",{src:ri,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s('<p>当 A、B 两个类发生循环引用时，在 A 完成实例化后，就使用实例化后的对象去创建一个对象工厂，并添加到三级缓存中，如果 A 被 AOP 代理，那么通过这个工厂获取到的就是A代理后的对象，如果 A 没有被 AOP 代理，那么这个工厂获取到的就是 A 实例化的对象。当 A 进行属性注入时，会去创建 B，同时 B 又依赖了 A，所以创建 B 的同时又会去调用getBean(a) 来获取需要的依赖，此时的 getBean(a) 会从缓存中获取。</p><ul><li>首先从一级缓存中获取，但 A 没有填充和初始化完成，因此不存在一级缓存中；接着去二级缓存获取，也不存在；最后去三级缓存获取，可以获取到。</li><li>第二步，调用对象工厂的getObject方法来获取到对应的对象，得到这个对象后将其注入到B中。</li><li>紧接着B会走完它的生命周期流程，包括初始化、后置处理器等。当B创建完后，会将B再注入到A中，此时A再完成它的整个生命周期。<br>至此，循环依赖结束！</li></ul><p><strong>为什么不用二级缓存？</strong></p><p>如果要使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理，这样违背了Spring设计的原则，Spring在设计之初就是通过AnnotationAwareAspectJAutoProxyCreator这个后置处理器来在Bean生命周期的最后一步来完成AOP代理，而不是在实例化后就立马进行AOP代理。</p><h3 id="aop-1" tabindex="-1"><a class="header-anchor" href="#aop-1"><span>AOP</span></a></h3><h4 id="aop-理解" tabindex="-1"><a class="header-anchor" href="#aop-理解"><span>AOP 理解</span></a></h4><p>Spring AOP 就是基于动态代理(如果实现了接口使用基于实现的JDK Proxy，否则使用基于继承的CGLib代理)，能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，有利于未来的可拓展性和可维护性。</p><h4 id="通知类型" tabindex="-1"><a class="header-anchor" href="#通知类型"><span>通知类型</span></a></h4><p>Around::before -&gt; Before -&gt; target::proceed -&gt; Around::after -&gt; AfterReturning / AfterThrowing -&gt; After</p><h3 id="mvc" tabindex="-1"><a class="header-anchor" href="#mvc"><span>MVC</span></a></h3><h4 id="mvc-理解" tabindex="-1"><a class="header-anchor" href="#mvc-理解"><span>MVC 理解</span></a></h4><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><p>Spring MVC 下我们一般把后端项目分为：</p><ul><li>Entity层：实体类</li><li>Dao层：操作数据库</li><li>Service层：处理业务</li><li>Controller层：返回数据给前台页面</li></ul><h4 id="核心组件和原理" tabindex="-1"><a class="header-anchor" href="#核心组件和原理"><span>核心组件和原理</span></a></h4><ul><li><code>DispatcherServlet</code>：核心的中央处理器，负责接收请求、分发，并给予客户端响应。</li><li><code>HandlerMapping</code>：处理器映射器，根据 uri 去匹配查找能处理的 Handler ，并会将请求涉及到的拦截器和 Handler 一起封装。</li><li><code>HandlerAdapter</code>：处理器适配器，根据 HandlerMapping 找到的 Handler ，适配执行对应的 Handler；</li><li><code>Handler</code>：请求处理器，处理实际请求的处理器。</li><li><code>ViewResolver</code>：视图解析器，根据 Handler 返回的逻辑视图/视图，解析并渲染真正的视图，传递给 DispatcherServlet 响应客户端</li></ul>',16),i("figure",null,[i("img",{src:di,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s(`<h3 id="其它-1" tabindex="-1"><a class="header-anchor" href="#其它-1"><span>其它</span></a></h3><h4 id="spring-启动流程" tabindex="-1"><a class="header-anchor" href="#spring-启动流程"><span>Spring 启动流程</span></a></h4><ol><li>首先从main找到run()方法，在执行run()方法之前new一个SpringApplication对象</li><li>进入run()方法，创建应用监听器SpringApplicationRunListeners开始监听</li><li>然后加载SpringBoot配置环境(ConfigurableEnvironment)，然后把配置环境(Environment)加入监听对象中</li><li>然后加载应用上下文(ConfigurableApplicationContext)，当做run方法的返回对象</li><li>最后创建Spring容器，refreshContext(context)，实现starter自动化配置和bean的实例化等工作。</li></ol><h4 id="常用注解" tabindex="-1"><a class="header-anchor" href="#常用注解"><span>常用注解</span></a></h4><ol><li>@SpringBootApplication: 启动类，是@SpringBootConfiguration, @EnalbeAutoConfiguration, @ComponentScan三个注解的集合</li><li>@Autowired：自动装配，被注入的类要被Spring容器管理</li><li>@Compoent, @Repository, @Service, @Controller：声明 Bean</li><li>@RestController: <a href="/Controller">@Controller </a> + <a href="/ResponseBody">@ResponseBody </a> 的集合，REST风格的控制器，将函数的返回值直接写入HTTP响应体</li><li><a href="/Scope">@Scope </a> 声明作用域</li><li><a href="/Configuration">@Configuration </a> 声明配置类</li><li><a href="/GetMapping">@GetMapping </a> 获取资源，<a href="/PostMapping">@PostMapping </a> 创建新资源，<a href="/PutMapping">@PutMapping </a> 更新资源，<a href="/DeleteMapping">@DeleteMapping </a> 删除资源</li><li><a href="/PathVariable">@PathVariable </a> 获取路径参数，<a href="/RequestParam">@RequestParam </a> 获取查询参数，<a href="/RequestBody">@RequestBody </a> 获取请求体参数并自动绑定到Java对象（利用HttpMessageConverter，且一个请求方法中仅能有一个）</li><li>@Value(&quot;\${...}&quot;) 读取简单配置信息，[@ConfigurationProperties(prefix ](/ConfigurationProperties(prefix ) = &quot;...&quot;) 读取配置并绑定到 Bean， @PropertySource(&quot;xxx&quot;) 读取指定配置文件</li><li>参数校验：<a href="/Validate">@Validate </a> 加在Controller上开启校验，具体规则有 @NotEmpty, @NotBlank, @Pattern, @Max, <a href="/Size...">@Size... </a> (加在 Entity 实体类的属性上)</li><li>全局异常：<a href="/ControllerAdvice">@ControllerAdvice </a> 定义全局异常处理类，<a href="/ExceptionHandler">@ExceptionHandler </a> 声明异常处理方法</li><li>JPA 相关：<a href="/Entity">@Entity </a> 实体类，<a href="/Table">@Table </a> 表名， @Id 声明主键，<a href="/GeneratedValue">@GeneratedValue </a> 主键生成策略， <a href="/Column">@Column </a> 声明字段， <a href="/Transient">@Transient </a> 声明不持久化字段（或用static/final修饰），<a href="/Lob">@Lob </a> 大字段，<a href="/Enumerated">@Enumerated </a> 枚举类型字段，@<a href="/EnableJpaAuditing">@EnableJpaAuditing </a> 开启JPA审计，<a href="/Transactional">@Transactional </a> 开启事务</li><li>Json数据处理：<a href="/JsonIgnoreProperties">@JsonIgnoreProperties </a> 过滤特定字段不返回/不解析，<a href="/JsonFormat">@JsonFormat </a> 格式化Json数据，<a href="/JsonUnwrapped">@JsonUnwrapped </a> 扁平化对象</li><li>测试相关：<a href="/ActiveProfiles">@ActiveProfiles </a> 声明生效的Spring配置文件，<a href="/Test">@Test </a> 测试方法，<a href="/WithMockUser">@WithMockUser </a> 模拟真实用户和权限</li></ol><h4 id="springboot-优势" tabindex="-1"><a class="header-anchor" href="#springboot-优势"><span>SpringBoot 优势</span></a></h4><ul><li>SpringBoot 依靠大量注解实现自动化配置，只需要添加相应的场景依赖，就可以快速构建出一个独立的 Spring 应用</li><li>通过自动 starter 依赖，简化了构建配置</li><li>内嵌服务器使得应用程序可以直接运行，不需要单独部署</li><li>SpringBoot 整合了大量第三方功能，并提供了默认配置，例如 mybatis、redis等，实现开箱即用</li><li>SpringBoot 提供了一些用于生产环境运行时的特性，例如指标、监控检查和外部化配置。</li></ul><h4 id="springboot-缺点" tabindex="-1"><a class="header-anchor" href="#springboot-缺点"><span>SpringBoot 缺点</span></a></h4><ul><li>缺少灵活性，有时需要在项目中扩展一些功能就需要手动配置</li><li>集成度较高，使用过程中不太容易了解底层；</li><li>难以适应较为复杂的场景，一旦项目变得复杂，就需要考虑功能的划分和更加细致的配置</li></ul><h4 id="事务传播行为" tabindex="-1"><a class="header-anchor" href="#事务传播行为"><span>事务传播行为</span></a></h4><p>Spring 管理事务有两种方式：编程式（手动硬编码）、声明式（基于<code>@Transactional</code>的AOP）</p><ul><li><code>Propagation_Required</code>: <a href="/Transactional">@Transactional </a> 默认模式，如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li><li><code>Propagation_Requires_New</code>: 总是创建新事务，如果当前存在事务则挂起。开启的事务相互独立，互不干扰</li><li><code>Propagation_Nested</code>: 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；否则新建事务</li><li><code>Propagation_Mandatory</code>: 如果当前存在事务就加入；否则抛出异常</li></ul><p>另外还有三种可能不回滚的事务：</p><ul><li><code>Propagation_Supports</code>: 如果当前存在事务就加入；否则以非事务的方式继续运行</li><li><code>Propagation_Not_Supported</code>: 以非事务方式运行，如果当前存在事务则把当前事务挂起</li><li><code>Propagation_Never</code>: 以非事务方式运行，如果当前存在事务则抛出异常</li></ul><h4 id="事务隔离级别" tabindex="-1"><a class="header-anchor" href="#事务隔离级别"><span>事务隔离级别</span></a></h4><ul><li><code>Isolation_Default</code>: 使用后端数据库默认的隔离级别，例如 MySQL 默认 REPEATABLE_READ</li><li><code>Isolation_Read_Uncommited</code>: 最低级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li><li><code>Isolation_Read_Commited</code>: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li><li><code>Isolation_Repeatable_Read</code>: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><code>Isolation_Serializable</code>: 最高级别，完全服从 ACID，所有事务依次执行，可以防止脏读、不可重复读、幻读等问题，当严重影响性能。</li></ul><h4 id="spring-cache" tabindex="-1"><a class="header-anchor" href="#spring-cache"><span>Spring Cache</span></a></h4><p>Spring 支持多种缓存的实现方式，例如 SimpleCache(ConcurrentMap实现), RedisCache, EhCache, CaffeineCache... 有两个核心接口：</p><ul><li><code>org.springframework.cache.Cache</code>：用于定义缓存的各种操作</li><li><code>org.springframework.cache.CacheManager</code>：用于管理各个cache缓存组件</li></ul><p><strong>原理</strong></p><ul><li>缓存的自动配置类 CacheAutoConfiguration 向容器中导入了 CacheConfigurationImportSelector</li><li>CacheConfigurationImportSelector 的 selectImports() 导入所有缓存类型的配置类，默认启用 SimpleCacheConfiguration</li><li>SimpleCacheConfiguration 配置类向容器中注入了一个 ConcurrentMapCacheManager 实例</li><li>ConcurrentMapCacheManager 底层创建一个 ConcurrentMapCache 管理缓存</li></ul><p><strong>缓存注解</strong></p><ul><li><code>@EnableCaching</code>：用于 SpringBoot 的启动类开启注解功能</li><li><code>@CacheConfig</code>：用于对类进行配置，对整个类的缓存进行配置，可用 <a href="/Cacheable">@Cacheable </a> 取代</li><li><code>@Cacheable</code>：通常用于配置方法，将方法的返回结果注入到缓存对象中 <ul><li>value/cacheNames: 指定缓存名（跟在 key-prefix 后面）</li><li>key/keyGenerator：指定缓存对应的 key 值，默认使用方法参数生成，可以使用 spel 指定</li><li>condition/unless: 条件缓存</li><li>sync：默认 false，为 true 时开启同步锁</li></ul></li><li><code>@CacheEvict</code>：可用于类或方法，用于清空缓存 <ul><li>allEntries: true 表示删除域名下所有缓存</li></ul></li><li><code>@CachePut</code>：强制执行方法并将返回结果放入缓存，常用于更新 DB 的方法 <ul><li>属性同 <a href="/Cacheable">@Cacheable </a></li></ul></li><li><code>@Caching</code>: <a href="/Cacheable">@Cacheable </a> + <a href="/CachePut">@CachePut </a> + <a href="/CacheEvict">@CacheEvict </a></li></ul><p><strong>缺陷</strong></p><ul><li>读缓存： <ul><li>缓存穿透：spring.cache.redis.cache-null-values 指定是否缓存空数据</li><li>缓存击穿：默认是无加锁的，可以置 Cacheable 的 sync 为 true</li><li>缓存雪崩：可以设置随机时间</li></ul></li><li>写缓存： <ul><li>读写加锁</li><li>引入 Canal</li><li>读多写多的场景，可以直接查 DB</li></ul></li></ul><p>总结：</p><ul><li>常规数据（读多写少，即时性，一致性要求不高的数据，完全可以使用 Spring-Cache</li><li>写模式(只要缓存的数据有过期时间就足够了)</li><li>特殊数据进行特殊设计</li></ul><h4 id="spring-单例并发问题" tabindex="-1"><a class="header-anchor" href="#spring-单例并发问题"><span>Spring 单例并发问题</span></a></h4><p>Spring 中的 Bean 默认都是单例的，Spring也没有对 Bean 有线程安全的控制策略，并发安全问题由开发决定。单例 Bean 的并发安全取决于 Bean 是有状态还是无状态，即是否有数据存储功能，例如 User 里面存储了用户数据。因此不应把有状态的 Bean 定义成单例 Bean。要么使用 prototype 作用域，要么使用本地变量 ThreadLocal。</p><h4 id="jpa-取消持久化" tabindex="-1"><a class="header-anchor" href="#jpa-取消持久化"><span>JPA 取消持久化</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> transient1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">           // not persistent because of static</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">final</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> transient2 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Satish&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // not persistent because of final</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">transient</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> transient3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // not persistent because of transient</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Transient</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> transient4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                  // not persistent because of @Transient</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="分布式" tabindex="-1"><a class="header-anchor" href="#分布式"><span>分布式</span></a></h2><h4 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h4><ul><li>分布式：把整个系统拆分成不同的服务，部署在不同的服务器/集群上减轻单体服务的压力，提高并发量和性能，提高开发效率，便于维护和扩展。</li><li>注册中心：负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互。</li><li>监控中心：负责统计各服务调用次数，调用时间等。</li><li>负载均衡：改善跨多个计算资源的工作负载分布，来优化资源使用，最大化吞吐量，最小化响应时间，并避免任何单个资源的过载。</li></ul><h4 id="cap-和-base" tabindex="-1"><a class="header-anchor" href="#cap-和-base"><span>CAP 和 BASE</span></a></h4><p><strong>CAP 理论</strong></p><p>对于一个分布式系统，在满足 P 的前提下，只能满足 AP（如ZooKeeper）或 CP（Eureka）：</p><ul><li>Consistency: 一致性，所有节点访问同一份最新的数据副本</li><li>Availability：可用性，非故障的节点在合理的时间内返回合理的响应</li><li>Partition Tolerance：分区容错性，出现网络分区时仍能对外提供服务</li></ul><p>原因：若系统出现分区，系统中的某个节点在进行写操作。为了保证 C 一致性， 必须要禁止其他节点的读写操作，这就和 A 可用性发生冲突了。如果为了保证 A 可用性，其他节点的读写操作正常的话，那就和 C 一致性发生冲突了。如果不需要保证 P，即网络分区正常，那么 C 一致性和 A 可用性可以同时保证。</p><p><strong>BASE 理论</strong></p><p>BASE 理论核心思想是：即使无法做到强一致性，也应采用适当的方式来使系统达到最终一致性。</p><ul><li>Basically-Available: 基本可用，系统在出现不可预知故障的时候，允许损失部分可用性（响应时间上的损失/系统功能上的损失）</li><li>Soft-state：软状态，允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性（允许不同节点的副本同步过程存在延迟）</li><li>Eventually-Consistent：最终一致性，系统中所有的数据副本经过一段时间的同步后，最终达到一致。</li></ul><p>BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p><h4 id="paxos" tabindex="-1"><a class="header-anchor" href="#paxos"><span>Paxos</span></a></h4><p>共识算法：通过保持复制日志的一致性，即使面对故障，服务器也可以在共享状态上达成一致。</p><p>Paxos 算法是第一个被证明完备的分布式系统共识算法。共识算法的作用是让分布式系统中的多个节点之间对某个提案（Proposal）达成一致的看法。例如哪个节点是 Leader、多个事件发生的顺序等。</p><p>Paxos 主要包含两个部分：</p><p><strong>1. Basic Paxos</strong></p><p>多节点间如何就某个值（提案）达成共识</p><ul><li>Proposer：也称 Coordinator，负责接受客户端的请求并发起提案（提案编号、提议值）</li><li>Acceptor：也称 Voter，负责对提议者的提案进行投票，同时需要记住自己的投票历史</li><li>Learner：如果有超过半数接受者就某个提议达成了共识，那么学习者就需要接受这个提议，并就该提议作出运算，然后将运算结果返回给客户端。</li></ul><p><strong>2. Multi Paxos</strong></p><p>一种思想，通过执行多个 Basic Paxos，就一系列值达成共识。</p><p>针对存在恶意节点的情况（拜占庭问题），一般使用 PoW 工作量证明、PoS 权益证明 等公式算法。</p><h4 id="raft" tabindex="-1"><a class="header-anchor" href="#raft"><span>Raft</span></a></h4><p><strong>节点类型</strong></p><p>一个 Raft 集群包括若干服务器，任何时间点，任意服务器一定会处于以下三个状态中的一个：</p><ul><li>Leader: 负责发起心跳，响应客户端，创建日志，同步日志</li><li>Candidate: Leader 选举过程中的临时角色，由 Follower 转化而来，发起投票参与竞选</li><li>Follower: 接受 Leader 的心跳和日志同步数据，投票给 Candidate</li></ul><p>在正常的情况下，只有一个服务器是 Leader，剩下的服务器是 Follower。Follower 是被动的，不会发送任何请求，只是响应来自 Leader 和 Candidate 的请求。</p><p><strong>选举</strong></p><p>任期：Raft 算法将时间划分为任意长度的任期（Redis 中的选举轮次），用连续的数字表示。每个任期都以一次选举开始。</p><p>Raft 使用心跳机制来触发 Leader 的选举。</p><ul><li>Leader 通过心跳保持 Leader 状态</li><li>Follower 通过心跳保持为 Follower 状态，并确认 Leader</li><li>如果 Follower 在一个周期内没收到心跳，将开始一次选举 <ul><li>自增自己的 term 并转换为 Candidate，向其他节点请求投票</li><li>如果超过半数节点投票给自己，则成为 Leader</li><li>期间，如果收到其它节点声明 Leader 的心跳，且 term 号大于等于自己的 term，则退回 Follower，否则拒绝该请求并让该节点更新</li><li>如果选举失败，随机一个新的超时时间，之后重新选举</li></ul></li></ul><p><strong>日志复制</strong></p><ul><li>Entry：<code>&lt;term, index, cmd&gt;</code>的结构，每一个事件成为 entry，只有 Leader 可以创建 entry。</li><li>Log：有 Entry 构成的数组，只有 Leader 才可以改变其他节点的 log。</li></ul><p>Leader 收到客户端请求后，会生成一个 entry，添加到自己的日志末尾，并广播给其它服务器，如果收到超过半数的成功响应，标记这个 entry 是 committed 的。Leader 通过强制 Follower 复制自己的日志来处理日志的不一致。</p><h4 id="api-网关" tabindex="-1"><a class="header-anchor" href="#api-网关"><span>API 网关</span></a></h4><p>主要功能：请求转发、请求过滤<br>基于这两个功能，继而实现 安全认证、流量控制、日志、监控...</p><p>常见网关：Netflix Zuul, Spring Cloud Gateway, Kong, APISIX, Shenyu...</p><h4 id="分布式-id" tabindex="-1"><a class="header-anchor" href="#分布式-id"><span>分布式 ID</span></a></h4><p>在分布式系统中，不同的数据节点要为数据生成全局唯一主键，也即分布式ID，需要满足：</p><ul><li>全局唯一</li><li>高性能</li><li>高可用</li><li>方便易用</li></ul><p>除此之外，还应保证安全、有序递增、有具体业务含义、独立部署</p><p><strong>常见解决方案</strong></p><ol><li>数据库主键自增：实现简单，但很多缺点</li><li>数据库号段模式：批量获取 ID，存入内存，需要时取用。</li><li>NoSQL：例如利用 Redis Cluster实现 id 原子递增</li><li>UUID 算法：基于 MAC 地址、时间戳、命名空间、随机数等信息生成唯一 ID。但占用存储空间过大，且无序，影响DB性能</li><li>Snowflake 算法：雪花算法，灵活有序。但如果机器时间不正确可能产生重复ID。</li></ol><p>开源方案例如 百度的 UidGenerator，美团的 Leaf，滴滴的 Tinyid</p><h4 id="rpc" tabindex="-1"><a class="header-anchor" href="#rpc"><span>RPC</span></a></h4><p>RPC，Remote Procedure Call 远程过程调用，通过网络编程实现不同服务器上的方法调用。</p><p>核心功能的实现由以下五个部分实现：</p><ol><li>客户端（服务消费端）：调用远程方法的一端</li><li>客户端 Stub（桩）： 本质上是代理类，把调用的类、方法、参数等信息传递到服务端（序列化/反序列化 + 接收/发送）</li><li>网络传输： 将调用信息传输到服务端，服务端执行完后通过网络把结果再传输回来。实现方式比如最基本的 Socket、性能以及封装更优秀的 Netty</li><li>服务端 Stub（桩）：指接收到客户端执行请求后，调用处理器然后返回结果给客户端的类（序列化/反序列化 + 接收/发送）</li><li>服务端（服务提供端）：提供远程方法的一端</li></ol><p><strong>HTTP 和 RPC</strong></p><p>纯裸 TCP 是能收发数据，但它是个无边界的数据流，上层需要定义消息格式用于定义消息边界。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。RPC本质上是一种调用方式，具体的实现 gRPC/Thrift 才是协议，目的是希望程序员能像调用本地方法那样去调用远端的服务方法。RPC也不一定非得基于TCP。</p><p>区别：</p><ul><li>服务发现：RPC一般有专门的中间服务保存服务名和IP信息（HTTP当然也能实现）</li><li>底层连接形式：RPC使用连接池</li><li>传输内容：HTTP报文非常冗余，而RPC定制化程度高，性能也更好。是内部网络使用RPC的主要原因</li></ul><p>当然HTTP/2通过压缩做了很多改进，甚至优于RPC，但由于历史原因，RPC仍在使用。</p><h2 id="消息队列" tabindex="-1"><a class="header-anchor" href="#消息队列"><span>消息队列</span></a></h2><h3 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h3><p>中间件：一类提供系统软件和应用软件之间连接、便于软件各部件之间的沟通的软件，应用软件可以借助中间件在不同的技术架构之间共享信息与资源。</p><p>消息队列：存放消息的容器，FIFO 按序消费。参与消息传递的双方称为 生产者 和 消费者，生产者负责发送消息，消费者负责处理消息。</p><p><strong>优点</strong></p><ul><li>异步处理，提高系统性能，减少响应时间</li><li>削峰/限流</li><li>降低系统耦合性</li></ul><p><strong>缺点</strong></p><ul><li>系统可用性降低：例如消息丢失，MQ宕机等问题</li><li>系统复杂性提高：需要保证无重复消费、消息丢失、消息传递顺序性等问题</li><li>一致性问题：消费者没有正确消费消息的情况</li></ul><p><strong>JMS</strong><br>Java Message Service Java消息服务的一套 API 规范。例如 ActiveMQ</p><ul><li>消息格式：StreamMessage, MapMessage, TextMessage, ObjectMessage, BytesMessage</li><li>消息模型：P2P 点对点、PubSub 订阅模型</li></ul><p><strong>AMQP</strong><br>Advanced Message Queuing Protocol 高级消息队列协议，应用层面向消息的中间件开发标准协议，支持跨平台、跨语言，兼容 JMS。例如 RabbitMQ</p><ul><li>仅支持 byte[] 消息类型</li><li>基于 Exchange 提供的路由算法，提供多种消息模型，例如 direct exchange, fanout exchange, topic change, headers exchange, system exchange</li></ul><p><strong>常见 MQ</strong></p><p>Kafka、RocketMQ、RabbitMQ、Pulsar</p><h3 id="kafka" tabindex="-1"><a class="header-anchor" href="#kafka"><span>Kafka</span></a></h3><p>Kafka 是一个分布式流式处理平台，用作消息队列和数据处理。有三个关键功能：</p><ol><li>消息队列：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。</li><li>容错的持久方式存储记录消息流： Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。</li><li>流式处理平台： 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。</li></ol><p>优点：极致的性能、生态兼容性</p><p><strong>消息模型</strong></p><ul><li>队列模型</li><li>PubSub 发布订阅模型：使用 Topic 作为消息通信载体，广播给订阅者</li></ul><p><strong>概念模型</strong></p><ul><li>Consumer</li><li>Producer</li><li>Broker：代理，一个独立的 Kafka 实例，多个 Broker 组成 Cluster</li><li>Topic：主题，Producer 发送消息到特定主题，Consumer 订阅特定主题的消息</li><li>Partition: Topic 的一部分。一个 Topic 可以有多个 Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个 Broker</li></ul><h3 id="rabbitmq" tabindex="-1"><a class="header-anchor" href="#rabbitmq"><span>RabbitMQ</span></a></h3><h4 id="概念-1" tabindex="-1"><a class="header-anchor" href="#概念-1"><span>概念</span></a></h4><p>RabbitMQ 是使用 Erlang 语言实现的 AMQP  消息中间件，整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。</p>`,109),i("figure",null,[i("img",{src:oi,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s(`<p><strong>消息</strong></p><ul><li>消息头：一系列可选属性，也叫标签。例如 routing-key 路由键, priority 优先权，delivery-mode 持久性存储...</li><li>消息体：payload</li></ul><p><strong>Exchange 交换机</strong></p><p>RabbitMQ 中消息必须先经过 Exchange，再根据路由规则分配到对应的 Queue。如果路由不到，可能返回给 Producer 或直接丢弃。</p><p>RabbitMQ 通过 Binding 将 Exchange 和 Queue 绑定关联，并指定一个 BindingKey 作为路由规则。Producer 发送消息时需要指定 RoutingKey，与 BindingKey 匹配时就会路由到对应的消息队列中。多个队列绑定到同一个 Exchange 可以使用相同的 BindingKey，具体路由还依赖于交换器类型。</p><p>分四种类型：</p><ul><li>direct：把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中。常用于处理有优先级的任务</li><li>fanout：把发送到该 Exchange 的消息路由到所有与它绑定的 Queue 中，不需要任何判断，因此速度最快</li><li>topic：将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，例如 * 匹配一个单词，# 匹配零/多个单词</li><li>headers：路由规则不依赖于路由键的匹配规则，而是根据发送的消息内容中的 headers 属性进行匹配，完全匹配才会路由</li></ul><p>因此，RabbitMQ 工作模式有 简单模式、work 工作模式、PubSub 模式、Routing 路由模式、Topic 主题模式</p><p><strong>Queue 消息队列</strong></p><p>Queue 用来保存消息，直到发送给消费者，一个消息可以投入一个或多个队列。</p><p>多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免消息被重复消费。</p><p><strong>Broker 服务节点</strong></p><p>一个 RabbitMQ 实例可以看作一个 Broker。</p><h4 id="常见问题" tabindex="-1"><a class="header-anchor" href="#常见问题"><span>常见问题</span></a></h4><ol><li>死信队列<br>Dead-Letter-Exchange 私信交换机/死信队列，当消息在一个队列中变成死信(dead message)之后，它能重新被发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列。</li></ol><p>导致死信的原因：</p><ul><li>消息被拒（Basic.Reject/Basic.Nack）且 requeue = false</li><li>消息 TTL 过期</li><li>队列满了无法添加</li></ul><ol start="2"><li>延迟队列<br>RabbitMQ 本身不支持延迟队列，但又两种实现方式：</li></ol><ul><li>利用死信交换机和消息的存活时间 TTL 模拟延迟</li><li>插件 rabbitmq-delayed-message-exchange</li></ul><ol start="3"><li>优先级队列</li></ol><p>可以通过 x-max-priority 参数实现优先级队列。不过，当消费速度大于生产速度且 Broker 没有堆积的情况下，优先级显得没有意义。</p><ol start="4"><li>消息传输</li></ol><p>RabbitMQ 使用信道 Channel 来传输数据，信道是建立在 TCP 连接上的虚拟连接，一条 TCP 连接上可以有上千条信道复用，每条信道都有唯一ID，并且对应一个线程使用。</p><ol start="5"><li>保证消息可靠性</li></ol><ul><li>Producer 到 RabbitMQ：事务机制 或 Confirm 机制</li><li>RabbitMQ 中：持久化、集群、普通模式、镜像模式</li><li>RabbitMQ 到 Consumer：basicAck 机制、死信队列、消息补偿机制</li></ul><ol start="6"><li>保证消息顺序性</li></ol><ul><li>拆分多个 Queue，每个 Queue 一个消费者</li><li>Consumer 内部用队列排队，分发给底层不同的 worker 处理</li></ul><ol start="7"><li>保证高可用<br>RabbitMQ 基于主从做高可用，有三种模式：</li></ol><ul><li>单机模式：生产环境不用</li><li>普通集群：多台机器启动多个 RabbitMQ 实例，创建的 Queue 只放在一个实例上，实例之间同步 Queue 的元数据，以找到 Queue 所在的实例</li><li>镜像集群：创建 Queue 存在于多个实例上，每次写消息到 Quee 都会同步到所有实例。缺点就是性能开销大，网络压力重</li></ul><h2 id="开发工具" tabindex="-1"><a class="header-anchor" href="#开发工具"><span>开发工具</span></a></h2><h3 id="linux" tabindex="-1"><a class="header-anchor" href="#linux"><span>Linux</span></a></h3><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">top</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">进程</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">号&gt; </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">-u</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">用户</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">名&gt;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ps</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -ef</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 向进程发送信号，例如 -9 SIGKILL</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">kill</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -9</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> pid</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 启动/停止/重启/重新加载配置 一个Unit服务</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">systemctl</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> | </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">stop</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> | </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">restart</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> | </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">reload</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">free</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    # 可用内存和已使用情况</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">vmstat</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  # 虚拟内存统计</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">df</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      # 文件系统磁盘空间占用</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">iostat</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  # IO 统计</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ifstat</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  # 统计网络接口流量状态</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 递归修改文件权限</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">chmod</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -R</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 777</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> dir</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 查看网络配合和收发数据包的统计信息</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ifconfig/ip</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 查看 socket、网络协议栈、网口、路由表信息</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ss/netstat</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 查看当前网络的吞吐率和 PPS</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sar</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># secure copy 远程安全拷贝</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">scp</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> local_file</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> remote_username@remote_ip:remote_file</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 统计行数</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">wc</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -l</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> file</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 日志处理 (awk 处理文本 -&gt; 排序 -&gt; 去重统计 -&gt; 统计结果逆序 -&gt; top 3)</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">awk</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;{print substr($4, 2, 11)}&#39;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> access.log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> | </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> | </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">uniq</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -c</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> | </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sort</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -rn</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> | </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">head</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -n</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 3</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 以 6 个线程，3 万个连接，持续 60s 对目标进行压测</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">wrk</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -t</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 6</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -c</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 30000</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -d</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 60s</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> http://xxx:8080</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="maven" tabindex="-1"><a class="header-anchor" href="#maven"><span>Maven</span></a></h3><p><strong>作用</strong></p><ol><li>项目构建：提供标准的、跨平台的自动化项目构建方式。</li><li>依赖管理：方便快捷的管理项目依赖的资源（jar 包），避免资源间的版本冲突问题。</li><li>统一开发结构：提供标准的、统一的项目结构。</li></ol><p><strong>坐标</strong></p><ul><li>groupId：项目隶属的组织或公司</li><li>artifactId：项目的名称</li><li>version</li><li>其它可选：packaging（jar/war/...）、classifier</li></ul><p><strong>依赖范围</strong><br>三套不同的classpath：</p><ul><li>编译 classpath ：编译主代码有效</li><li>测试 classpath ：编译、运行测试代码有效</li><li>运行 classpath ：项目运行时有效</li></ul><p>不同的依赖范围：</p><ul><li>compile：默认，对编译、测试、运行都有效</li><li>provided：对编译、测试有效，如Servlet</li><li>test：仅用于测试，如JUnit</li><li>runtime：仅用于运行，如JDBC Driver</li><li>system：必须通过systemPath指定，不依赖Maven</li></ul><p><strong>依赖冲突</strong><br>遵循 路径最短优先 -&gt; 声明顺序优先 两大原则。</p><p><code>&lt;exception&gt;</code> 手动排除依赖</p><p><strong>Maven 仓库</strong><br>除了本地仓库，远程仓库分三类：</p><ul><li>中央仓库：Maven 社区维护</li><li>私服：设在局域网内的仓库服务</li><li>其它公共仓库：用于加速访问，或部分构件不存在于中央仓库</li></ul><p>依赖查找顺序：本地仓库 -&gt; 远程仓库 -&gt; 报错</p><p><strong>生命周期</strong></p><ul><li>default</li><li>clean</li><li>site</li></ul><p>每个生命周期里包含多个阶段，阶段间前后依赖，当执行某个阶段的时候，会先执行它前面的阶段。</p><p><strong>多模块管理</strong></p><ul><li>降低代码之间的耦合性（从类级别的耦合提升到 jar 包级别的耦合）</li><li>减少重复，提升复用性</li><li>每个模块都可以是自解释的（通过模块名或者模块文档）</li><li>模块还规范了代码边界的划分，开发者很容易通过模块确定自己所负责的内容</li></ul><h3 id="git" tabindex="-1"><a class="header-anchor" href="#git"><span>Git</span></a></h3><p>Git 不同与其它版本控制记录文件修改的增量，而是直接保存修改文件的快照。</p><p><strong>文件三种状态</strong></p><ul><li>已提交（committed）：数据已经安全的保存在本地数据库中。</li><li>已修改（modified）：已修改表示修改了文件，但还没保存到数据库中。</li><li>已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li></ul><p>由此引出三个工作区：工作目录、暂存区、Git 仓库</p><p><strong>常用命令</strong></p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 添加远程地址</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">git</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> remote</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> add</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> origin</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">serve</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">r&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 贮藏修改到栈上</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">git</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> stash</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 应用贮藏的修改</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">git</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> stash</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> apply</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>merge 和 rebase 区别</strong></p><ul><li>merge 合并分支会新增一个merge commit，然后将两个分支的历史联系起来。对现有分支不会以任何方式被更改，但是会导致历史记录相对复杂</li><li>rebase 找到两个分支最近的共同祖先，将整个分支移动到另一个分支上，修改各自的冲突，整合所有分支上的提交。好处是历史记录更加清晰，是在原有提交的基础上将差异内容反映进去，消除了 git merge所需的不必要的合并提交</li></ul><h3 id="docker" tabindex="-1"><a class="header-anchor" href="#docker"><span>Docker</span></a></h3><p><strong>优势</strong><br>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><ul><li>一致的运行环境，能够更轻松地迁移</li><li>对进程进行封装隔离，容器与容器之间互不影响，更高效地利用系统资源</li><li>可以通过镜像复制多个一致的容器</li></ul><p><strong>重要概念</strong></p><ul><li>镜像：一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数</li><li>容器：镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等，每个容器相互隔离</li><li>仓库：集中存放镜像文件的地方</li></ul><p><strong>容器</strong></p><ul><li>容器镜像是轻量的、可执行的独立软件包 ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。</li><li>容器化软件适用于不同OS的应用，在任何环境中都能够始终如一地运行。</li><li>容器赋予了软件独立性，使其免受外在环境差异的影响</li></ul><p><strong>对比虚拟机</strong></p><ul><li>容器是一个应用层抽象，用于将代码和依赖资源打包在一起。多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行。容器占用空间少，启动快</li><li>虚拟机 (VM) 是一个物理硬件层抽象，用于将一台服务器变成多台服务器。</li></ul><p><strong>常用命令</strong></p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> version</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      # 查看docker版本</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> images</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">       # 查看所有已下载镜像，等价于：docker image ls 命令</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> container</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ls</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> #	查看所有容器</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ps</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">           #查看正在运行的容器</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> image</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> prune</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  # 清理临时的、没有被使用的镜像文件。-a, --all: 删除所有没有用的镜像，而不仅仅是临时文件；</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> search</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> mysql</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     # 查看mysql相关镜像</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> pull</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> mysql:5.7</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   # 拉取mysql镜像</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> image</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ls</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">         # 查看所有已下载镜像</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> rmi</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> xxx</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">          # 删除镜像</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> rm</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> xxx</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">           # 删除容器</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> start</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> xxx</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> restart</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> xxx</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> stop</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> xxx</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> kill</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> xxx</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> udpate</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --restart=always</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> xxx</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  # 设置容器自启动</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> logs</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -ft</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> xxx</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">       # 实时显示日志，并打印时间戳</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> top</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> xxx</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            # 容器内运行了哪些进程</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> exec</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -it</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> xxx</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> bash</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  # 与容器交互</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> cp</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> file</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> xxx:dir</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    # 将文件从宿主机拷贝到容器指定位置，反之也可以</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> inspect</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> xxx</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        # 查看容器/数据卷细节</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> run</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -v</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> volume:dir</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  # 将volume/宿主机目录 映射到 容器内的dir</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> commit</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -m</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;描述信息&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -a</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;镜像作者&quot;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> tomcat01</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> my_tomcat:1.0</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   # 打包镜像</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> save</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> my_tomcat:1.0</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -o</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> my-tomcat-1.0.tar</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                    # 备份镜像</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> load</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -i</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> my-tomcat-1.0.tar</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                  # 加载本地镜像</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="系统设计" tabindex="-1"><a class="header-anchor" href="#系统设计"><span>系统设计</span></a></h2><h4 id="熔断降级" tabindex="-1"><a class="header-anchor" href="#熔断降级"><span>熔断降级</span></a></h4><p><strong>熔断</strong></p><p>A 服务调用 B 服务的某个功能，由于网络不稳定问题，或者 B 服务卡机，导致功能时间超长。如果这样子的次数太多。我们就可以直接将 B 断路了（A 不再请求 B 接口），凡是调用 B 的直接返回降级数据，不必等待 B 的超长执行。 这样 B 的故障问题，就不会级联影响到 A。</p><p><strong>降级</strong></p><p>整个网站处于流量高峰期，服务器压力剧增，根据当前业务情况及流量，对一些服务和页面进行有策略的降级（停止服务，所有的调用直接返回降级数据）。以此缓解服务器资源的的压力，以保证核心业务的正常运行，同时也保持了客户和大部分客户的得到正确的相应。</p><p><strong>相同点</strong></p><ul><li>为了保证集群大部分服务的可用性和可靠性，防止崩溃，牺牲一部分服务</li><li>用户最终都是体验到某个功能不可用</li></ul><p><strong>不同点</strong>、</p><ul><li>熔断是被调用方故障，触发系统主动规则</li><li>降级是基于全局考虑，手动停止一些正常服务，释放资源</li></ul><h4 id="服务限流" tabindex="-1"><a class="header-anchor" href="#服务限流"><span>服务限流</span></a></h4><p>限流就是对请求的速率进行限制，避免瞬时的大量请求击垮软件系统。</p><p><strong>固定窗口计数器</strong></p><ul><li>即时间窗口，规定了单位时间内处理的请求数量。</li><li>例如用 counter 计数请求，超过阈值后拒绝请求，等时间到了重置</li><li>这种限流算法无法保证限流速率，因而无法保证突然激增的流量。例如一分钟内的前55s没有请求，后1s突然有1000个请求，系统直接被击垮</li></ul><p><strong>滑动窗口计数器</strong></p><ul><li>在固定窗口计数器基础上，把时间以一定比例分片，对窗口内请求数计数。</li><li>分片越细，窗口滚动越平滑，限流也就越精确</li></ul><p><strong>漏桶算法</strong></p><ul><li>类似漏桶漏水，任意速率流入，固定速率流出</li><li>可以使用队列保存请求，定期从队列中取出请求执行</li></ul><p><strong>令牌桶算法</strong></p><ul><li>以一定速率网桶里添加令牌，桶满就不再添加</li><li>请求在处理前需要拿到一个令牌，处理完毕后将令牌丢弃</li></ul><h4 id="高可用" tabindex="-1"><a class="header-anchor" href="#高可用"><span>高可用</span></a></h4><p>描述一个系统在大部分时间都是可用的，即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。</p><p><strong>系统不可用原因</strong></p><ul><li>黑客攻击</li><li>硬件故障</li><li>并发量/用户请求量激增</li><li>代码中的坏味道导致内存泄漏或者其他问题，进而引发程序崩溃</li><li>网站架构中的某个组件宕机</li><li>自然灾害、人为破坏</li><li>......</li></ul><p><strong>提高方法</strong></p><ol><li>集群，避免单点故障</li><li>限流，避免瞬时流量高峰冲垮系统</li><li>超时和重试机制</li><li>熔断，系统自动收集所依赖服务的资源使用情况和性能指标，当所依赖的服务恶化或者调用失败次数达到某个阈值的时候就迅速失败，让当前系统立即切换依赖其他备用服务。</li><li>异步调用，或配合消息队列</li><li>缓存机制</li></ol><p><strong>冗余设计</strong></p><ul><li>高可用集群：同一份服务部署两份或者多份，以便故障时快速切换</li><li>同城/异地灾备，备用服务不处理请求</li><li>同城/异地多活，备用服务也处理请求</li></ul><h4 id="性能测试" tabindex="-1"><a class="header-anchor" href="#性能测试"><span>性能测试</span></a></h4><ul><li>性能测试：通过测试工具模拟用户请求系统，目的主要是为了测试系统的性能是否满足要求</li><li>负载测试：对被测试的系统继续加大请求压力，直到服务器的某个资源已经达到饱和，达到系统上限</li><li>压力测试：不去管系统资源的使用情况，对系统继续加大请求压力，直到服务器崩溃无法再继续提供服务</li><li>稳定性测试：模拟真实场景，给系统一定压力，看看业务是否能稳定运行</li></ul><h4 id="restful" tabindex="-1"><a class="header-anchor" href="#restful"><span>RestFul</span></a></h4><p>Resource Representational State Transfer “资源”在网络传输中以某种“表现形式”进行“状态转移”。</p><ul><li>资源：特定 URI 对应的对象数据</li><li>表现形式：资源具体的呈现形式，如JSON、XML、Image等</li><li>状态转移：通过CRUD，使得服务器端资源状态的改变</li></ul><p><strong>动作</strong></p><ul><li>GET：请求获取特定资源</li><li>POST：创建新资源</li><li>PUT：更新资源</li><li>DELETE：删除资源</li><li>PATCH：部分更新</li></ul><h4 id="软件工程" tabindex="-1"><a class="header-anchor" href="#软件工程"><span>软件工程</span></a></h4><p><strong>瀑布模型</strong></p><p>软件概念 -&gt; 需求分析 -&gt; 架构设计 -&gt; 详细设计 -&gt; 编码 -&gt; 测试</p><p><strong>敏捷开发模型</strong><br>一种以人为核心、迭代、循序渐进的开发方法。在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。</p><p><strong>开发策略</strong><br>软件复用、分而治之、逐步演进、优化折中</p><h4 id="认证授权" tabindex="-1"><a class="header-anchor" href="#认证授权"><span>认证授权</span></a></h4><ul><li>认证：验证身份凭据</li><li>授权：管理操作权限</li></ul><p>RBAC 模型：Role-Based Access Control 基于角色的权限访问控制，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。</p><p><strong>Cookie 和 Session</strong></p><p>Cookie：保存在客户端（浏览器），一般用来保存用户信息。（例如存放 SessionId 用于服务器标记用户）<br>Session：保存在服务端，记录用户的状态。（HTTP是无状态的，需要Session标记并跟踪特定用户）</p><ul><li>一般 Session 的安全性更高，Cookie尽量加密放到服务端解密。</li><li>Session 一般依赖于 Cookie 实现。，但也可以不用 Cookie，例如直接放在 url 中，但安全性和用户体验降低。</li><li>Cookie 无法防止 CSRF 跨站请求伪造（以用户身份发送虚假请求），但 Token 令牌可以禁止（Token 保存在 localStorage 中，前端负责携带 Token）</li><li>Cookie 和 Token 都无法阻止 XSS 跨站脚本攻击（注入恶意代码，通过脚本盗用信息）</li></ul><h4 id="sso" tabindex="-1"><a class="header-anchor" href="#sso"><span>SSO</span></a></h4><p>Single Sign On 单点登录，在多个应用的系统中，只需要登陆一次，就可以访问其它相互信任的应用系统。对于同域下的不同服务，只要扩大 Cookie 作用域到顶域，然后共享 session 即可（Redis 统一存储 Session）。但对于不同域下的服务，需要单独部署 SSO 系统，只要登录了这个公共的登陆服务就代表对应的服务群都登录了。</p>`,119),i("figure",null,[i("img",{src:gi,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1),s(`<p><strong>跨域 SSO</strong></p><ul><li>用户访问 app1 系统，app1 没有登录，跳转到SSO</li><li>SSO 也没有登录，弹出用户登录页</li><li>用户填写用户名、密码，SSO 进行认证后，将登录状态写入 SSO 的 session，并通知浏览器中写入 SSO 域下的 Cookie</li><li>SSO 登录完成后会生成一个 ST (Service Ticket)，携带并跳转到 app1 系统</li><li>app1 拿到 ST 后，向 SSO 发送请求验证 ST 是否有效</li><li>验证通过后，app1 将登录状态写入 Session 并设置 app1 域下的 Cookie</li></ul><p><strong>访问 App2</strong></p><ul><li>用户访问 app2 系统，app2 没有登录，跳转到SSO</li><li>由于 SSO 已经登录了，不需要重新登录认证</li><li>SSO 生成 ST，携带并跳转到 app2 系统</li><li>app2 拿到 ST 后，向 SSO 发送请求验证 ST 是否有效</li><li>验证成功后，app2 将登录状态写入 Session 并设置 app2 域下的 Cookie</li></ul><h4 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式"><span>设计模式</span></a></h4><h5 id="单例" tabindex="-1"><a class="header-anchor" href="#单例"><span>单例</span></a></h5><p>确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 懒汉</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Singleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Singleton</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> instance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> private</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Singleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (){}</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Singleton</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getInstance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (instance </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        instance </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Singleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> instance;  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 饿汉</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Singleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Singleton</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> instance </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Singleton</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  private</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Singleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (){}</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Singleton</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getInstance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">      return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> instance;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 双重校验锁</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Singleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 实例化对象分三个步骤：分配内存对象 -&gt; 初始化对象 -&gt; 将对象指向刚分配的内存空间</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // Volatile 禁止指令重排序，防止另一个线程访问一个初始化未完成的对象（2、3步重排序）</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> volatile</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Singleton</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> singleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  private</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Singleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (){}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Singleton</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getSingleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (singleton </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      // 只有第一次初始化才需要加锁，后续不需要  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">      synchronized</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Singleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 如果多个线程同时通过了第一次检查，防止第二个进入临界区的线程再次创建对象</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (singleton </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">          singleton </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Singleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      }  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> singleton;  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="工厂模式" tabindex="-1"><a class="header-anchor" href="#工厂模式"><span>工厂模式</span></a></h5><p>通过定义工厂类来创建对象，让使用者不用知道具体的参数就可以创建出所需的产品类。</p><h5 id="适配器模式" tabindex="-1"><a class="header-anchor" href="#适配器模式"><span>适配器模式</span></a></h5><p>解决两个软件实体间的接口不兼容的问题</p><h5 id="策略模式" tabindex="-1"><a class="header-anchor" href="#策略模式"><span>策略模式</span></a></h5><p>相同的目标，用不同的方法实现。例如 Spring 中加载 BeanDefinition 可以从类路径加载、文件系统加载、网络资源加载，可以通过不同的类，实现共同的接口来实现。</p><h5 id="代理模式-1" tabindex="-1"><a class="header-anchor" href="#代理模式-1"><span>代理模式</span></a></h5><p>一个类代表另一个类的功能。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p><h2 id="手撕算法" tabindex="-1"><a class="header-anchor" href="#手撕算法"><span>手撕算法</span></a></h2><h4 id="lru" tabindex="-1"><a class="header-anchor" href="#lru"><span>LRU</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> LRUCache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> DLinkedNode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        DLinkedNode</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> prev</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        DLinkedNode</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> DLinkedNode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {}</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> DLinkedNode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> _key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> _value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {key </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> _key; value </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> _value;}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Map</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> DLinkedNode</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> cache </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> HashMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> DLinkedNode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> size</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> capacity</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> DLinkedNode</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> head</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> tail</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> LRUCache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> capacity</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">size</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">capacity</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> capacity;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 使用伪头部和伪尾部节点</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        head </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> DLinkedNode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        tail </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> DLinkedNode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        head</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tail;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        tail</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">prev</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> head;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        DLinkedNode</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> node</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> cache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (node </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 如果 key 存在，先通过哈希表定位，再移到头部</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        moveToHead</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(node);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        DLinkedNode</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> node</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> cache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (node </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 如果 key 不存在，创建一个新的节点</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">            DLinkedNode</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> newNode</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> DLinkedNode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key, value);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 添加进哈希表</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            cache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key, newNode);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 添加至双向链表的头部</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">            addToHead</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(newNode);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            ++size;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (size </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> capacity) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                // 如果超出容量，删除双向链表的尾部节点</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">                DLinkedNode</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> tail</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> removeTail</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                // 删除哈希表中对应的项</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">                cache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">remove</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">tail</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                --size;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        else</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> value;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">            moveToHead</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(node);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> addToHead</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">DLinkedNode</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">prev</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> head;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> head</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        head</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">prev</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> node;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        head</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> node;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> removeNode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">DLinkedNode</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">prev</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">next</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">prev</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">prev</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> moveToHead</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">DLinkedNode</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        removeNode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(node);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        addToHead</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(node);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> DLinkedNode</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> removeTail</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        DLinkedNode</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> res</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> tail</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">prev</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        removeNode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(res);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> res;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="堆排" tabindex="-1"><a class="header-anchor" href="#堆排"><span>堆排</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Solution</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> heapSort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">nums</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> heapSize</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> nums</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        buildHeap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(nums, heapSize);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> nums</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i--) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(nums[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot; &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">            swap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(nums, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, i);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            --heapSize;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">            heapify</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(nums, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, heapSize); </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> buildHeap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">nums</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> heapSize</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> heapSize </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">/</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i--) </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">            heapify</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(nums, i, heapSize);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> heapify</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">nums</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> heapSize</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> l</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, r </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> maxIdx</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(l </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> heapSize </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nums[maxIdx] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nums[l])</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            maxIdx </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> l;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(r </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> heapSize </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nums[maxIdx] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nums[r])</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            maxIdx </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> r;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(maxIdx </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i){</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">            swap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(nums, i, maxIdx);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">            heapify</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(nums, maxIdx, heapSize);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> swap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">nums</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> j</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> tmp</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nums[i];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        nums[i] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nums[j];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        nums[j] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tmp;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="快排" tabindex="-1"><a class="header-anchor" href="#快排"><span>快排</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Solution</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Random</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> rand </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Random</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">currentTimeMillis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">[] </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sortArray</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">nums</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        quickSort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(nums, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">nums</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nums;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> quickSort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">nums</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> left</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> right</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(left </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> right)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> r</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> rand</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">nextInt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(right </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> left </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        swap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(nums, left, left </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> r);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> pivot</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> left;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> lt</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> left </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, gt </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> right;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(lt </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> right </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nums[lt] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nums[pivot])    lt++;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(gt </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> left </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nums[gt] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nums[pivot])  gt--;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(lt </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> gt)    </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">break</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">            swap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(nums, lt++ ,gt--);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        swap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(nums, pivot, gt);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        quickSort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(nums, left, gt </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        quickSort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(nums, gt </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, right);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> swap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">nums</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> j</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> tmp</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nums[i];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        nums[i] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nums[j];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        nums[j] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tmp;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="归并排序" tabindex="-1"><a class="header-anchor" href="#归并排序"><span>归并排序</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Solution</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">[] tmp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">[] </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sortArray</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">nums</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        tmp </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">nums</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        mergeSort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(nums, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">nums</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nums;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> mergeSort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">nums</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> l</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> r</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (l </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> r) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> mid</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (l </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> r) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        mergeSort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(nums, l, mid);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        mergeSort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(nums, mid </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, r);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> l, j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> mid </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> cnt</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> mid </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> r) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (nums[i] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nums[j]) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                tmp[cnt++] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nums[i++];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                tmp[cnt++] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nums[j++];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> mid) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            tmp[cnt++] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nums[i++];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> r) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            tmp[cnt++] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nums[j++];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> k</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; k </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> r </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> l </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; ++k) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            nums[k </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> l] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tmp[k];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="背包" tabindex="-1"><a class="header-anchor" href="#背包"><span>背包</span></a></h4><p><strong>0-1背包</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 前 i 件商品，总重量 j 的前提下的最大价值</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">dp[i][j] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">max</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(dp[i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">][j], dp[i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">][j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> w[i]] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> v[i])</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>完全背包</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 前 i 种硬币（可重复），总金额 j 的组合方式</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">dp[i][j] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> dp[i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">][j] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> dp[i][j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> coins[i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">]]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="斐波那契" tabindex="-1"><a class="header-anchor" href="#斐波那契"><span>斐波那契</span></a></h4><p>不要写递归！！！复杂度 $O(2^n)$!!!</p><p>写 DP，复杂度 O(n)</p><h4 id="二分细节" tabindex="-1"><a class="header-anchor" href="#二分细节"><span>二分细节</span></a></h4><ol><li>while(l &lt; r)</li><li>如果更新时 l = mid + 1 和 r = mid; 则 mid = left + (right - left + 1) / 2;</li><li>如果更新时 l = mid 和 r = mid - 1; 则 mid = left + (right - left + 1) / 2;</li><li>返回时优先取 r，避免越界</li></ol><blockquote><p>二分的本质是「二段性」而非「单调性」<br>二分不仅适用于 01 特性（满足/不满足），还适用于** 一定满足/不一定满足** 这样的特性</p></blockquote><h2 id="场景题" tabindex="-1"><a class="header-anchor" href="#场景题"><span>场景题</span></a></h2><p>40亿 bit ~= 500 MB；1亿整数 ~= 400 MB</p><ol><li>两个文件分别有 50亿 URL，找出其中相同的 URL</li></ol><p>先哈希切分多个小文件，对每个文件建立 HashSet，查找相同的 URL；优化：前缀字典树，降低存储成本提高查询效率</p><ol start="2"><li>大量数据找出 Top 100 频度的字符串</li></ol><p>分而治之，哈希取余 -&gt; HashMap 统计频度 -&gt; 容量 K 的小顶堆求 Top K</p><ol start="3"><li>大量数据中找出不重复的数字</li></ol><p>分治法：切分小文件 -&gt; Hashset/HashMap 找出每个小文件不重复的整数 -&gt; 合并每个子结果</p><p>位图法：用两位 bit 表示数字状态，00没出现，01出现一次，10出现多次。前提是内存可以容纳所有 bit</p><ol start="4"><li>大量数据中判断一个数是否存在</li></ol><p>分治法：/<br>位图法：每个存在的整数对应的 bit 置 1，然后直接查询该数对应位是否为 1。</p><ol start="5"><li>5亿个数中找出中位数</li></ol><p>双堆法：一个大根堆，一个小根堆。大根堆的最大元素小于小根堆的最小元素，保证两个堆的元素个数不超过 1。如果数据总数为偶数，中位数就是两个堆顶的平均值，否则是容量较大的堆的堆顶元素。</p><p>分治法: 先遍历一轮，二进制最高位为 1 的写入 file1，否则写入 file0，则中位数位于数量较多的文件中。继续按 位 划分，直到可以定位到中位数。</p><ol start="6"><li>Redis 数据结构的应用</li></ol><p>ZSet 可以用于实现排行榜数据，例如根据某个权重排序，获得排名顺序。</p><p>Set 可以用于集合的交集、并集计算等。例如计算每日新增用户数，用两天的用户 set 作差（sdiffstore命令）</p><p>Bitmap 不记录数据本身，只能判断是否存在，可以用于每月的签到记录的场景。</p>`,54)]))}const vi=h(w,[["render",ci]]),bi=JSON.parse('{"path":"/coding/interview-java.html","title":"面试八股","lang":"zh-CN","frontmatter":{"title":"面试八股","date":"2023-03-10T00:00:00.000Z","category":["Java"],"tag":["面试"],"description":"实习 -- 目的地搜索优化 以前用户在搜索机场数据时，只会展示对应的城市机场信息，新的需求是用户在搜索某个景点信息时，展示对应城市的机场信息。另外优化了两个问题： 邻近机场距离由机场-邻近城市 -> 机场-邻近机场：增加near_airport_distance的json格式串 同音不同字的城市机场搜索：cityPinyin -> 机场 的 Map 切...","head":[["meta",{"property":"og:url","content":"https://xchanper.github.io/coding/interview-java.html"}],["meta",{"property":"og:site_name","content":"chanper"}],["meta",{"property":"og:title","content":"面试八股"}],["meta",{"property":"og:description","content":"实习 -- 目的地搜索优化 以前用户在搜索机场数据时，只会展示对应的城市机场信息，新的需求是用户在搜索某个景点信息时，展示对应城市的机场信息。另外优化了两个问题： 邻近机场距离由机场-邻近城市 -> 机场-邻近机场：增加near_airport_distance的json格式串 同音不同字的城市机场搜索：cityPinyin -> 机场 的 Map 切..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://xchanper.github.io/img/HTTP%E6%BC%94%E8%BF%9B.webp#id=D7LAB&originHeight=366&originWidth=782&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-22T07:34:10.000Z"}],["meta",{"property":"article:tag","content":"面试"}],["meta",{"property":"article:published_time","content":"2023-03-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-22T07:34:10.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面试八股\\",\\"image\\":[\\"https://xchanper.github.io/img/HTTP%E6%BC%94%E8%BF%9B.webp#id=D7LAB&originHeight=366&originWidth=782&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png#id=N9ti5&originHeight=1081&originWidth=1296&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png#id=kVjem&originHeight=794&originWidth=753&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/DNS%E6%9F%A5%E8%AF%A2.webp#id=l92M7&originHeight=1095&originWidth=1505&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B.webp#id=Rdt00&originHeight=271&originWidth=613&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98.webp#id=puypr&originHeight=854&originWidth=962&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5.webp#id=Ed6yQ&originHeight=1004&originWidth=1382&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5.webp#id=zADBN&originHeight=561&originWidth=935&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98.webp#id=pGugH&originHeight=699&originWidth=1452&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/32%E4%BD%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.webp#id=cOAL8&originHeight=976&originWidth=1210&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.webp#id=gi9T3&originHeight=722&originWidth=1166&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/%E7%9B%AE%E5%BD%95%E9%A1%B9%E5%92%8C%E7%B4%A2%E5%BC%95%E5%85%B3%E7%B3%BB%E5%9B%BE.webp#id=mkdtI&originHeight=842&originWidth=1172&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.webp#id=N5wFA&originHeight=1262&originWidth=962&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/I_O%E8%BD%AF%E4%BB%B6%E5%88%86%E5%B1%82.webp#id=aTZtk&originHeight=842&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/%E5%8D%95Reactor%E5%8D%95%E8%BF%9B%E7%A8%8B.webp#id=Xhd2m&originHeight=834&originWidth=1427&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.webp#id=cxi30&originHeight=1277&originWidth=1514&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.webp#id=ZGkWX&originHeight=1262&originWidth=1772&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/Proactor.webp#id=sbg1q&originHeight=654&originWidth=1427&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C.webp#id=oVxf2&originHeight=560&originWidth=587&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/Executor%E6%A1%86%E6%9E%B6.png#id=GBk0x&originHeight=380&originWidth=561&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/ThreadLocal%E7%BB%93%E6%9E%84.png#id=s38Y5&originHeight=794&originWidth=1072&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/CLH%E9%98%9F%E5%88%97.png#id=ixnaN&originHeight=304&originWidth=1181&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/MySQL%E6%9E%B6%E6%9E%84.webp#id=DyVTi&originHeight=1440&originWidth=1920&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.webp#id=AzFfx&originHeight=1131&originWidth=1440&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.webp#id=PE5BI&originHeight=856&originWidth=1142&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg#id=JyJIF&originHeight=303&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.webp#id=vQ1zV&originHeight=619&originWidth=1440&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/MVC%E5%8E%9F%E7%90%86.png#id=jJqZb&originHeight=419&originWidth=737&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/RabbitMQ%E6%A8%A1%E5%9E%8B.jpg#id=q62UK&originHeight=306&originWidth=687&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\",\\"https://xchanper.github.io/img/SSO.png#id=IasZY&originHeight=931&originWidth=737&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\\"],\\"datePublished\\":\\"2023-03-10T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-22T07:34:10.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"实习 -- 目的地搜索优化","slug":"实习-目的地搜索优化","link":"#实习-目的地搜索优化","children":[{"level":3,"title":"数据库设计","slug":"数据库设计","link":"#数据库设计","children":[]},{"level":3,"title":"核心逻辑","slug":"核心逻辑","link":"#核心逻辑","children":[]}]},{"level":2,"title":"项目","slug":"项目","link":"#项目","children":[{"level":3,"title":"酷安好物","slug":"酷安好物","link":"#酷安好物","children":[]},{"level":3,"title":"手写Spring","slug":"手写spring","link":"#手写spring","children":[]}]},{"level":2,"title":"数据结构","slug":"数据结构","link":"#数据结构","children":[]},{"level":2,"title":"计网","slug":"计网","link":"#计网","children":[{"level":3,"title":"基础","slug":"基础","link":"#基础","children":[]},{"level":3,"title":"HTTP","slug":"http","link":"#http","children":[]},{"level":3,"title":"TCP","slug":"tcp","link":"#tcp","children":[]},{"level":3,"title":"IP","slug":"ip","link":"#ip","children":[]}]},{"level":2,"title":"操作系统","slug":"操作系统","link":"#操作系统","children":[{"level":3,"title":"硬件结构","slug":"硬件结构","link":"#硬件结构","children":[]},{"level":3,"title":"OS 结构","slug":"os-结构","link":"#os-结构","children":[]},{"level":3,"title":"内存管理","slug":"内存管理","link":"#内存管理","children":[]},{"level":3,"title":"进程管理","slug":"进程管理","link":"#进程管理","children":[]},{"level":3,"title":"调度算法","slug":"调度算法","link":"#调度算法","children":[]},{"level":3,"title":"文件系统","slug":"文件系统","link":"#文件系统","children":[]},{"level":3,"title":"设备管理","slug":"设备管理","link":"#设备管理","children":[]},{"level":3,"title":"网络系统","slug":"网络系统","link":"#网络系统","children":[]}]},{"level":2,"title":"Java","slug":"java","link":"#java","children":[{"level":3,"title":"集合","slug":"集合","link":"#集合","children":[]},{"level":3,"title":"IO","slug":"io","link":"#io","children":[]},{"level":3,"title":"并发","slug":"并发","link":"#并发","children":[]},{"level":3,"title":"JVM","slug":"jvm","link":"#jvm","children":[]},{"level":3,"title":"其它","slug":"其它","link":"#其它","children":[]}]},{"level":2,"title":"MySQL","slug":"mysql","link":"#mysql","children":[{"level":3,"title":"三范式","slug":"三范式","link":"#三范式","children":[]},{"level":3,"title":"SQL 注入","slug":"sql-注入","link":"#sql-注入","children":[]},{"level":3,"title":"架构","slug":"架构","link":"#架构","children":[]},{"level":3,"title":"InnoDb 和 MyISAM 区别","slug":"innodb-和-myisam-区别","link":"#innodb-和-myisam-区别","children":[]},{"level":3,"title":"MyISAM 的优势","slug":"myisam-的优势","link":"#myisam-的优势","children":[]},{"level":3,"title":"对比 NoSQL","slug":"对比-nosql","link":"#对比-nosql","children":[]},{"level":3,"title":"索引","slug":"索引","link":"#索引","children":[]},{"level":3,"title":"事务","slug":"事务","link":"#事务","children":[]},{"level":3,"title":"三大日志","slug":"三大日志","link":"#三大日志","children":[]},{"level":3,"title":"MVVC 机制","slug":"mvvc-机制","link":"#mvvc-机制","children":[]},{"level":3,"title":"锁机制","slug":"锁机制-1","link":"#锁机制-1","children":[]},{"level":3,"title":"主从同步","slug":"主从同步","link":"#主从同步","children":[]},{"level":3,"title":"分库分表","slug":"分库分表","link":"#分库分表","children":[]},{"level":3,"title":"SQL 语句","slug":"sql-语句","link":"#sql-语句","children":[]},{"level":3,"title":"count 效率","slug":"count-效率","link":"#count-效率","children":[]}]},{"level":2,"title":"Redis","slug":"redis","link":"#redis","children":[{"level":3,"title":"数据结构","slug":"数据结构-1","link":"#数据结构-1","children":[]},{"level":3,"title":"速度快的原因","slug":"速度快的原因","link":"#速度快的原因","children":[]},{"level":3,"title":"线程模型","slug":"线程模型","link":"#线程模型","children":[]},{"level":3,"title":"过期删除策略","slug":"过期删除策略","link":"#过期删除策略","children":[]},{"level":3,"title":"缓存淘汰机制","slug":"缓存淘汰机制","link":"#缓存淘汰机制","children":[]},{"level":3,"title":"持久化机制","slug":"持久化机制","link":"#持久化机制","children":[]},{"level":3,"title":"缓存三大问题","slug":"缓存三大问题","link":"#缓存三大问题","children":[]},{"level":3,"title":"分布式锁","slug":"分布式锁","link":"#分布式锁","children":[]},{"level":3,"title":"缓存一致性问题","slug":"缓存一致性问题","link":"#缓存一致性问题","children":[]},{"level":3,"title":"高可用模式","slug":"高可用模式","link":"#高可用模式","children":[]}]},{"level":2,"title":"Spring","slug":"spring","link":"#spring","children":[{"level":3,"title":"IoC","slug":"ioc-1","link":"#ioc-1","children":[]},{"level":3,"title":"AOP","slug":"aop-1","link":"#aop-1","children":[]},{"level":3,"title":"MVC","slug":"mvc","link":"#mvc","children":[]},{"level":3,"title":"其它","slug":"其它-1","link":"#其它-1","children":[]}]},{"level":2,"title":"分布式","slug":"分布式","link":"#分布式","children":[]},{"level":2,"title":"消息队列","slug":"消息队列","link":"#消息队列","children":[{"level":3,"title":"基本概念","slug":"基本概念","link":"#基本概念","children":[]},{"level":3,"title":"Kafka","slug":"kafka","link":"#kafka","children":[]},{"level":3,"title":"RabbitMQ","slug":"rabbitmq","link":"#rabbitmq","children":[]}]},{"level":2,"title":"开发工具","slug":"开发工具","link":"#开发工具","children":[{"level":3,"title":"Linux","slug":"linux","link":"#linux","children":[]},{"level":3,"title":"Maven","slug":"maven","link":"#maven","children":[]},{"level":3,"title":"Git","slug":"git","link":"#git","children":[]},{"level":3,"title":"Docker","slug":"docker","link":"#docker","children":[]}]},{"level":2,"title":"系统设计","slug":"系统设计","link":"#系统设计","children":[]},{"level":2,"title":"手撕算法","slug":"手撕算法","link":"#手撕算法","children":[]},{"level":2,"title":"场景题","slug":"场景题","link":"#场景题","children":[]}],"git":{"createdTime":1750577650000,"updatedTime":1750577650000,"contributors":[{"name":"chanper","email":"qianchaosolo@gmail.com","commits":1}]},"filePathRelative":"coding/interview-java.md","localizedDate":"2023年3月10日","autoDesc":true}');export{vi as comp,bi as data};

import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as e,o as s}from"./app-CHBNztBQ.js";const a="/assets/%E8%A1%8C%E9%94%81-Bkza3cho.png",n="/assets/%E9%97%B4%E9%9A%99%E9%94%81-tsxxw_id.png",r="/assets/%E4%B8%B4%E9%94%AE%E9%94%81-Bdp5WObX.png",h="/assets/%E9%94%81%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-Bc411LWc.png",p={};function d(o,i){return s(),t("div",null,i[0]||(i[0]=[e(`<p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。</p><ul><li>InnoDB按照锁的粒度分为以下三类： <ul><li>全局锁：锁定数据库中的所有表，粒度最大</li><li>表级锁：每次操作锁住整张表，粒度大，并发低，但开销小加锁快</li><li>行级锁：每次操作锁住一条行数据，粒度小，并发大，但开销大加锁慢</li></ul></li><li>MyISAM、Memory等引擎仅支持表级锁，难以支持高并发的场景，且不支持事务，因此适用于只读或以读为主的场景</li><li>InnoDB 支持行级锁、表级锁，默认使用行级锁</li><li>几乎每种锁在实现上都会分共享锁（读锁）和排他锁（写锁），共享锁允许多个线程持有，但只能读数据，排他锁只有一个线程可以获取，且只有该线程可以读写数据。</li></ul><h2 id="全局锁" tabindex="-1"><a class="header-anchor" href="#全局锁"><span>全局锁</span></a></h2><p>全局锁就是对整个数据库实例加锁，是一个重操作。加锁后整个实例就处于只读状态，后续的 DML、DDL语句，以及更新类事务提交语句都将被阻塞。典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p><p><strong>语法：</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 加全局锁（FTWRL）</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">flush tables </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">with</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> read</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> lock;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 数据备份</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">mysqldump -uroot -p****** db_name </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> backup_path</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 释放锁</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">unlock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tables;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>特点：</strong></p><ul><li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li><li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。</li><li>如果是 InnoDB 引擎，可以在 mysqldump 备份时加上<code>--single-transaction</code>参数，启动一个事务，确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。</li></ul><h2 id="表级锁" tabindex="-1"><a class="header-anchor" href="#表级锁"><span>表级锁</span></a></h2><p>表级锁每次操作锁住整张表，实现简单，加锁速度快，但锁定粒度大，锁冲突的概率高，因此并发度低。表级锁分为两类：表锁、元数据锁。</p><h3 id="表锁" tabindex="-1"><a class="header-anchor" href="#表锁"><span>表锁</span></a></h3><p>表锁分为两种：</p><ul><li>表共享锁（表S锁 / 读锁）: 所有事务（包括当前加锁的客户端）都只能读，不能写</li><li>表独占锁（表X锁 / 写锁）: 当前加锁的客户端可读可写，其他客户端不可读也不可写。</li></ul><p><strong>语法：</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 加读锁</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">lock tables tb_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">read</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 加写锁</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">lock tables tb_name write;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 释放锁</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">unlock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tables;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 查看当前数据库中的加锁情况：</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> object_type, object_schema, object_name,lock_type, lock_duration </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> performance_schema</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">metadata_locks</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外，对于不支持行锁的 MyISAM 等引擎来说，默认的就是表锁，所以 DML 语句会自动加解写锁，DQL 语句自动加解读锁。还有连接断开时也会自动释放锁。</p><h3 id="元数据锁" tabindex="-1"><a class="header-anchor" href="#元数据锁"><span>元数据锁</span></a></h3><p>当查询一个表中的数据时，如果另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构就不一致了，这肯定是不合理的，这时就需要用到元数据锁。</p><p>Meta Data Lock（MDL）位于 Server 层，MDL 加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的一致性，避免 DML 与 DDL 冲突，保证读写的正确性。也就是说表上有活动事务的时候，不可以对元数据进行写入操作。</p><p>MDL 也分共享锁和排他锁：</p><ul><li>DML 和 DQL 语句会自动申请 MDL 共享锁，多个线程可同时 CRUD</li><li>DDL 语句执行期间可能申请排它锁，也可能申请共享锁，具体取决于 MySQL 版本和执行的 DDL 语句。当申请的是排他锁时，其它线程不能读写。TODO: 待补充文档@chanper</li></ul><h2 id="行级锁" tabindex="-1"><a class="header-anchor" href="#行级锁"><span>行级锁</span></a></h2><p>每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高，但开销大，加锁速度慢，而且可能出现死锁。</p><p>InnoDB 数据基于索引组织，因此行级锁在实现上是对索引上的索引项进行加锁，如果一条 SQL 语句操作了主键索引，MySQL 就会锁住这条主键索引，如果一条语句操作了非主键索引，MySQL 会先锁定该非主键索引，再锁定关联的主键索引。</p><p>行级锁实现上分为<strong>记录锁、间隙锁、临键锁</strong>，每种实现也分共享锁和排他锁，DQL 语句读取记录时需要先获取该记录的共享锁，DML 语句需要先获取该记录的排他锁。</p><h3 id="记录锁" tabindex="-1"><a class="header-anchor" href="#记录锁"><span>记录锁</span></a></h3><p>Record Lock（LOCK_REC_NOT_GAP），锁定单个行记录，防止其他事务对该行进行修改。在 RC（Read Committed）、RR（Repeatable Read）隔离级别下都支持。</p><figure><img src="`+a+'" alt="行锁" tabindex="0" loading="lazy"><figcaption>行锁</figcaption></figure><h3 id="间隙锁" tabindex="-1"><a class="header-anchor" href="#间隙锁"><span>间隙锁</span></a></h3><p>Gap Locks（LOCK_GAP）间隙锁对索引记录间隙（不含该记录）加锁，确保索引记录间隙不变，防止其他事务在这个间隙插入新记录。RR 隔离级别支持。</p><ul><li>间隙锁唯一目的是为了防止产生幻读</li><li>间隙锁可以共存，不会限制其它事务在同一间隙上加任何行锁</li><li>如果要对索引末尾加间隙锁，可以对 Supremum 伪记录加间隙锁</li></ul><figure><img src="'+n+'" alt="间隙锁" tabindex="0" loading="lazy"><figcaption>间隙锁</figcaption></figure><h3 id="临键锁" tabindex="-1"><a class="header-anchor" href="#临键锁"><span>临键锁</span></a></h3><p>Next-Key Locks（LOCK_ORDINARY）临键锁是记录锁和间隙锁的组合，同时锁住数据和数据前面的间隙（左开右闭）。RR 隔离级别支持。</p><ul><li>默认情况下 InnoDB 使用临键锁进行搜索和索引扫描，以防止幻读</li><li>临键锁只与非唯一索引列有关，唯一索引上的查询不会存在临键锁，退化为记录锁</li><li>索引上的等值查询（普通索引），向右遍历，最后一个值不满足查询需求时，临键锁退化为间隙锁</li></ul><figure><img src="'+r+'" alt="临键锁" tabindex="0" loading="lazy"><figcaption>临键锁</figcaption></figure><h3 id="加锁总结" tabindex="-1"><a class="header-anchor" href="#加锁总结"><span>加锁总结</span></a></h3><table><thead><tr><th>SQL</th><th>记录锁类型</th><th>说明</th></tr></thead><tbody><tr><td>SELECT ...</td><td>不加锁</td><td>InnoDB 引擎采用 MVCC 机制实现非阻塞读</td></tr><tr><td>SELECT ... LOCK IN SHARE MODE</td><td>共享临键锁</td><td>扫描如果有唯一索引，则降级为记录锁</td></tr><tr><td>SELECT ... FOR UPDATE</td><td>排他临键锁</td><td>扫描如果有唯一索引，则降级为记录锁</td></tr><tr><td>UPDATE ...</td><td>排他临键锁</td><td>自动加锁，扫描如果有唯一索引，则降级为记录锁</td></tr><tr><td>DELETE ...</td><td>排他临键锁</td><td>自动加锁，扫描如果有唯一索引，则降级为记录锁</td></tr><tr><td>INSERT ...</td><td>排他记录锁</td><td>在将要插入的那一行设置</td></tr></tbody></table><p>注：行级锁的实现是依靠其对应的索引，如果没用到索引的查询，就会走表锁</p><h2 id="其它锁" tabindex="-1"><a class="header-anchor" href="#其它锁"><span>其它锁</span></a></h2><h3 id="意向锁" tabindex="-1"><a class="header-anchor" href="#意向锁"><span>意向锁</span></a></h3><p>假设，事务A获取了某一行记录的排它锁，事物A尚未提交,事务B想要获取表锁时，则事物B必须要确认表的每一行都不存在排他锁，需要进行全表扫描，效率很低，此时就引入意向锁。</p><p>意向锁是 InnoDB 引擎自动维护的，当执行加行锁的语句时会自动尝试获取意向锁，无法手动操作。从范围上属于表级锁，分两种：</p><ul><li>意向共享锁（IS）：Intention Shared Lock，当一个事务准备在某条记录上加行级共享锁时，需要先获取该表的 IS 锁</li><li>意向排他锁（IX）：Intention Exclusive Lock，当一个事务准备在某条记录上加行级排他锁时，需要先获取该表的 IX 锁</li></ul><p><strong>意向锁特点：</strong></p><ol><li>从锁粒度角度：InnoDB 允许行级锁与表级锁共存,而意向锁是表锁</li><li>从锁模式角度：意向锁是一种独立类型，辅助解决记录锁效率不及的问题</li><li>从兼容性角度：意向锁包含了共享/排他两种。</li></ol><p><strong>兼容互斥性：</strong></p><ol><li>意向锁之间是互相兼容的，不管是共享意向锁还是排他意向锁</li><li>共享意向锁和表级共享锁兼容，和表级排他锁互斥</li><li>排他意向锁和表级共享锁、表级排他锁互斥</li></ol><p>注：从意向锁加锁时机来理解，如果表上有意向排他锁，说明有事务持有表内某个记录的行级排他锁，那么该表自然也不能加表级排他锁。而意向排他锁只能表明表里的某一行被加了行级排他锁，所以另一个事务也可以在该表上加意向排他锁，并对表内另一行加行级排他锁，行记录的锁由行级锁来控制。</p><h3 id="插入意向锁" tabindex="-1"><a class="header-anchor" href="#插入意向锁"><span>插入意向锁</span></a></h3><p>插入意向锁（Insert Intention Lock）是在插入数据行之前，由 INSERT 操作设置的一种间隙锁。插入意向锁表示一种插入的意图，是一种特殊的间隙锁，如果插入到相同间隙中的多个事务没有插入相同位置，则不需要互相等待。假设存在索引记录 4 和 7。两个事务分别尝试插入 5 和 6，它们在获取行排他锁之前，分别使用插入意向锁来锁定 4 到 7 之间的间隙；但是不会相互阻塞，因为插入的是不同的行。</p><h3 id="auto-inc锁" tabindex="-1"><a class="header-anchor" href="#auto-inc锁"><span>AUTO_INC锁</span></a></h3><p>用于AUTO_INCREMENT修饰的列递增赋值，innodb_autoinc_lock_mode控制赋值方案是使用AUTO_INC锁还是采用一个轻量级锁生成列值。</p><h3 id="页级锁" tabindex="-1"><a class="header-anchor" href="#页级锁"><span>页级锁</span></a></h3><p>页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。因此，采取了折衷的页级锁，一次锁定相邻的一组记录。仅 BDB 引擎支持页级锁。</p><h2 id="锁的内存结构" tabindex="-1"><a class="header-anchor" href="#锁的内存结构"><span>锁的内存结构</span></a></h2><p>对记录加锁的本质就是在内存中创建一个锁结构与之关联，如果符合以下条件，则对这些记录的锁可以放到一个锁结构中：</p><ul><li>在同一个事务中进行加锁操作</li><li>被加锁的记录在同一个页面中</li><li>加锁的类型一致</li><li>等待状态一致</li></ul><figure><img src="'+h+'" alt="锁内存结构" tabindex="0" loading="lazy"><figcaption>锁内存结构</figcaption></figure><ul><li>锁所在的事务信息：指向关于生成该锁事务的相关信息</li><li>索引信息：对于行锁需要记录加锁的记录属于哪个索引</li><li>表锁/行锁信息： <ul><li>表锁：记录对哪个表加锁，以及一些其它信息</li><li>行锁：记录表空间Id、所在页号、以及结构末尾的比特位数。每条记录对应一个比特位，记录是否加锁</li></ul></li><li>type_mode: 32位数，其中 <ul><li>低四位 - lock_mode: 锁的模式，包括LOCK_IS, LOCK_IX, LOCK_S, LOCK_X, LOCK_AUTO_INC;</li><li>5~8位 - lock_type: 锁的类型，分表锁LOCK_TABLE和行锁LOCK_REC</li><li>其余位 - rec_lock_type: 行锁具体类型，如LOCK_ORDINARY, LOCK_GAP, LOCK_REC_NOT_GAP, LOCK_INSERT_INTENTION等。并且其中的第9个比特位标志is_waiting，即是否获取到锁</li></ul></li><li>其它信息</li><li>一堆比特位：针对行锁结构，每个比特位对应一条记录，映射一个heap_no</li></ul><h2 id="参考文档" tabindex="-1"><a class="header-anchor" href="#参考文档"><span>参考文档</span></a></h2><ol><li><a href="https://juejin.cn/post/6931752749545553933" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6931752749545553933</a></li><li><a href="https://yunlongn.github.io/2021/08/06/MySQL%E5%8D%81%E4%B8%89%EF%BC%9A%E5%B0%8F%E4%B8%80%E4%B8%87%E5%AD%97+14%E5%BC%A0%E5%9B%BE%E8%AF%BB%E6%87%82%E9%94%81%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener noreferrer">https://yunlongn.github.io/2021/08/06/MySQL十三：小一万字+14张图读懂锁机制/</a></li><li><a href="https://www.cnblogs.com/better-farther-world2099/articles/14955475.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/better-farther-world2099/articles/14955475.html</a></li></ol>',62)]))}const g=l(p,[["render",d]]),u=JSON.parse('{"path":"/coding/MySQL-Lock.html","title":"MySQL 锁机制","lang":"zh-CN","frontmatter":{"title":"MySQL 锁机制","date":"2025-05-11T00:00:00.000Z","category":["数据库"],"tag":["MySQL"],"description":"锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。 InnoDB按照锁的粒度分为以下三类： 全局锁：锁定数据库中的所有表，粒度最大 表级...","head":[["meta",{"property":"og:url","content":"https://xchanper.github.io/coding/MySQL-Lock.html"}],["meta",{"property":"og:site_name","content":"chanper"}],["meta",{"property":"og:title","content":"MySQL 锁机制"}],["meta",{"property":"og:description","content":"锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。 InnoDB按照锁的粒度分为以下三类： 全局锁：锁定数据库中的所有表，粒度最大 表级..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-22T07:34:10.000Z"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:published_time","content":"2025-05-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-22T07:34:10.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL 锁机制\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-05-11T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-22T07:34:10.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"全局锁","slug":"全局锁","link":"#全局锁","children":[]},{"level":2,"title":"表级锁","slug":"表级锁","link":"#表级锁","children":[{"level":3,"title":"表锁","slug":"表锁","link":"#表锁","children":[]},{"level":3,"title":"元数据锁","slug":"元数据锁","link":"#元数据锁","children":[]}]},{"level":2,"title":"行级锁","slug":"行级锁","link":"#行级锁","children":[{"level":3,"title":"记录锁","slug":"记录锁","link":"#记录锁","children":[]},{"level":3,"title":"间隙锁","slug":"间隙锁","link":"#间隙锁","children":[]},{"level":3,"title":"临键锁","slug":"临键锁","link":"#临键锁","children":[]},{"level":3,"title":"加锁总结","slug":"加锁总结","link":"#加锁总结","children":[]}]},{"level":2,"title":"其它锁","slug":"其它锁","link":"#其它锁","children":[{"level":3,"title":"意向锁","slug":"意向锁","link":"#意向锁","children":[]},{"level":3,"title":"插入意向锁","slug":"插入意向锁","link":"#插入意向锁","children":[]},{"level":3,"title":"AUTO_INC锁","slug":"auto-inc锁","link":"#auto-inc锁","children":[]},{"level":3,"title":"页级锁","slug":"页级锁","link":"#页级锁","children":[]}]},{"level":2,"title":"锁的内存结构","slug":"锁的内存结构","link":"#锁的内存结构","children":[]},{"level":2,"title":"参考文档","slug":"参考文档","link":"#参考文档","children":[]}],"git":{"createdTime":1750577650000,"updatedTime":1750577650000,"contributors":[{"name":"chanper","email":"qianchaosolo@gmail.com","commits":1}]},"filePathRelative":"coding/MySQL-Lock.md","localizedDate":"2025年5月11日","autoDesc":true}');export{g as comp,u as data};

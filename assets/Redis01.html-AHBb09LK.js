import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as e,o as a}from"./app-CN1e8mfj.js";const s="/img/SDS%E7%BB%93%E6%9E%84.png",n="/img/%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png",h="/img/%E5%AD%97%E5%85%B8%E7%BB%93%E6%9E%84.png",p="/img/%E8%B7%B3%E8%A1%A8%E6%A6%82%E5%BF%B5.png",r="/img/%E8%B7%B3%E8%A1%A8%E5%AE%9E%E7%8E%B0.png",E="/img/%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84.png",o="/img/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E5%AE%9E%E4%BE%8B.png",c="/img/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E5%B1%9E%E6%80%A7.png",u="/img/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E7%82%B9.png",d="/img/%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B.png",g="/img/%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A0%81.png",B="/img/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1.png",m="/img/%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1_zip.png",A="/img/%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1_linked.png",_="/img/%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1_zip.png",b="/img/%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1_dict.png",x="/img/%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1_intset.png",f="/img/%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1_dict.png",S="/img/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88_ziplist.png",R="/img/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88_skiplist.png",y={};function D(C,i){return a(),t("div",null,[...i[0]||(i[0]=[e('<h2 id="简单动态字符串" tabindex="-1"><a class="header-anchor" href="#简单动态字符串"><span>简单动态字符串</span></a></h2><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span>定义</span></a></h3><p>Redis仅使用C字符串作为字面量，大多数情况下，使用<code>SDS-Simple Dynamic String</code>简单动态字符串作为字符串表示。</p><p><img src="'+s+'" alt="SDS结构"></p><ul><li>len：记录buf数组中已使用字节数，等于SDS保存字符串的长度</li><li>free：记录buf数组中未使用字节数</li><li>buf：字节数组用于保存字符串</li></ul><h3 id="与c字符串的区别" tabindex="-1"><a class="header-anchor" href="#与c字符串的区别"><span>与C字符串的区别</span></a></h3><ul><li>SDS额外记录了字符串长度，因此获取字符串长度的复杂度由O(n)缩小为O(1)</li><li>存储数据的buf数组实现了内存自动重分配，杜绝了缓冲区溢出 <ul><li>空间预分配：对SDS修改需要扩展空间时，Redis会为SDS分配额外空间 <ul><li>如果修改后len &lt; 1MB，则额外分配len长度的free空间，即len=free</li><li>如果修改后len &gt; 1MB，则额外分配1MB的free空间</li></ul></li><li>惰性空间释放：SDS需要缩短字符串时，并不立即回收多余空间，而是先记录到free字段中，等有需要时再真正释放。减少了耗时的重分配操作</li></ul></li><li>二进制安全：Redis使用len标记字符串长度，而不是根据空字符，因此可以保存任意格式二进制数据。</li><li>在存储上仍然在字符末尾加上<code>\\0</code>空字符，可以兼容部分C字符串函数</li></ul><h2 id="链表" tabindex="-1"><a class="header-anchor" href="#链表"><span>链表</span></a></h2><p><img src="'+n+'" alt="链表结构"></p><ul><li>双端、无环、带表头表尾指针、带长度计数器</li><li>支持多态，dup、free、match三个void*指针字段可以设置特殊类型函数，用于保存不同类型的值。</li></ul><h2 id="字典" tabindex="-1"><a class="header-anchor" href="#字典"><span>字典</span></a></h2><h3 id="字典实现" tabindex="-1"><a class="header-anchor" href="#字典实现"><span>字典实现</span></a></h3><p><img src="'+h+'" alt="字典结构"></p><ul><li>哈希表结点 - dictEntry <ul><li>key-value结构，其中value可以是指针、uint64_t、int64_t</li><li>next：指向同索引的下一个结点（链地址法解决哈希冲突）</li></ul></li><li>哈希表- dictht <ul><li>table：数组，存储哈希表节点指针</li><li>size：记录表的大小</li><li>sizemask：用于和哈希值计算应该放置的索引</li><li>used：已有的结点数量</li></ul></li><li>字典 - dict <ul><li>dictType：存储类型特定函数，用于实现多态</li><li>privdata：保存类型特定函数所需参数</li><li>ht：两个哈希表的数组，一般只使用ht[0]，ht[1]用于Rehash</li><li>rehashidx：是否在Rehash，不是则置-1</li></ul></li></ul><h3 id="哈希算法" tabindex="-1"><a class="header-anchor" href="#哈希算法"><span>哈希算法</span></a></h3><ul><li>Redis使用<code>MurmurHash2</code>算法，具有很好的随机分布性和计算速度</li><li>链地址法解决哈希冲突，且新节点总是添加到链表的表头以加快速度</li><li>Rehash：哈希结点过多或过少时，需要调整哈希表的大小 <ul><li>调整条件： <ul><li>扩展：服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。</li><li>扩展：服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。</li><li>收缩：服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。</li></ul></li><li>调整大小： <ul><li>如果是扩展，那么ht[1]的大小为第一个$&gt;=ht[0].used*2 \\ \\text{的} \\ 2^n$</li><li>如果是收缩，那么ht[1]的大小为第一个$&gt;=ht[0].used \\ \\text{的} \\ 2^n$</li></ul></li><li>调整步骤： <ul><li><ol><li>为ht[1]分配空间，大小计算如上</li></ol></li><li><ol start="2"><li>将ht[0]中的所有键值对重新计算哈希值和索引值，放入ht[1]</li></ol></li><li><ol start="3"><li>迁移完成后，释放ht[0]，将ht[1]设置为ht[0]，并为ht[1]创建新的空白哈希表，为下一次rehash做准备</li></ol></li></ul></li></ul></li><li>渐进式Rehash：为了避免一次性大量rehash对服务器性能造成影响，需要分多次、渐进rehash。 <ul><li>渐进方式： <ul><li><ol><li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</li></ol></li><li><ol start="2"><li>维护索引计数器变量<code>rehashidx</code>置0，表示rehash开始。</li></ol></li><li><ol start="3"><li>rehash开始后，每次对字典执行添加、删除、查找或更新操作时，程序除了执行指定操作外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，完成后将rehashidx属性的值增一。</li></ol></li><li><ol start="4"><li>随着字典操作的不断执行，最终ht[0]的所有键值对都会被rehash至ht[1]，这时将rehashidx属性的值置-1，表示rehash操作完成。</li></ol></li></ul></li><li>rehash期间的查找需要先后在ht[0]、ht[1]中查找</li><li>rehash期间的添加一律保存至ht[1]，保证ht[0]键值对只减不增</li><li>渐进式采取分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。</li></ul></li></ul><h2 id="跳表" tabindex="-1"><a class="header-anchor" href="#跳表"><span>跳表</span></a></h2><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h3><ul><li>跳表是一种有序数据结构，在每个节点中维持多个指向其它节点的指针，从而快速访问结点。</li><li>跳表效率与平衡树相当，且实现简单。</li><li>Redis中跳表的作用有两个，一是有序集合的底层实现之一，二是集群节点中用作内部数据结构。</li></ul><p><img src="'+p+'" alt="跳表概念"></p><h3 id="实现" tabindex="-1"><a class="header-anchor" href="#实现"><span>实现</span></a></h3><p><img src="'+r+'" alt="跳表实现"></p><ul><li>zskiplistNode：跳表结点 <ul><li>层：level类型数组，其中每个元素指向其它结点以加快访问。创建新结点时，根据幂次定律随机生成介于1~32之间的值作为结点层数。level类型有两个字段： <ul><li>前进指针：指向下一个结点，可以一次跳过多个结点</li><li>跨度：记录两个结点的距离 <ul><li>结点跨度越大，逻辑上相距越远</li><li>指向NULL的前进指针跨度为0</li><li>用于计算排位</li></ul></li></ul></li><li>后退节点：指向前驱结点，每次只能后退一步</li><li>分值：double型浮点数，跳表中的结点按分值从小到大排序</li><li>成员：对象指针，指向一个SDS。成员在跳表中唯一，分值相同的结点按成员字典序排序 <br></li></ul></li><li>zskiplist：维护跳表相关信息，提高效率 <ul><li>header: 指向跳表表头结点</li><li>tail：指向跳表表尾结点</li><li>level：跳表结点的最大层数</li><li>length：跳表长度，即结点数量</li></ul></li></ul><h2 id="整数集合" tabindex="-1"><a class="header-anchor" href="#整数集合"><span>整数集合</span></a></h2><p>整数集合<code>intset</code>是集合键的底层实现之一，有序且不重复。</p><h3 id="实现-1" tabindex="-1"><a class="header-anchor" href="#实现-1"><span>实现</span></a></h3><p><img src="'+E+'" alt="整数集合结构"></p><ul><li>encoding: 编码方式，包括 uint16_t / uint32_t / uint64_t 三种</li><li>length: 元素数量，即contents数组长度</li><li>contents：保存元素的数组 <ul><li>虽然声明是uint8_t，实际类型取决于encoding</li><li>所有元素类型保持一致</li><li>元素从小到大，无重复排序</li></ul></li></ul><h3 id="数组升级" tabindex="-1"><a class="header-anchor" href="#数组升级"><span>数组升级</span></a></h3><p>当添加一个新元素时，如果新元素类型比现有的所有元素类型都长，整数集合需要先升级。</p><ul><li>策略 - 复杂度O(n)： <ul><li><ol><li>根据新元素类型，扩展整数集合底层数组的空间大小，并为新元素分配空间</li></ol></li><li><ol start="2"><li>将现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，保持有序</li></ol></li><li><ol start="3"><li>将新元素添加到底层数组里面（新元素要么最大置数组头，要么最小置数组尾）</li></ol></li></ul></li><li>优点：提升了整数集合的灵活性，也节约了内存</li><li>整数集合不支持降级</li></ul><h2 id="压缩列表" tabindex="-1"><a class="header-anchor" href="#压缩列表"><span>压缩列表</span></a></h2><p>列表键和哈希键的底层实现之一，为节约内存而开发的由一系列特殊编码的连续内存块组成的顺序型数据结构。</p><h3 id="实现-2" tabindex="-1"><a class="header-anchor" href="#实现-2"><span>实现</span></a></h3><p><img src="'+o+'" alt="压缩列表实例"></p><p><img src="'+c+'" alt="压缩列表属性"></p><h3 id="列表节点" tabindex="-1"><a class="header-anchor" href="#列表节点"><span>列表节点</span></a></h3><p><img src="'+u+'" alt="压缩列表结点"></p><ul><li>每个Entry保存一个字节数组或一个整数值，由previous_entry_length, encoding, content三部分组成 <ul><li>如果是字节数组，分三种： <ul><li>长度$&lt;=(2^6-1)$的字节数组</li><li>长度$&lt;=(2^{14}-1)$的字节数组</li><li>长度$&lt;=(2^{32}-1)$的字节数组</li></ul></li><li>如果是整数值，分6种： <ul><li>4位长，介于0~12的无符号整数</li><li>1字节长有符号整数</li><li>3字节长有符号整数</li><li>int16_t类型整数</li><li>int32_t类型整数</li><li>int64_t类型整数</li></ul></li></ul></li><li>previous_entry_length: 前一个结点的长度，占1字节/5字节。可以结合当前结点地址计算出前一节点的起始地址 <ul><li>如果前一节点长度小于254，则占1字节</li><li>如果前一节点长度大于等于254，则占5字节，其中第一个字节置为0xFE作为标记</li></ul></li><li>encoding：记录content属性的类型及长度 <ul><li>如果最高位为00/01/10，则占1/2/5字节，表示content存储字节数组，数组的长度由其余位记录</li><li>如果最高位为11，则占1字节，表示content存储整数值，类型和长度由其余位记录（值甚至可能直接保存在encoding中）</li></ul></li><li>content：保存节点值，可能是字节数组/整数值</li></ul><h3 id="连锁更新" tabindex="-1"><a class="header-anchor" href="#连锁更新"><span>连锁更新</span></a></h3><p>如果压缩列表里恰好有多个连续的，长度介于250-253字节的数组，在增删改时可能引发连锁更新，导致连续的空间重分配，最坏复杂度$O(N^2)$。但实际情况下很少发生。</p><h2 id="对象" tabindex="-1"><a class="header-anchor" href="#对象"><span>对象</span></a></h2><h3 id="对象类型和编码" tabindex="-1"><a class="header-anchor" href="#对象类型和编码"><span>对象类型和编码</span></a></h3><ul><li>Redis使用对象来表示数据库中的键和值，包含字符串对象、列表对象、哈希对象、集合对象、有序集合对象五种类型</li><li>每种对象都使用了前述的至少一种数据结构（SDS，链表，字典，跳表，整数集合，压缩列表）</li><li>每个对象都由一个redisObject结构表示 <ul><li><p>type：对象类型</p><ul><li>Redis中键总是一个字符串对象，而值可以是五种对象中任意一种</li><li>使用<code>type key</code>命令输出对象类型 <img src="'+d+'" alt="对象类型"></li></ul></li><li><p>encoding：记录对象所使用的数据结构</p><ul><li>每种对象都至少使用了两种不同实现结构</li><li>Redis可以根据不同使用场景切换使用不同实现方式，提升了灵活性和效率</li><li>使用<code>object encoding key</code>命令输出对象编码 <img src="'+g+'" alt="对象编码"></li></ul></li><li><p>ptr：指向对象的底层实现数据结构</p></li></ul></li></ul><h3 id="字符串对象" tabindex="-1"><a class="header-anchor" href="#字符串对象"><span>字符串对象</span></a></h3><p>字符串对象是唯一一种会被其它四种类型嵌套的对象</p><ul><li>字符串对象的编码有三种： <ul><li>int：可以用long类型保存的整数</li><li>embstr：长度 $&lt;=32Bytes$ 的短字符串</li><li>raw：长度 $&gt;32Bytes$ 的长字符串，或无法用long保存的整数，或无法用long double保存的浮点数</li></ul></li></ul><p><img src="'+B+'" alt="字符串对象"></p><ul><li>embstr与raw编码联系： <ul><li>两者都使用redisObject和sdshdr结构表示字符串编码</li><li>raw分两次内存分配给两个结构，而embstr一次性分配连续的内存空间给两个结构。相应的释放内存次数也不同</li><li>embstr连续存储能够更好的利用缓存带来的优势</li></ul></li></ul><ul><li>编码转换：int/embstr在某些条件下会自动转换为raw编码的字符串对象 <ul><li>对于int，如果执行了一些操作，不再是整数或超出long范围，则会转换为raw</li><li>对于embstr，本身是只读对象，没有相应的操作。因此任何对embstr的修改操作，都会使其转换为raw</li></ul></li></ul><h3 id="列表对象" tabindex="-1"><a class="header-anchor" href="#列表对象"><span>列表对象</span></a></h3><ul><li>列表对象的编码有两种： <ul><li><p>ziplist：使用压缩列表实现，每个压缩列表结点保存一个列表元素 <img src="'+m+'" alt="列表对象_zip"></p></li><li><p>linkedlist：使用双端链表实现，每个链表节点保存一个字符串对象，每个字符串对象保存一个列表元素 <img src="'+A+'" alt="列表对象_linked"></p></li></ul></li></ul><ul><li>编码转换：当列表对象同时满足以下两个条件时，使用 ziplist，否则 linkedlist（参数可调） <ul><li>列表对象保存的所有字符串元素的长度都小于64Byte</li><li>列表对象保存的元素数量小于512</li></ul></li></ul><h3 id="哈希对象" tabindex="-1"><a class="header-anchor" href="#哈希对象"><span>哈希对象</span></a></h3><ul><li>哈希对象的编码有两种： <ul><li><p>ziplist：使用压缩列表实现</p><ul><li>新加入的键和值分别保存在一个压缩列表结点中，推入列表表尾 <img src="'+_+'" alt="哈希对象_zip"></li></ul></li><li><p>hashtable：使用字典实现</p><ul><li>字典的每个键都是一个字符串对象，保存键</li><li>字典的每个值都是一个字符串对象，保存值 <img src="'+b+'" alt="哈希对象_dict"></li></ul></li></ul></li></ul><ul><li>编码转换：当哈希对象同时满足以下两个条件时，使用 ziplist，否则 hashtable（参数可调） <ul><li>哈希对象保存的所有键、值的字符串长度都小于64Byte</li><li>哈希对象保存的键值对数量小于512</li></ul></li></ul><h3 id="集合对象" tabindex="-1"><a class="header-anchor" href="#集合对象"><span>集合对象</span></a></h3><ul><li>集合对象的编码有两种： <ul><li><p>intset：使用整数集合实现</p><ul><li>所有元素保存在整数集合中 <img src="'+x+'" alt="集合对象_intset"></li></ul></li><li><p>hashtable：使用字典实现</p><ul><li>字典的每个键都是一个字符串对象，保存一个集合元素</li><li>字典的每个值都是NULL <img src="'+f+'" alt="集合对象_dict"></li></ul></li></ul></li></ul><ul><li>编码转换：当集合对象同时满足以下两个条件时，使用 intset，否则 hashtable（参数可调） <ul><li>集合对象保存的所有元素都是整数值</li><li>集合对象保存的元素数量不超过512个</li></ul></li></ul><h3 id="有序集合对象" tabindex="-1"><a class="header-anchor" href="#有序集合对象"><span>有序集合对象</span></a></h3><p>有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double</p><ul><li>有序集合对象的编码有两种： <ul><li><p>ziplist：使用压缩列表实现</p><ul><li>每个元素使用两个紧挨在一起的压缩列表节点保存，第一个是元素成员，第二个是元素分值</li><li>压缩列表内的集合元素按分值从小到大排序 <img src="'+S+'" alt="有序集合_ziplist"></li></ul></li><li><p>skiplist：使用zset-跳表+字典实现</p><ul><li>跳表按分值从小到大保存所有集合元素</li><li>跳表的每个结点保存一个集合元素，object存储成员，score存储分值</li><li>跳表可以实现有序集合的范围型操作</li><li>字典创建了从成员到分值的映射</li><li>字典的每个键值对保存一个集合元素，键是成员，值是分值</li><li>字典可以实现$O(1)$查找指定元素分值</li><li>尽管可以单独用跳表或字典实现有序集合，但不能同时满足范围型操作和查找操作的效率</li><li>跳表和字典通过指针共享相同的元素，不额外浪费内存 <img src="'+R+'" alt="有序集合_skiplist"></li></ul></li></ul></li></ul><ul><li>编码转换：当有序集合对象同时满足以下两个条件时，使用 ziplist，否则 skiplist（参数可调） <ul><li>有序集合保存的元素数量小于128个</li><li>有序集合保存的所有元素成员的长度都小于64字节</li></ul></li></ul><h3 id="对象其它属性" tabindex="-1"><a class="header-anchor" href="#对象其它属性"><span>对象其它属性</span></a></h3><ul><li>类型检查： <ul><li>Redis部分命令适用于任何类型键，如DEL, EXPIRE...；称基于类型的多态命令</li><li>另一部分只能用于特定类型，如HSET, SADD...；称基于编码的多态命令</li><li>服务器根据redisObject中的type属性检查操作是否适用</li><li>服务器根据redisObject中的encoding属性检查操作的具体实现</li></ul></li><li>RefCount： <ul><li>对象周期分创建、操作、释放三个</li><li>Redis使用引用计数机制实现内存自动回收，由redisObject中的refCount记录引用数</li><li>基于refCount，相同整数值的字符串对象可以进行共享，节约内存</li><li>Redis自动对0-9999的整数值进行共享</li><li>考虑到值判等的开销，仅对包含整数值的字符串对象进行共享</li></ul></li><li>LRU： <ul><li>redisObject中的lru属性记录对象最后一次被访问的时间，用于LRU内存回收策略</li><li>也用于idletime计算空转时间</li></ul></li></ul>',65)])])}const k=l(y,[["render",D]]),$=JSON.parse('{"path":"/coding/Redis01.html","title":"Redis 数据结构","lang":"zh-CN","frontmatter":{"title":"Redis 数据结构","date":"2023-02-13T00:00:00.000Z","category":["缓存"],"tag":["Redis"],"description":"简单动态字符串 定义 Redis仅使用C字符串作为字面量，大多数情况下，使用SDS-Simple Dynamic String简单动态字符串作为字符串表示。 SDS结构 len：记录buf数组中已使用字节数，等于SDS保存字符串的长度 free：记录buf数组中未使用字节数 buf：字节数组用于保存字符串 与C字符串的区别 SDS额外记录了字符串长度，...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis 数据结构\\",\\"image\\":[\\"https://xchanper.github.io/img/SDS%E7%BB%93%E6%9E%84.png\\",\\"https://xchanper.github.io/img/%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png\\",\\"https://xchanper.github.io/img/%E5%AD%97%E5%85%B8%E7%BB%93%E6%9E%84.png\\",\\"https://xchanper.github.io/img/%E8%B7%B3%E8%A1%A8%E6%A6%82%E5%BF%B5.png\\",\\"https://xchanper.github.io/img/%E8%B7%B3%E8%A1%A8%E5%AE%9E%E7%8E%B0.png\\",\\"https://xchanper.github.io/img/%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84.png\\",\\"https://xchanper.github.io/img/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E5%AE%9E%E4%BE%8B.png\\",\\"https://xchanper.github.io/img/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E5%B1%9E%E6%80%A7.png\\",\\"https://xchanper.github.io/img/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E7%82%B9.png\\",\\"https://xchanper.github.io/img/%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B.png\\",\\"https://xchanper.github.io/img/%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A0%81.png\\",\\"https://xchanper.github.io/img/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1.png\\",\\"https://xchanper.github.io/img/%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1_zip.png\\",\\"https://xchanper.github.io/img/%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1_linked.png\\",\\"https://xchanper.github.io/img/%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1_zip.png\\",\\"https://xchanper.github.io/img/%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1_dict.png\\",\\"https://xchanper.github.io/img/%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1_intset.png\\",\\"https://xchanper.github.io/img/%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1_dict.png\\",\\"https://xchanper.github.io/img/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88_ziplist.png\\",\\"https://xchanper.github.io/img/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88_skiplist.png\\"],\\"datePublished\\":\\"2023-02-13T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-11T09:16:05.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://xchanper.github.io/coding/Redis01.html"}],["meta",{"property":"og:site_name","content":"chanper"}],["meta",{"property":"og:title","content":"Redis 数据结构"}],["meta",{"property":"og:description","content":"简单动态字符串 定义 Redis仅使用C字符串作为字面量，大多数情况下，使用SDS-Simple Dynamic String简单动态字符串作为字符串表示。 SDS结构 len：记录buf数组中已使用字节数，等于SDS保存字符串的长度 free：记录buf数组中未使用字节数 buf：字节数组用于保存字符串 与C字符串的区别 SDS额外记录了字符串长度，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://xchanper.github.io/img/SDS%E7%BB%93%E6%9E%84.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-11T09:16:05.000Z"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:published_time","content":"2023-02-13T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-11T09:16:05.000Z"}]]},"git":{"createdTime":1768122965000,"updatedTime":1768122965000,"contributors":[{"name":"chanper","username":"chanper","email":"qianchaosolo@gmail.com","commits":1,"url":"https://github.com/chanper"}]},"filePathRelative":"coding/Redis01.md","autoDesc":true}');export{k as comp,$ as data};
